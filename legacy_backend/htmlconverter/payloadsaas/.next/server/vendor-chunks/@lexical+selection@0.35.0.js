"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+selection@0.35.0";
exports.ids = ["vendor-chunks/@lexical+selection@0.35.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties),\n/* harmony export */   $copyBlockFormatIndent: () => (/* binding */ $copyBlockFormatIndent),\n/* harmony export */   $ensureForwardRangeSelection: () => (/* binding */ $ensureForwardRangeSelection),\n/* harmony export */   $forEachSelectedTextNode: () => (/* binding */ $forEachSelectedTextNode),\n/* harmony export */   $getComputedStyleForElement: () => (/* binding */ $getComputedStyleForElement),\n/* harmony export */   $getComputedStyleForParent: () => (/* binding */ $getComputedStyleForParent),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $isParentRTL: () => (/* binding */ $isParentRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getCSSFromStyleObject: () => (/* binding */ getCSSFromStyleObject),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Gets the computed DOM styles of the element.\n * @param node - The node to check the styles for.\n * @returns the computed styles of the element or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForElement(element) {\n  const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n  const domElement = editor.getElementByKey(element.getKey());\n  if (domElement === null) {\n    return null;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return null;\n  }\n  return view.getComputedStyle(domElement);\n}\n\n/**\n * Gets the computed DOM styles of the parent of the node.\n * @param node - The node to check its parent's styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForParent(node) {\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(node) ? node : node.getParentOrThrow();\n  return $getComputedStyleForElement(parent);\n}\n\n/**\n * Determines whether a node's parent is RTL.\n * @param node - The node to check whether it is RTL.\n * @returns whether the node is RTL.\n */\nfunction $isParentRTL(node) {\n  const styles = $getComputedStyleForParent(node);\n  return styles !== null && styles.direction === 'rtl';\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.isCollapsed() : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.style : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    for (const slice of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretRangeFromSelection)(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock)(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)())) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Gets the computed DOM styles of the parent of the selection's anchor node.\n * @param selection - The selection to check the styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyle(selection) {\n  const anchorNode = selection.anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n    return $getComputedStyleForElement(anchorNode);\n  }\n  return $getComputedStyleForParent(anchorNode);\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  let adjustedIsBackward = isVertical ? !isBackward : isBackward;\n\n  // In right-to-left writing mode, we invert the direction for correct caret movement\n  if ($isParentElementRTL(selection)) {\n    adjustedIsBackward = !adjustedIsBackward;\n  }\n  const focusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(focusCaret)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin)) {\n      continue;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.direction === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrc2VsZWN0aW9uQDAuMzUuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwYjtBQUMvWDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7O0FBRWdpQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hYy9TeW5jL3Byb2plY3QvZWNvbW1lcmNlL3Nob3BzYWFzL2h0bWxjb252ZXJ0ZXIvcGF5bG9hZHNhYXMvbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3NlbGVjdGlvbkAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3NlbGVjdGlvbi9MZXhpY2FsU2VsZWN0aW9uLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaXNUZXh0Tm9kZSwgJGdldEVkaXRvciwgJGlzUm9vdE5vZGUsICRpc1Rva2VuT3JTZWdtZW50ZWQsICRnZXRDaGFyYWN0ZXJPZmZzZXRzLCAkaXNFbGVtZW50Tm9kZSwgJGdldE5vZGVCeUtleSwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkY3JlYXRlVGV4dE5vZGUsICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY2FyZXRSYW5nZUZyb21TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgSU5URVJOQUxfJGlzQmxvY2ssICRzZXRTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNDaGlsZENhcmV0LCAkaXNEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNlbGVjdEFsbCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0aW9uIHJhbmdlIGZvciB0aGUgRE9NLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3JOb2RlIC0gVGhlIGFuY2hvciBub2RlIG9mIGEgc2VsZWN0aW9uLlxuICogQHBhcmFtIF9hbmNob3JPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIGZvY3VzLlxuICogQHBhcmFtIGZvY3VzTm9kZSAtIFRoZSBjdXJyZW50IGZvY3VzLlxuICogQHBhcmFtIF9mb2N1c09mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGZvY3VzIHRvIHRoZSBhbmNob3IuXG4gKiBAcmV0dXJucyBUaGUgcmFuZ2Ugb2Ygc2VsZWN0aW9uIGZvciB0aGUgRE9NIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wO1xuICAgIC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfSk7XG4gIGxldCBwcmV2UmVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIC8vIEV4Y2x1ZGUgcmVjdHMgdGhhdCBvdmVybGFwIHByZWNlZGluZyBSZWN0cyBpbiB0aGUgc29ydGVkIGxpc3QuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0O1xuICAgIC8vIEV4Y2x1ZGUgc2VsZWN0aW9ucyB0aGF0IHNwYW4gdGhlIGVudGlyZSBlbGVtZW50XG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMgcHJvdmlkZWQgaW4gdGhlIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBzdHJpbmcgb2Ygc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKiBAcmV0dXJucyBUaGUgc3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KHN0eWxlcykge1xuICBsZXQgY3NzID0gJyc7XG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29tcHV0ZWQgRE9NIHN0eWxlcyBvZiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgdGhlIHN0eWxlcyBmb3IuXG4gKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGVzIG9mIHRoZSBlbGVtZW50IG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gRE9NIGVsZW1lbnQgb3Igbm8gZGVmYXVsdCB2aWV3IGZvciB0aGUgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uICRnZXRDb21wdXRlZFN0eWxlRm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGVkaXRvciA9ICRnZXRFZGl0b3IoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWxlbWVudC5nZXRLZXkoKSk7XG4gIGlmIChkb21FbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdmlldyA9IGRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgaWYgKHZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvbXB1dGVkIERPTSBzdHlsZXMgb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgaXRzIHBhcmVudCdzIHN0eWxlcyBmb3IuXG4gKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGVzIG9mIHRoZSBub2RlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gRE9NIGVsZW1lbnQgb3Igbm8gZGVmYXVsdCB2aWV3IGZvciB0aGUgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uICRnZXRDb21wdXRlZFN0eWxlRm9yUGFyZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gJGlzUm9vdE5vZGUobm9kZSkgPyBub2RlIDogbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHJldHVybiAkZ2V0Q29tcHV0ZWRTdHlsZUZvckVsZW1lbnQocGFyZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBub2RlJ3MgcGFyZW50IGlzIFJUTC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgd2hldGhlciBpdCBpcyBSVEwuXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBub2RlIGlzIFJUTC5cbiAqL1xuZnVuY3Rpb24gJGlzUGFyZW50UlRMKG5vZGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gJGdldENvbXB1dGVkU3R5bGVGb3JQYXJlbnQobm9kZSk7XG4gIHJldHVybiBzdHlsZXMgIT09IG51bGwgJiYgc3R5bGVzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbi8qKlxuICogR2VuZXJhbGx5IHVzZWQgdG8gYXBwZW5kIHRleHQgY29udGVudCB0byBIVE1MIGFuZCBKU09OLiBHcmFicyB0aGUgdGV4dCBjb250ZW50IGFuZCBcInNsaWNlc1wiXG4gKiBpdCB0byBiZSBnZW5lcmF0ZWQgaW50byB0aGUgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gY29udGFpbmluZyB0aGUgbm9kZSB3aG9zZSBUZXh0Tm9kZSBpcyB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gdGV4dE5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYmUgZWRpdGVkLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZCh0ZXh0Tm9kZSkgJiYgYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICBpZiAoaXNBbmNob3IgfHwgaXNGb2N1cykge1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFRoaXMgbXV0YXRlcyBfX3RleHQgZGlyZWN0bHkgYmVjYXVzZSB0aGUgcHJpbWFyeSB1c2UgY2FzZSBpcyB0b1xuICAgICAgLy8gbW9kaWZ5IGEgJGNsb25lV2l0aFByb3BlcnRpZXMgbm9kZSB0aGF0IHNob3VsZCBuZXZlciBiZSBhZGRlZFxuICAgICAgLy8gdG8gdGhlIEVkaXRvclN0YXRlIHNvIHdlIG11c3Qgbm90IGNhbGwgZ2V0V3JpdGFibGUgdmlhIHNldFRleHRDb250ZW50XG4gICAgICB0ZXh0Tm9kZS5fX3RleHQgPSB0ZXh0Tm9kZS5fX3RleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IG9mIHRoZSBzZWxlY3Rpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBvaW50IG9mZnNldCBpcyBpbiB0aGUgbGFzdCBwb3NzaWJsZSBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpc0F0Tm9kZUVuZDogbm9kZSBtdXN0IGJlIGEgVGV4dE5vZGUgb3IgRWxlbWVudE5vZGVgKTtcbiAgfVxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5mdW5jdGlvbiAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3Iub2Zmc2V0KTtcbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBjdXJyZW50Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKGxhc3REZXNjZW5kYW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbGFzdERlc2NlbmRhbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IGN1cnJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSAwO1xuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG4gICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG4gICAgaWYgKHRleHQgPT09ICcnICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoISRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhJGlzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIHByZXZOb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgIC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IC0gcmVtYWluaW5nIDogMDtcbiAgICAgICAgY29uc3Qgc3BsaXRFbmQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cbmZ1bmN0aW9uICRhZGROb2RlU3R5bGUobm9kZSkge1xuICBjb25zdCBDU1NUZXh0ID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoQ1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KENTU1RleHQsIHN0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBnaXZlbiBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yXG4gKiBjb2xsYXBzZWQgUmFuZ2VTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yIGNvbGxhcHNlZCBSYW5nZVNlbGVjdGlvbiB0byBhcHBseSB0aGUgc3R5bGVzIHRvXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4gXFxcXHtDU1NQcm9wZXJ0eTogdmFsdWVcXFxcfSAuIENhbiBhbHNvIGFjY2VwdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldCkgPyB0YXJnZXQuaXNDb2xsYXBzZWQoKSA6ICRpc1RleHROb2RlKHRhcmdldCkgfHwgJGlzRWxlbWVudE5vZGUodGFyZ2V0KSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRwYXRjaFN0eWxlIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIFRleHROb2RlLCBFbGVtZW50Tm9kZSwgb3IgY29sbGFwc2VkIFJhbmdlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgcHJldlN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUygkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpID8gdGFyZ2V0LnN0eWxlIDogJGlzVGV4dE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRTdHlsZSgpIDogdGFyZ2V0LmdldFRleHRTdHlsZSgpKTtcbiAgY29uc3QgbmV3U3R5bGVzID0gT2JqZWN0LmVudHJpZXMocGF0Y2gpLnJlZHVjZSgoc3R5bGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHtcbiAgICAuLi5wcmV2U3R5bGVzXG4gIH0pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpIHx8ICRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnNldFRleHRTdHlsZShuZXdDU1NUZXh0KTtcbiAgfVxuICBDU1NfVE9fU1RZTEVTLnNldChuZXdDU1NUZXh0LCBuZXdTdHlsZXMpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIHN0eWxlcyB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKiBXaWxsIHVwZGF0ZSBwYXJ0aWFsbHkgc2VsZWN0ZWQgVGV4dE5vZGVzIGJ5IHNwbGl0dGluZyB0aGUgVGV4dE5vZGUgYW5kIGFwcGx5aW5nXG4gKiB0aGUgc3R5bGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvbmUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIG5vZGUocykgdG8gdXBkYXRlLlxuICogQHBhcmFtIHBhdGNoIC0gVGhlIHBhdGNoIHRvIGFwcGx5LCB3aGljaCBjYW4gaW5jbHVkZSBtdWx0aXBsZSBzdHlsZXMuIFxcXFx7Q1NTUHJvcGVydHk6IHZhbHVlXFxcXH0gLiBDYW4gYWxzbyBhY2NlcHQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAkcGF0Y2hTdHlsZShzZWxlY3Rpb24sIHBhdGNoKTtcbiAgICBjb25zdCBlbXB0eU5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZW1wdHlOb2RlKSAmJiBlbXB0eU5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAkcGF0Y2hTdHlsZShlbXB0eU5vZGUsIHBhdGNoKTtcbiAgICB9XG4gIH1cbiAgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlKHRleHROb2RlID0+IHtcbiAgICAkcGF0Y2hTdHlsZSh0ZXh0Tm9kZSwgcGF0Y2gpO1xuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZShmbikge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNsaWNlZFRleHROb2RlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0U2xpY2VJbmRpY2VzID0gbm9kZSA9PiBzbGljZWRUZXh0Tm9kZXMuZ2V0KG5vZGUuZ2V0S2V5KCkpIHx8IFswLCBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpXTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBmb3IgKGNvbnN0IHNsaWNlIG9mICRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24pLmdldFRleHRTbGljZXMoKSkge1xuICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHNsaWNlZFRleHROb2Rlcy5zZXQoc2xpY2UuY2FyZXQub3JpZ2luLmdldEtleSgpLCBzbGljZS5nZXRTbGljZUluZGljZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgIGlmICghKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkgJiYgc2VsZWN0ZWROb2RlLmNhbkhhdmVGb3JtYXQoKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBbc3RhcnRPZmZzZXQsIGVuZE9mZnNldF0gPSBnZXRTbGljZUluZGljZXMoc2VsZWN0ZWROb2RlKTtcbiAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICBpZiAoZW5kT2Zmc2V0ID09PSBzdGFydE9mZnNldCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGEgdG9rZW4vc2VnbWVudCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICBpZiAoJGlzVG9rZW5PclNlZ21lbnRlZChzZWxlY3RlZE5vZGUpIHx8IHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gc2VsZWN0ZWROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmbihzZWxlY3RlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG9yIHRocmVlIG5vZGVzXG4gICAgICAvLyBhbmQgc3R5bGUgdGhlIHNlbGVjdGVkIG9uZS5cbiAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBzZWxlY3RlZE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzcGxpdE5vZGVzW3N0YXJ0T2Zmc2V0ID09PSAwID8gMCA6IDFdO1xuICAgICAgZm4ocmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvLyBQcmlvciB0byBOb2RlQ2FyZXQgIzcwNDYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gYSBzaWRlLWVmZmVjdFxuICAvLyBzbyB3ZSBkbyB0aGlzIGZvciB0ZXN0IGNvbXBhdGliaWxpdHkuXG4gIC8vIFRPRE86IHdlIG1heSB3YW50IHRvIGNvbnNpZGVyIHNpbXBsaWZ5aW5nIGJ5IHJlbW92aW5nIHRoaXNcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgc2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JyAmJiBzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICRlbnN1cmVGb3J3YXJkUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBnaXZlbiBSYW5nZVNlbGVjdGlvbiBpcyBub3QgYmFja3dhcmRzLiBJZiBpdFxuICogaXMgYmFja3dhcmRzLCB0aGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIHBvaW50cyB3aWxsIGJlIHN3YXBwZWRcbiAqIGluLXBsYWNlLiBFbnN1cmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gaXMgYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICogaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIgKGUuZy4gaW4gYSByZWFkLW9ubHkgY29udGV4dFxuICogeW91IHdpbGwgd2FudCB0byBjbG9uZSAkZ2V0U2VsZWN0aW9uKCkgYmVmb3JlIHVzaW5nIHRoaXMpLlxuICpcbiAqIEBwYXJhbSBzZWxlY3Rpb24gYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICovXG5mdW5jdGlvbiAkZW5zdXJlRm9yd2FyZFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmlzQmFja3dhcmQoKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICAvLyBzdGFzaCBmb3IgdGhlIGluLXBsYWNlIHN3YXBcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBvZmZzZXQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFuY2hvcjtcbiAgICBhbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICBmb2N1cy5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRjb3B5QmxvY2tGb3JtYXRJbmRlbnQoc3JjTm9kZSwgZGVzdE5vZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gc3JjTm9kZS5nZXRGb3JtYXRUeXBlKCk7XG4gIGNvbnN0IGluZGVudCA9IHNyY05vZGUuZ2V0SW5kZW50KCk7XG4gIGlmIChmb3JtYXQgIT09IGRlc3ROb2RlLmdldEZvcm1hdFR5cGUoKSkge1xuICAgIGRlc3ROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICB9XG4gIGlmIChpbmRlbnQgIT09IGRlc3ROb2RlLmdldEluZGVudCgpKSB7XG4gICAgZGVzdE5vZGUuc2V0SW5kZW50KGluZGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtICRjcmVhdGVFbGVtZW50IC0gVGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgbm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtICRhZnRlckNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBuZXcgbm9kZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lICgkY29weUJsb2NrRm9ybWF0SW5kZW50IGJ5IGRlZmF1bHQpXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgJGNyZWF0ZUVsZW1lbnQsICRhZnRlckNyZWF0ZUVsZW1lbnQgPSAkY29weUJsb2NrRm9ybWF0SW5kZW50KSB7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2VsZWN0aW9ucyB0ZW5kIHRvIG5vdCBpbmNsdWRlIHRoZWlyIGNvbnRhaW5pbmcgYmxvY2tzIHNvIHdlIGVmZmVjdGl2ZWx5XG4gIC8vIGV4cGFuZCBpdCBoZXJlXG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGJsb2NrTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbmV3U2VsZWN0aW9uID0gbnVsbDtcbiAgaWYgKGFuY2hvckFuZEZvY3VzKSB7XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpO1xuICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAgIGNvbnN0IGFuY2hvckJsb2NrID0gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrID0gJGdldEFuY2VzdG9yKGZvY3VzLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChhbmNob3JCbG9jay5nZXRLZXkoKSwgYW5jaG9yQmxvY2spO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZm9jdXNCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChmb2N1c0Jsb2NrLmdldEtleSgpLCBmb2N1c0Jsb2NrKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5nZXROb2RlcygpKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBibG9ja01hcC5zZXQobm9kZS5nZXRLZXkoKSwgbm9kZSk7XG4gICAgfSBlbHNlIGlmIChhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jZXN0b3JCbG9jayA9ICRnZXRBbmNlc3Rvcihub2RlLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jZXN0b3JCbG9jaykpIHtcbiAgICAgICAgYmxvY2tNYXAuc2V0KGFuY2VzdG9yQmxvY2suZ2V0S2V5KCksIGFuY2VzdG9yQmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHByZXZOb2RlXSBvZiBibG9ja01hcCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAkY3JlYXRlRWxlbWVudCgpO1xuICAgICRhZnRlckNyZWF0ZUVsZW1lbnQocHJldk5vZGUsIGVsZW1lbnQpO1xuICAgIHByZXZOb2RlLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKGtleSA9PT0gbmV3U2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIG5ld1NlbGVjdGlvbi5hbmNob3IudHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBuZXdTZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmZvY3VzLm9mZnNldCwgbmV3U2VsZWN0aW9uLmZvY3VzLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3U2VsZWN0aW9uICYmIHNlbGVjdGlvbi5pcygkZ2V0U2VsZWN0aW9uKCkpKSB7XG4gICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBJbiBmYXZvciBvZiAkc2V0QmxvY2tUeXBlc1xuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgaW4gZW1wdHlFbGVtZW50cyB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDtcblxuICAvLyBJZiBvdXIgdGFyZ2V0IGlzIFJvb3QtbGlrZSwgbGV0J3Mgc2VlIGlmIHdlIGNhbiByZS1hZGp1c3RcbiAgLy8gc28gdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBmaXJzdCBjaGlsZCBpbnN0ZWFkLlxuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5hbmNob3IpICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmZvY3VzKSkge1xuICAgICRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxhc3RFbGVtZW50LnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGVsZW1lbnQgaGFzIHZlcnRpY2FsIHdyaXRpbmcgbW9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGhhcyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUgKHdyaXRpbmctbW9kZTogdmVydGljYWwtcmwpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSAkZ2V0Q29tcHV0ZWRTdHlsZShzZWxlY3Rpb24pO1xuICByZXR1cm4gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlID09PSAndmVydGljYWwtcmwnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvbXB1dGVkIERPTSBzdHlsZXMgb2YgdGhlIHBhcmVudCBvZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byBjaGVjayB0aGUgc3R5bGVzIGZvci5cbiAqIEByZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZXMgb2YgdGhlIG5vZGUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBET00gZWxlbWVudCBvciBubyBkZWZhdWx0IHZpZXcgZm9yIHRoZSBkb2N1bWVudC5cbiAqL1xuZnVuY3Rpb24gJGdldENvbXB1dGVkU3R5bGUoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgcmV0dXJuICRnZXRDb21wdXRlZFN0eWxlRm9yRWxlbWVudChhbmNob3JOb2RlKTtcbiAgfVxuICByZXR1cm4gJGdldENvbXB1dGVkU3R5bGVGb3JQYXJlbnQoYW5jaG9yTm9kZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9ICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKTtcblxuICAvLyBJbiB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHdlIGFkanVzdCB0aGUgZGlyZWN0aW9uIGZvciBjb3JyZWN0IGNhcmV0IG1vdmVtZW50XG4gIGxldCBhZGp1c3RlZElzQmFja3dhcmQgPSBpc1ZlcnRpY2FsID8gIWlzQmFja3dhcmQgOiBpc0JhY2t3YXJkO1xuXG4gIC8vIEluIHJpZ2h0LXRvLWxlZnQgd3JpdGluZyBtb2RlLCB3ZSBpbnZlcnQgdGhlIGRpcmVjdGlvbiBmb3IgY29ycmVjdCBjYXJldCBtb3ZlbWVudFxuICBpZiAoJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pKSB7XG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gIWFkanVzdGVkSXNCYWNrd2FyZDtcbiAgfVxuICBjb25zdCBmb2N1c0NhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgYWRqdXN0ZWRJc0JhY2t3YXJkID8gJ3ByZXZpb3VzJyA6ICduZXh0Jyk7XG4gIGlmICgkaXNFeHRlbmRhYmxlVGV4dFBvaW50Q2FyZXQoZm9jdXNDYXJldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBuZXh0Q2FyZXQgb2YgJGV4dGVuZENhcmV0VG9SYW5nZShmb2N1c0NhcmV0KSkge1xuICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgIHJldHVybiAhbmV4dENhcmV0Lm9yaWdpbi5pc0lubGluZSgpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Q2FyZXQub3JpZ2luKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gJGdldENvbXB1dGVkU3R5bGUoc2VsZWN0aW9uKTtcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG4vKipcbiAqIE1vdmVzIHNlbGVjdGlvbiBieSBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIHRoZSBjaGFyYWN0ZXJzIHRvIG1vdmUuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZCAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqL1xuZnVuY3Rpb24gJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBpc1JUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9ICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKTtcblxuICAvLyBJbiB2ZXJ0aWNhbC1ybCB3cml0aW5nIG1vZGUsIGFycm93IGtleSBkaXJlY3Rpb25zIG5lZWQgdG8gYmUgZmxpcHBlZFxuICAvLyB0byBtYXRjaCB0aGUgdmlzdWFsIGZsb3cgb2YgdGV4dCAodG9wIHRvIGJvdHRvbSwgcmlnaHQgdG8gbGVmdClcbiAgbGV0IGFkanVzdGVkSXNCYWNrd2FyZDtcbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAvLyBJbiB2ZXJ0aWNhbC1ybCBtb2RlLCB3ZSBuZWVkIHRvIGNvbXBsZXRlbHkgaW52ZXJ0IHRoZSBkaXJlY3Rpb25cbiAgICAvLyBMZWZ0IGFycm93IChiYWNrd2FyZCkgc2hvdWxkIG1vdmUgZG93biAoZm9yd2FyZClcbiAgICAvLyBSaWdodCBhcnJvdyAoZm9yd2FyZCkgc2hvdWxkIG1vdmUgdXAgKGJhY2t3YXJkKVxuICAgIGFkanVzdGVkSXNCYWNrd2FyZCA9ICFpc0JhY2t3YXJkO1xuICB9IGVsc2UgaWYgKGlzUlRMKSB7XG4gICAgLy8gSW4gaG9yaXpvbnRhbCBSVEwgbW9kZSwgdXNlIHRoZSBzdGFuZGFyZCBSVEwgYmVoYXZpb3JcbiAgICBhZGp1c3RlZElzQmFja3dhcmQgPSAhaXNCYWNrd2FyZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGFuZGFyZCBMVFIgaG9yaXpvbnRhbCB0ZXh0XG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gaXNCYWNrd2FyZDtcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBkaXJlY3Rpb24gYWRqdXN0bWVudCB0byBtb3ZlIHRoZSBjYXJldFxuICAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGFkanVzdGVkSXNCYWNrd2FyZCwgJ2NoYXJhY3RlcicpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIE5vZGVzLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgd2hvc2Ugc3R5bGUgdmFsdWUgdG8gZ2V0LlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciBub2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgY3NzID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV0gfHwgZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24sIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogSWYgYWxsIFRleHROb2RlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBUZXh0Tm9kZXMgd2hvc2UgdmFsdWUgdG8gZmluZC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgc2VsZWN0ZWQgVGV4dE5vZGVzLlxuICovXG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5KHNlbGVjdGlvbiwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlID0gJycpIHtcbiAgbGV0IHN0eWxlVmFsdWUgPSBudWxsO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1cy5vZmZzZXQgOiBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBlbmROb2RlID0gaXNCYWNrd2FyZCA/IGZvY3VzLmdldE5vZGUoKSA6IGFuY2hvci5nZXROb2RlKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5zdHlsZSAhPT0gJycpIHtcbiAgICBjb25zdCBjc3MgPSBzZWxlY3Rpb24uc3R5bGU7XG4gICAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwgJiYgc3R5bGVQcm9wZXJ0eSBpbiBzdHlsZU9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgLy8gaWYgbm8gYWN0dWFsIGNoYXJhY3RlcnMgaW4gdGhlIGVuZCBub2RlIGFyZSBzZWxlY3RlZCwgd2UgZG9uJ3RcbiAgICAvLyBpbmNsdWRlIGl0IGluIHRoZSBzZWxlY3Rpb24gZm9yIHB1cnBvc2VzIG9mIGRldGVybWluaW5nIHN0eWxlXG4gICAgLy8gdmFsdWVcbiAgICBpZiAoaSAhPT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgbm9kZS5pcyhlbmROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3Qgbm9kZVN0eWxlVmFsdWUgPSAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IG5vZGVTdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVZhbHVlICE9PSBub2RlU3R5bGVWYWx1ZSkge1xuICAgICAgICAvLyBtdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBpbiB0aGUgc2VsZWN0aW9uIGFuZCB0aGV5IGRvbid0IGFsbFxuICAgICAgICAvLyBoYXZlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBzdHlsZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVWYWx1ZSA9PT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IHN0eWxlVmFsdWU7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgPSAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcjtcblxuZXhwb3J0IHsgJGFkZE5vZGVTdHlsZSwgJGNvcHlCbG9ja0Zvcm1hdEluZGVudCwgJGVuc3VyZUZvcndhcmRSYW5nZVNlbGVjdGlvbiwgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlLCAkZ2V0Q29tcHV0ZWRTdHlsZUZvckVsZW1lbnQsICRnZXRDb21wdXRlZFN0eWxlRm9yUGFyZW50LCAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5LCAkaXNBdE5vZGVFbmQsICRpc1BhcmVudEVsZW1lbnRSVEwsICRpc1BhcmVudFJUTCwgJG1vdmVDYXJldFNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIsICRwYXRjaFN0eWxlVGV4dCwgJHNldEJsb2Nrc1R5cGUsICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50LCAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciwgJHdyYXBOb2RlcywgY3JlYXRlRE9NUmFuZ2UsIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCBnZXRDU1NGcm9tU3R5bGVPYmplY3QsIGdldFN0eWxlT2JqZWN0RnJvbUNTUywgdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $addNodeStyle: () => (/* binding */ $addNodeStyle),\n/* harmony export */   $cloneWithProperties: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$cloneWithProperties),\n/* harmony export */   $copyBlockFormatIndent: () => (/* binding */ $copyBlockFormatIndent),\n/* harmony export */   $ensureForwardRangeSelection: () => (/* binding */ $ensureForwardRangeSelection),\n/* harmony export */   $forEachSelectedTextNode: () => (/* binding */ $forEachSelectedTextNode),\n/* harmony export */   $getComputedStyleForElement: () => (/* binding */ $getComputedStyleForElement),\n/* harmony export */   $getComputedStyleForParent: () => (/* binding */ $getComputedStyleForParent),\n/* harmony export */   $getSelectionStyleValueForProperty: () => (/* binding */ $getSelectionStyleValueForProperty),\n/* harmony export */   $isAtNodeEnd: () => (/* binding */ $isAtNodeEnd),\n/* harmony export */   $isParentElementRTL: () => (/* binding */ $isParentElementRTL),\n/* harmony export */   $isParentRTL: () => (/* binding */ $isParentRTL),\n/* harmony export */   $moveCaretSelection: () => (/* binding */ $moveCaretSelection),\n/* harmony export */   $moveCharacter: () => (/* binding */ $moveCharacter),\n/* harmony export */   $patchStyleText: () => (/* binding */ $patchStyleText),\n/* harmony export */   $selectAll: () => (/* reexport safe */ lexical__WEBPACK_IMPORTED_MODULE_0__.$selectAll),\n/* harmony export */   $setBlocksType: () => (/* binding */ $setBlocksType),\n/* harmony export */   $shouldOverrideDefaultCharacterSelection: () => (/* binding */ $shouldOverrideDefaultCharacterSelection),\n/* harmony export */   $sliceSelectedTextNodeContent: () => (/* binding */ $sliceSelectedTextNodeContent),\n/* harmony export */   $trimTextContentFromAnchor: () => (/* binding */ $trimTextContentFromAnchor),\n/* harmony export */   $wrapNodes: () => (/* binding */ $wrapNodes),\n/* harmony export */   createDOMRange: () => (/* binding */ createDOMRange),\n/* harmony export */   createRectsFromDOMRange: () => (/* binding */ createRectsFromDOMRange),\n/* harmony export */   getCSSFromStyleObject: () => (/* binding */ getCSSFromStyleObject),\n/* harmony export */   getStyleObjectFromCSS: () => (/* binding */ getStyleObjectFromCSS),\n/* harmony export */   trimTextContentFromAnchor: () => (/* binding */ trimTextContentFromAnchor)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n    node = node.firstChild;\n  }\n  return null;\n}\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n  const firstChild = anchorDOM.firstChild;\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n  return range;\n}\n\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n  if (rootElement === null) {\n    return [];\n  }\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length;\n  //sort rects from top left to bottom right.\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top;\n    // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n    return top;\n  });\n  let prevRect;\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i];\n    // Exclude rects that overlap preceding Rects in the sorted list.\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;\n    // Exclude selections that span the entire element\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n    prevRect = selectionRect;\n  }\n  return selectionRects;\n}\n\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  if (!css) {\n    return styleObject;\n  }\n  const styles = css.split(';');\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n      if (key && value) {\n        styleObject[key.trim()] = value.trim();\n      }\n    }\n  }\n  return styleObject;\n}\n\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n  return value;\n}\n\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n  return css;\n}\n\n/**\n * Gets the computed DOM styles of the element.\n * @param node - The node to check the styles for.\n * @returns the computed styles of the element or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForElement(element) {\n  const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)();\n  const domElement = editor.getElementByKey(element.getKey());\n  if (domElement === null) {\n    return null;\n  }\n  const view = domElement.ownerDocument.defaultView;\n  if (view === null) {\n    return null;\n  }\n  return view.getComputedStyle(domElement);\n}\n\n/**\n * Gets the computed DOM styles of the parent of the node.\n * @param node - The node to check its parent's styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyleForParent(node) {\n  const parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(node) ? node : node.getParentOrThrow();\n  return $getComputedStyleForElement(parent);\n}\n\n/**\n * Determines whether a node's parent is RTL.\n * @param node - The node to check whether it is RTL.\n * @returns whether the node is RTL.\n */\nfunction $isParentRTL(node) {\n  const styles = $getComputedStyleForParent(node);\n  return styles !== null && styles.direction === 'rtl';\n}\n\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  if (textNode.isSelected(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(textNode) && anchorAndFocus !== null) {\n    const [anchor, focus] = anchorAndFocus;\n    const isBackward = selection.isBackward();\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n    if (isAnchor || isFocus) {\n      const [anchorOffset, focusOffset] = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getCharacterOffsets)(selection);\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      // NOTE: This mutates __text directly because the primary use case is to\n      // modify a $cloneWithProperties node that should never be added\n      // to the EditorState so we must not call getWritable via setTextContent\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n    }\n  }\n  return textNode;\n}\n\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n  const node = point.getNode();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n    formatDevErrorMessage(`isAtNodeEnd: node must be a TextNode or ElementNode`);\n  }\n  return point.offset === node.getChildrenSize();\n}\n\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\nfunction $trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n  while (remaining > 0 && currentNode !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      const lastDescendant = currentNode.getLastDescendant();\n      if (lastDescendant !== null) {\n        currentNode = lastDescendant;\n      }\n    }\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n      while (parentSibling === null) {\n        parent = parent.getParent();\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n        parentSibling = parent.getPreviousSibling();\n      }\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n        nextNode = parentSibling;\n      }\n    }\n    let text = currentNode.getTextContent();\n    // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n    if (text === '' && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n    const currentNodeSize = text.length;\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n      if (parent != null && parent.getChildrenSize() === 0 && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent)) {\n        parent.remove();\n      }\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey();\n      // See if we can just revert it to what was in the last editor state\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(key);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        let target = currentNode;\n        if (!currentNode.isSimpleText()) {\n          const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset;\n        // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(slicedText);\n        currentNode.replace(textNode);\n      }\n      remaining = 0;\n    }\n  }\n}\n\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\n/**\n * Applies the provided styles to the given TextNode, ElementNode, or\n * collapsed RangeSelection.\n *\n * @param target - The TextNode, ElementNode, or collapsed RangeSelection to apply the styles to\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyle(target, patch) {\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.isCollapsed() : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(target))) {\n    formatDevErrorMessage(`$patchStyle must only be called with a TextNode, ElementNode, or collapsed RangeSelection`);\n  }\n  const prevStyles = getStyleObjectFromCSS((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) ? target.style : (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target) ? target.getStyle() : target.getTextStyle());\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (typeof value === 'function') {\n      styles[key] = value(prevStyles[key], target);\n    } else if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n    return styles;\n  }, {\n    ...prevStyles\n  });\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(target) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(target)) {\n    target.setStyle(newCSSText);\n  } else {\n    target.setTextStyle(newCSSText);\n  }\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. \\\\{CSSProperty: value\\\\} . Can also accept a function that returns the new property value.\n */\nfunction $patchStyleText(selection, patch) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    const emptyNode = selection.anchor.getNode();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(emptyNode) && emptyNode.isEmpty()) {\n      $patchStyle(emptyNode, patch);\n    }\n  }\n  $forEachSelectedTextNode(textNode => {\n    $patchStyle(textNode, patch);\n  });\n}\nfunction $forEachSelectedTextNode(fn) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!selection) {\n    return;\n  }\n  const slicedTextNodes = new Map();\n  const getSliceIndices = node => slicedTextNodes.get(node.getKey()) || [0, node.getTextContentSize()];\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    for (const slice of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretRangeFromSelection)(selection).getTextSlices()) {\n      if (slice) {\n        slicedTextNodes.set(slice.caret.origin.getKey(), slice.getSliceIndices());\n      }\n    }\n  }\n  const selectedNodes = selection.getNodes();\n  for (const selectedNode of selectedNodes) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(selectedNode) && selectedNode.canHaveFormat())) {\n      continue;\n    }\n    const [startOffset, endOffset] = getSliceIndices(selectedNode);\n    // No actual text is selected, so do nothing.\n    if (endOffset === startOffset) {\n      continue;\n    }\n\n    // The entire node is selected or a token/segment, so just format it\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTokenOrSegmented)(selectedNode) || startOffset === 0 && endOffset === selectedNode.getTextContentSize()) {\n      fn(selectedNode);\n    } else {\n      // The node is partially selected, so split it into two or three nodes\n      // and style the selected one.\n      const splitNodes = selectedNode.splitText(startOffset, endOffset);\n      const replacement = splitNodes[startOffset === 0 ? 0 : 1];\n      fn(replacement);\n    }\n  }\n  // Prior to NodeCaret #7046 this would have been a side-effect\n  // so we do this for test compatibility.\n  // TODO: we may want to consider simplifying by removing this\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.anchor.type === 'text' && selection.focus.type === 'text' && selection.anchor.key === selection.focus.key) {\n    $ensureForwardRangeSelection(selection);\n  }\n}\n\n/**\n * Ensure that the given RangeSelection is not backwards. If it\n * is backwards, then the anchor and focus points will be swapped\n * in-place. Ensuring that the selection is a writable RangeSelection\n * is the responsibility of the caller (e.g. in a read-only context\n * you will want to clone $getSelection() before using this).\n *\n * @param selection a writable RangeSelection\n */\nfunction $ensureForwardRangeSelection(selection) {\n  if (selection.isBackward()) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    // stash for the in-place swap\n    const {\n      key,\n      offset,\n      type\n    } = anchor;\n    anchor.set(focus.key, focus.offset, focus.type);\n    focus.set(key, offset, type);\n  }\n}\n\nfunction $copyBlockFormatIndent(srcNode, destNode) {\n  const format = srcNode.getFormatType();\n  const indent = srcNode.getIndent();\n  if (format !== destNode.getFormatType()) {\n    destNode.setFormat(format);\n  }\n  if (indent !== destNode.getIndent()) {\n    destNode.setIndent(indent);\n  }\n}\n\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param $createElement - The function that creates the node. eg. $createParagraphNode.\n * @param $afterCreateElement - The function that updates the new node based on the previous one ($copyBlockFormatIndent by default)\n */\nfunction $setBlocksType(selection, $createElement, $afterCreateElement = $copyBlockFormatIndent) {\n  if (selection === null) {\n    return;\n  }\n  // Selections tend to not include their containing blocks so we effectively\n  // expand it here\n  const anchorAndFocus = selection.getStartEndPoints();\n  const blockMap = new Map();\n  let newSelection = null;\n  if (anchorAndFocus) {\n    const [anchor, focus] = anchorAndFocus;\n    newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    newSelection.anchor.set(anchor.key, anchor.offset, anchor.type);\n    newSelection.focus.set(focus.key, focus.offset, focus.type);\n    const anchorBlock = $getAncestor(anchor.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    const focusBlock = $getAncestor(focus.getNode(), lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorBlock)) {\n      blockMap.set(anchorBlock.getKey(), anchorBlock);\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusBlock)) {\n      blockMap.set(focusBlock.getKey(), focusBlock);\n    }\n  }\n  for (const node of selection.getNodes()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock)(node)) {\n      blockMap.set(node.getKey(), node);\n    } else if (anchorAndFocus === null) {\n      const ancestorBlock = $getAncestor(node, lexical__WEBPACK_IMPORTED_MODULE_0__.INTERNAL_$isBlock);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(ancestorBlock)) {\n        blockMap.set(ancestorBlock.getKey(), ancestorBlock);\n      }\n    }\n  }\n  for (const [key, prevNode] of blockMap) {\n    const element = $createElement();\n    $afterCreateElement(prevNode, element);\n    prevNode.replace(element, true);\n    if (newSelection) {\n      if (key === newSelection.anchor.key) {\n        newSelection.anchor.set(element.getKey(), newSelection.anchor.offset, newSelection.anchor.type);\n      }\n      if (key === newSelection.focus.key) {\n        newSelection.focus.set(element.getKey(), newSelection.focus.offset, newSelection.focus.type);\n      }\n    }\n  }\n  if (newSelection && selection.is((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)())) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n  }\n}\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n  while (node !== null && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n    node = parentNode;\n  }\n}\n\n/**\n * @deprecated In favor of $setBlockTypes\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const anchorAndFocus = selection.getStartEndPoints();\n  const anchor = anchorAndFocus ? anchorAndFocus[0] : null;\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  if (anchor !== null && (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0)) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n    target.replace(element);\n    return;\n  }\n  let topLevelNode = null;\n  let descendants = [];\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$hasAncestor)(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = [];\n  // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n  let target = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstNode) ? firstNode : firstNode.getParentOrThrow();\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n  let targetIsPrevSibling = false;\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n    target = target.getParentOrThrow();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n      break;\n    }\n  }\n  const emptyElements = new Set();\n\n  // Find any top level empty elements\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n  const movedNodes = new Set();\n\n  // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n    if (parent !== null && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement);\n        // Move node and its siblings to the new\n        // element.\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        formatDevErrorMessage(`Expected node in emptyElements to be an ElementNode`);\n      }\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n  let lastElement = null;\n\n  // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(firstChild)) {\n        target = firstChild;\n      }\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n\n/**\n * Tests if the selection's parent element has vertical writing mode.\n * @param selection - The selection whose parent to test.\n * @returns true if the selection's parent has vertical writing mode (writing-mode: vertical-rl), false otherwise.\n */\nfunction $isEditorVerticalOrientation(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.writingMode === 'vertical-rl';\n}\n\n/**\n * Gets the computed DOM styles of the parent of the selection's anchor node.\n * @param selection - The selection to check the styles for.\n * @returns the computed styles of the node or null if there is no DOM element or no default view for the document.\n */\nfunction $getComputedStyle(selection) {\n  const anchorNode = selection.anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n    return $getComputedStyleForElement(anchorNode);\n  }\n  return $getComputedStyleForParent(anchorNode);\n}\n\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical writing mode, we adjust the direction for correct caret movement\n  let adjustedIsBackward = isVertical ? !isBackward : isBackward;\n\n  // In right-to-left writing mode, we invert the direction for correct caret movement\n  if ($isParentElementRTL(selection)) {\n    adjustedIsBackward = !adjustedIsBackward;\n  }\n  const focusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, adjustedIsBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(focusCaret)) {\n    return false;\n  }\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(focusCaret)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n      return !nextCaret.origin.isInline();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin)) {\n      continue;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(nextCaret.origin)) {\n      return true;\n    }\n    break;\n  }\n  return false;\n}\n\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\nfunction $isParentElementRTL(selection) {\n  const computedStyle = $getComputedStyle(selection);\n  return computedStyle !== null && computedStyle.direction === 'rtl';\n}\n\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  const isVertical = $isEditorVerticalOrientation(selection);\n\n  // In vertical-rl writing mode, arrow key directions need to be flipped\n  // to match the visual flow of text (top to bottom, right to left)\n  let adjustedIsBackward;\n  if (isVertical) {\n    // In vertical-rl mode, we need to completely invert the direction\n    // Left arrow (backward) should move down (forward)\n    // Right arrow (forward) should move up (backward)\n    adjustedIsBackward = !isBackward;\n  } else if (isRTL) {\n    // In horizontal RTL mode, use the standard RTL behavior\n    adjustedIsBackward = !isBackward;\n  } else {\n    // Standard LTR horizontal text\n    adjustedIsBackward = isBackward;\n  }\n\n  // Apply the direction adjustment to move the caret\n  $moveCaretSelection(selection, isHoldingShift, adjustedIsBackward, 'character');\n}\n\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n  return defaultValue;\n}\n\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed() && selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n  return styleValue === null ? defaultValue : styleValue;\n}\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @deprecated renamed to {@link $trimTextContentFromAnchor} by @lexical/eslint-plugin rules-of-lexical */\nconst trimTextContentFromAnchor = $trimTextContentFromAnchor;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrc2VsZWN0aW9uQDAuMzUuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvc2VsZWN0aW9uL0xleGljYWxTZWxlY3Rpb24uZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwYjtBQUMvWDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLDBCQUEwQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTSxJQUFJLGVBQWU7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1EQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvREFBVztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsNERBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyx1REFBYztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0RBQVc7QUFDcEI7QUFDQTtBQUNBLCtEQUErRCxvREFBVztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsc0RBQWE7QUFDdEMsWUFBWSxvREFBVztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDhEQUFxQjtBQUNuRDtBQUNBO0FBQ0EsMkJBQTJCLHdEQUFlO0FBQzFDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVksMERBQWlCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCLHdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxzQkFBc0I7QUFDbEc7QUFDQTtBQUNBLFFBQVEsMERBQWlCLGtDQUFrQyxvREFBVyxZQUFZLHVEQUFjO0FBQ2hHO0FBQ0E7QUFDQSwyQ0FBMkMsMERBQWlCLDBCQUEwQixvREFBVztBQUNqRztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBTSwwREFBaUIsWUFBWSxvREFBVztBQUM5QztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLHNCQUFzQjtBQUNsRztBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2Qix3QkFBd0IsaUVBQXdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxvREFBVztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwwREFBaUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUFxQjtBQUN4QztBQUNBO0FBQ0EsdURBQXVELHNEQUFpQjtBQUN4RSxxREFBcUQsc0RBQWlCO0FBQ3RFLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjLFVBQVUsMERBQWlCO0FBQ2pEO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxzREFBaUI7QUFDaEUsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHNEQUFhO0FBQ2hELElBQUksc0RBQWE7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNERBQW1CO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw0REFBbUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyREFBMkQscURBQVk7QUFDN0U7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHVEQUFjO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBLFFBQVEsdURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9EQUFXO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdURBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxNQUFNO0FBQ04sV0FBVyx1REFBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTSw0REFBbUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsVUFBVSx1REFBYztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTix3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsOERBQXFCO0FBQzdDLE1BQU0sMERBQWlCO0FBQ3ZCLElBQUksc0RBQWE7QUFDakIsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHVEQUFjO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQix3REFBZTtBQUNwQyxNQUFNLG9FQUEyQjtBQUNqQztBQUNBO0FBQ0EsMEJBQTBCLDREQUFtQjtBQUM3QyxRQUFRLHNEQUFhO0FBQ3JCO0FBQ0EsTUFBTSxTQUFTLHVEQUFjO0FBQzdCO0FBQ0EsTUFBTSxTQUFTLHlEQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDBEQUFpQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7O0FBRWdpQiIsInNvdXJjZXMiOlsiL1VzZXJzL21hYy9TeW5jL3Byb2plY3QvZWNvbW1lcmNlL3Nob3BzYWFzL2h0bWxjb252ZXJ0ZXIvcGF5bG9hZHNhYXMvbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK3NlbGVjdGlvbkAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3NlbGVjdGlvbi9MZXhpY2FsU2VsZWN0aW9uLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyAkaXNUZXh0Tm9kZSwgJGdldEVkaXRvciwgJGlzUm9vdE5vZGUsICRpc1Rva2VuT3JTZWdtZW50ZWQsICRnZXRDaGFyYWN0ZXJPZmZzZXRzLCAkaXNFbGVtZW50Tm9kZSwgJGdldE5vZGVCeUtleSwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkY3JlYXRlVGV4dE5vZGUsICRpc1JhbmdlU2VsZWN0aW9uLCAkZ2V0U2VsZWN0aW9uLCAkY2FyZXRSYW5nZUZyb21TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgSU5URVJOQUxfJGlzQmxvY2ssICRzZXRTZWxlY3Rpb24sICRpc1Jvb3RPclNoYWRvd1Jvb3QsICRoYXNBbmNlc3RvciwgJGlzTGVhZk5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNDaGlsZENhcmV0LCAkaXNEZWNvcmF0b3JOb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5leHBvcnQgeyAkY2xvbmVXaXRoUHJvcGVydGllcywgJHNlbGVjdEFsbCB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cbmNvbnN0IENTU19UT19TVFlMRVMgPSBuZXcgTWFwKCk7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gZ2V0RE9NVGV4dE5vZGUoZWxlbWVudCkge1xuICBsZXQgbm9kZSA9IGVsZW1lbnQ7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQobm9kZSkge1xuICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gIGlmIChwYXJlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5ldmVyIGhhcHBlbicpO1xuICB9XG4gIHJldHVybiBbcGFyZW50LCBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5pbmRleE9mKG5vZGUpXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc2VsZWN0aW9uIHJhbmdlIGZvciB0aGUgRE9NLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBhbmNob3JOb2RlIC0gVGhlIGFuY2hvciBub2RlIG9mIGEgc2VsZWN0aW9uLlxuICogQHBhcmFtIF9hbmNob3JPZmZzZXQgLSBUaGUgYW1vdW50IG9mIHNwYWNlIG9mZnNldCBmcm9tIHRoZSBhbmNob3IgdG8gdGhlIGZvY3VzLlxuICogQHBhcmFtIGZvY3VzTm9kZSAtIFRoZSBjdXJyZW50IGZvY3VzLlxuICogQHBhcmFtIF9mb2N1c09mZnNldCAtIFRoZSBhbW91bnQgb2Ygc3BhY2Ugb2Zmc2V0IGZyb20gdGhlIGZvY3VzIHRvIHRoZSBhbmNob3IuXG4gKiBAcmV0dXJucyBUaGUgcmFuZ2Ugb2Ygc2VsZWN0aW9uIGZvciB0aGUgRE9NIHRoYXQgd2FzIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTVJhbmdlKGVkaXRvciwgYW5jaG9yTm9kZSwgX2FuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBfZm9jdXNPZmZzZXQpIHtcbiAgY29uc3QgYW5jaG9yS2V5ID0gYW5jaG9yTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgZm9jdXNLZXkgPSBmb2N1c05vZGUuZ2V0S2V5KCk7XG4gIGNvbnN0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgbGV0IGFuY2hvckRPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yS2V5KTtcbiAgbGV0IGZvY3VzRE9NID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShmb2N1c0tleSk7XG4gIGxldCBhbmNob3JPZmZzZXQgPSBfYW5jaG9yT2Zmc2V0O1xuICBsZXQgZm9jdXNPZmZzZXQgPSBfZm9jdXNPZmZzZXQ7XG4gIGlmICgkaXNUZXh0Tm9kZShhbmNob3JOb2RlKSkge1xuICAgIGFuY2hvckRPTSA9IGdldERPTVRleHROb2RlKGFuY2hvckRPTSk7XG4gIH1cbiAgaWYgKCRpc1RleHROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICBmb2N1c0RPTSA9IGdldERPTVRleHROb2RlKGZvY3VzRE9NKTtcbiAgfVxuICBpZiAoYW5jaG9yTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGZvY3VzTm9kZSA9PT0gdW5kZWZpbmVkIHx8IGFuY2hvckRPTSA9PT0gbnVsbCB8fCBmb2N1c0RPTSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChhbmNob3JET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbYW5jaG9yRE9NLCBhbmNob3JPZmZzZXRdID0gZ2V0RE9NSW5kZXhXaXRoaW5QYXJlbnQoYW5jaG9yRE9NKTtcbiAgfVxuICBpZiAoZm9jdXNET00ubm9kZU5hbWUgPT09ICdCUicpIHtcbiAgICBbZm9jdXNET00sIGZvY3VzT2Zmc2V0XSA9IGdldERPTUluZGV4V2l0aGluUGFyZW50KGZvY3VzRE9NKTtcbiAgfVxuICBjb25zdCBmaXJzdENoaWxkID0gYW5jaG9yRE9NLmZpcnN0Q2hpbGQ7XG4gIGlmIChhbmNob3JET00gPT09IGZvY3VzRE9NICYmIGZpcnN0Q2hpbGQgIT0gbnVsbCAmJiBmaXJzdENoaWxkLm5vZGVOYW1lID09PSAnQlInICYmIGFuY2hvck9mZnNldCA9PT0gMCAmJiBmb2N1c09mZnNldCA9PT0gMCkge1xuICAgIGZvY3VzT2Zmc2V0ID0gMTtcbiAgfVxuICB0cnkge1xuICAgIHJhbmdlLnNldFN0YXJ0KGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgICByYW5nZS5zZXRFbmQoZm9jdXNET00sIGZvY3VzT2Zmc2V0KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChyYW5nZS5jb2xsYXBzZWQgJiYgKGFuY2hvck9mZnNldCAhPT0gZm9jdXNPZmZzZXQgfHwgYW5jaG9yS2V5ICE9PSBmb2N1c0tleSkpIHtcbiAgICAvLyBSYW5nZSBpcyBiYWNrd2FyZHMsIHdlIG5lZWQgdG8gcmV2ZXJzZSBpdFxuICAgIHJhbmdlLnNldFN0YXJ0KGZvY3VzRE9NLCBmb2N1c09mZnNldCk7XG4gICAgcmFuZ2Uuc2V0RW5kKGFuY2hvckRPTSwgYW5jaG9yT2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gcmFuZ2U7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBET01SZWN0cywgZ2VuZXJhbGx5IHVzZWQgdG8gaGVscCB0aGUgZWRpdG9yIGZpbmQgYSBzcGVjaWZpYyBsb2NhdGlvbiBvbiB0aGUgc2NyZWVuLlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvclxuICogQHBhcmFtIHJhbmdlIC0gQSBmcmFnbWVudCBvZiBhIGRvY3VtZW50IHRoYXQgY2FuIGNvbnRhaW4gbm9kZXMgYW5kIHBhcnRzIG9mIHRleHQgbm9kZXMuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0aW9uUmVjdHMgYXMgYW4gYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlKGVkaXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKHJvb3RFbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGNvbnN0IHJvb3RSZWN0ID0gcm9vdEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKHJvb3RFbGVtZW50KTtcbiAgY29uc3Qgcm9vdFBhZGRpbmcgPSBwYXJzZUZsb2F0KGNvbXB1dGVkU3R5bGUucGFkZGluZ0xlZnQpICsgcGFyc2VGbG9hdChjb21wdXRlZFN0eWxlLnBhZGRpbmdSaWdodCk7XG4gIGNvbnN0IHNlbGVjdGlvblJlY3RzID0gQXJyYXkuZnJvbShyYW5nZS5nZXRDbGllbnRSZWN0cygpKTtcbiAgbGV0IHNlbGVjdGlvblJlY3RzTGVuZ3RoID0gc2VsZWN0aW9uUmVjdHMubGVuZ3RoO1xuICAvL3NvcnQgcmVjdHMgZnJvbSB0b3AgbGVmdCB0byBib3R0b20gcmlnaHQuXG4gIHNlbGVjdGlvblJlY3RzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB0b3AgPSBhLnRvcCAtIGIudG9wO1xuICAgIC8vIFNvbWUgcmVjdHMgbWF0Y2ggcG9zaXRpb24gY2xvc2VseSwgYnV0IG5vdCBwZXJmZWN0bHksXG4gICAgLy8gc28gd2UgZ2l2ZSBhIDNweCB0b2xlcmFuY2UuXG4gICAgaWYgKE1hdGguYWJzKHRvcCkgPD0gMykge1xuICAgICAgcmV0dXJuIGEubGVmdCAtIGIubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfSk7XG4gIGxldCBwcmV2UmVjdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWxlY3Rpb25SZWN0c0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmVjdCA9IHNlbGVjdGlvblJlY3RzW2ldO1xuICAgIC8vIEV4Y2x1ZGUgcmVjdHMgdGhhdCBvdmVybGFwIHByZWNlZGluZyBSZWN0cyBpbiB0aGUgc29ydGVkIGxpc3QuXG4gICAgY29uc3QgaXNPdmVybGFwcGluZ1JlY3QgPSBwcmV2UmVjdCAmJiBwcmV2UmVjdC50b3AgPD0gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QudG9wICsgcHJldlJlY3QuaGVpZ2h0ID4gc2VsZWN0aW9uUmVjdC50b3AgJiYgcHJldlJlY3QubGVmdCArIHByZXZSZWN0LndpZHRoID4gc2VsZWN0aW9uUmVjdC5sZWZ0O1xuICAgIC8vIEV4Y2x1ZGUgc2VsZWN0aW9ucyB0aGF0IHNwYW4gdGhlIGVudGlyZSBlbGVtZW50XG4gICAgY29uc3Qgc2VsZWN0aW9uU3BhbnNFbGVtZW50ID0gc2VsZWN0aW9uUmVjdC53aWR0aCArIHJvb3RQYWRkaW5nID09PSByb290UmVjdC53aWR0aDtcbiAgICBpZiAoaXNPdmVybGFwcGluZ1JlY3QgfHwgc2VsZWN0aW9uU3BhbnNFbGVtZW50KSB7XG4gICAgICBzZWxlY3Rpb25SZWN0cy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgIHNlbGVjdGlvblJlY3RzTGVuZ3RoLS07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcHJldlJlY3QgPSBzZWxlY3Rpb25SZWN0O1xuICB9XG4gIHJldHVybiBzZWxlY3Rpb25SZWN0cztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMgcHJvdmlkZWQgaW4gdGhlIENTUyBzdHJpbmcuXG4gKiBAcGFyYW0gY3NzIC0gVGhlIENTUyBzdHJpbmcgb2Ygc3R5bGVzIGFuZCB0aGVpciB2YWx1ZXMuXG4gKiBAcmV0dXJucyBUaGUgc3R5bGVPYmplY3QgY29udGFpbmluZyBhbGwgdGhlIHN0eWxlcyBhbmQgdGhlaXIgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoY3NzKSB7XG4gIGNvbnN0IHN0eWxlT2JqZWN0ID0ge307XG4gIGlmICghY3NzKSB7XG4gICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xuICB9XG4gIGNvbnN0IHN0eWxlcyA9IGNzcy5zcGxpdCgnOycpO1xuICBmb3IgKGNvbnN0IHN0eWxlIG9mIHN0eWxlcykge1xuICAgIGlmIChzdHlsZSAhPT0gJycpIHtcbiAgICAgIGNvbnN0IFtrZXksIHZhbHVlXSA9IHN0eWxlLnNwbGl0KC86KFteXSspLyk7IC8vIHNwbGl0IG9uIGZpcnN0IGNvbG9uXG4gICAgICBpZiAoa2V5ICYmIHZhbHVlKSB7XG4gICAgICAgIHN0eWxlT2JqZWN0W2tleS50cmltKCldID0gdmFsdWUudHJpbSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVPYmplY3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBDU1Mgc3RyaW5nLCByZXR1cm5zIGFuIG9iamVjdCBmcm9tIHRoZSBzdHlsZSBjYWNoZS5cbiAqIEBwYXJhbSBjc3MgLSBUaGUgQ1NTIHByb3BlcnR5IGFzIGEgc3RyaW5nLlxuICogQHJldHVybnMgVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBDU1MgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpIHtcbiAgbGV0IHZhbHVlID0gQ1NTX1RPX1NUWUxFUy5nZXQoY3NzKTtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IGdldFN0eWxlT2JqZWN0RnJvbVJhd0NTUyhjc3MpO1xuICAgIENTU19UT19TVFlMRVMuc2V0KGNzcywgdmFsdWUpO1xuICB9XG4gIHtcbiAgICAvLyBGcmVlemUgdGhlIHZhbHVlIGluIERFViB0byBwcmV2ZW50IGFjY2lkZW50YWwgbXV0YXRpb25zXG4gICAgT2JqZWN0LmZyZWV6ZSh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIENTUyBzdHlsZXMgZnJvbSB0aGUgc3R5bGUgb2JqZWN0LlxuICogQHBhcmFtIHN0eWxlcyAtIFRoZSBzdHlsZSBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIHRvIGdldC5cbiAqIEByZXR1cm5zIEEgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIENTUyBzdHlsZXMgYW5kIHRoZWlyIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KHN0eWxlcykge1xuICBsZXQgY3NzID0gJyc7XG4gIGZvciAoY29uc3Qgc3R5bGUgaW4gc3R5bGVzKSB7XG4gICAgaWYgKHN0eWxlKSB7XG4gICAgICBjc3MgKz0gYCR7c3R5bGV9OiAke3N0eWxlc1tzdHlsZV19O2A7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3M7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgY29tcHV0ZWQgRE9NIHN0eWxlcyBvZiB0aGUgZWxlbWVudC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgdGhlIHN0eWxlcyBmb3IuXG4gKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGVzIG9mIHRoZSBlbGVtZW50IG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gRE9NIGVsZW1lbnQgb3Igbm8gZGVmYXVsdCB2aWV3IGZvciB0aGUgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uICRnZXRDb21wdXRlZFN0eWxlRm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGNvbnN0IGVkaXRvciA9ICRnZXRFZGl0b3IoKTtcbiAgY29uc3QgZG9tRWxlbWVudCA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWxlbWVudC5nZXRLZXkoKSk7XG4gIGlmIChkb21FbGVtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgdmlldyA9IGRvbUVsZW1lbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcbiAgaWYgKHZpZXcgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKGRvbUVsZW1lbnQpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvbXB1dGVkIERPTSBzdHlsZXMgb2YgdGhlIHBhcmVudCBvZiB0aGUgbm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgaXRzIHBhcmVudCdzIHN0eWxlcyBmb3IuXG4gKiBAcmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGVzIG9mIHRoZSBub2RlIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gRE9NIGVsZW1lbnQgb3Igbm8gZGVmYXVsdCB2aWV3IGZvciB0aGUgZG9jdW1lbnQuXG4gKi9cbmZ1bmN0aW9uICRnZXRDb21wdXRlZFN0eWxlRm9yUGFyZW50KG5vZGUpIHtcbiAgY29uc3QgcGFyZW50ID0gJGlzUm9vdE5vZGUobm9kZSkgPyBub2RlIDogbm9kZS5nZXRQYXJlbnRPclRocm93KCk7XG4gIHJldHVybiAkZ2V0Q29tcHV0ZWRTdHlsZUZvckVsZW1lbnQocGFyZW50KTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBub2RlJ3MgcGFyZW50IGlzIFJUTC5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gY2hlY2sgd2hldGhlciBpdCBpcyBSVEwuXG4gKiBAcmV0dXJucyB3aGV0aGVyIHRoZSBub2RlIGlzIFJUTC5cbiAqL1xuZnVuY3Rpb24gJGlzUGFyZW50UlRMKG5vZGUpIHtcbiAgY29uc3Qgc3R5bGVzID0gJGdldENvbXB1dGVkU3R5bGVGb3JQYXJlbnQobm9kZSk7XG4gIHJldHVybiBzdHlsZXMgIT09IG51bGwgJiYgc3R5bGVzLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG59XG5cbi8qKlxuICogR2VuZXJhbGx5IHVzZWQgdG8gYXBwZW5kIHRleHQgY29udGVudCB0byBIVE1MIGFuZCBKU09OLiBHcmFicyB0aGUgdGV4dCBjb250ZW50IGFuZCBcInNsaWNlc1wiXG4gKiBpdCB0byBiZSBnZW5lcmF0ZWQgaW50byB0aGUgbmV3IFRleHROb2RlLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3Rpb24gY29udGFpbmluZyB0aGUgbm9kZSB3aG9zZSBUZXh0Tm9kZSBpcyB0byBiZSBlZGl0ZWQuXG4gKiBAcGFyYW0gdGV4dE5vZGUgLSBUaGUgVGV4dE5vZGUgdG8gYmUgZWRpdGVkLlxuICogQHJldHVybnMgVGhlIHVwZGF0ZWQgVGV4dE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50KHNlbGVjdGlvbiwgdGV4dE5vZGUpIHtcbiAgY29uc3QgYW5jaG9yQW5kRm9jdXMgPSBzZWxlY3Rpb24uZ2V0U3RhcnRFbmRQb2ludHMoKTtcbiAgaWYgKHRleHROb2RlLmlzU2VsZWN0ZWQoc2VsZWN0aW9uKSAmJiAhJGlzVG9rZW5PclNlZ21lbnRlZCh0ZXh0Tm9kZSkgJiYgYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpIHtcbiAgICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBhbmNob3JBbmRGb2N1cztcbiAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNBbmNob3IgPSB0ZXh0Tm9kZS5pcyhhbmNob3JOb2RlKTtcbiAgICBjb25zdCBpc0ZvY3VzID0gdGV4dE5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICBpZiAoaXNBbmNob3IgfHwgaXNGb2N1cykge1xuICAgICAgY29uc3QgW2FuY2hvck9mZnNldCwgZm9jdXNPZmZzZXRdID0gJGdldENoYXJhY3Rlck9mZnNldHMoc2VsZWN0aW9uKTtcbiAgICAgIGNvbnN0IGlzU2FtZSA9IGFuY2hvck5vZGUuaXMoZm9jdXNOb2RlKTtcbiAgICAgIGNvbnN0IGlzRmlyc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gZm9jdXNOb2RlIDogYW5jaG9yTm9kZSk7XG4gICAgICBjb25zdCBpc0xhc3QgPSB0ZXh0Tm9kZS5pcyhpc0JhY2t3YXJkID8gYW5jaG9yTm9kZSA6IGZvY3VzTm9kZSk7XG4gICAgICBsZXQgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgbGV0IGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChpc1NhbWUpIHtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGZvY3VzT2Zmc2V0IDogYW5jaG9yT2Zmc2V0O1xuICAgICAgICBlbmRPZmZzZXQgPSBhbmNob3JPZmZzZXQgPiBmb2N1c09mZnNldCA/IGFuY2hvck9mZnNldCA6IGZvY3VzT2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmIChpc0ZpcnN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1c09mZnNldCA6IGFuY2hvck9mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIGVuZE9mZnNldCA9IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoaXNMYXN0KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IGlzQmFja3dhcmQgPyBhbmNob3JPZmZzZXQgOiBmb2N1c09mZnNldDtcbiAgICAgICAgc3RhcnRPZmZzZXQgPSAwO1xuICAgICAgICBlbmRPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIC8vIE5PVEU6IFRoaXMgbXV0YXRlcyBfX3RleHQgZGlyZWN0bHkgYmVjYXVzZSB0aGUgcHJpbWFyeSB1c2UgY2FzZSBpcyB0b1xuICAgICAgLy8gbW9kaWZ5IGEgJGNsb25lV2l0aFByb3BlcnRpZXMgbm9kZSB0aGF0IHNob3VsZCBuZXZlciBiZSBhZGRlZFxuICAgICAgLy8gdG8gdGhlIEVkaXRvclN0YXRlIHNvIHdlIG11c3Qgbm90IGNhbGwgZ2V0V3JpdGFibGUgdmlhIHNldFRleHRDb250ZW50XG4gICAgICB0ZXh0Tm9kZS5fX3RleHQgPSB0ZXh0Tm9kZS5fX3RleHQuc2xpY2Uoc3RhcnRPZmZzZXQsIGVuZE9mZnNldCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZXh0Tm9kZTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBpcyBhdCB0aGUgZW5kIG9mIHRoZSBub2RlLlxuICogQHBhcmFtIHBvaW50IC0gVGhlIHBvaW50IG9mIHRoZSBzZWxlY3Rpb24gdG8gdGVzdC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBvaW50IG9mZnNldCBpcyBpbiB0aGUgbGFzdCBwb3NzaWJsZSBwb3NpdGlvbiwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdE5vZGVFbmQocG9pbnQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICd0ZXh0Jykge1xuICAgIHJldHVybiBwb2ludC5vZmZzZXQgPT09IHBvaW50LmdldE5vZGUoKS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgfVxuICBjb25zdCBub2RlID0gcG9pbnQuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpc0F0Tm9kZUVuZDogbm9kZSBtdXN0IGJlIGEgVGV4dE5vZGUgb3IgRWxlbWVudE5vZGVgKTtcbiAgfVxuICByZXR1cm4gcG9pbnQub2Zmc2V0ID09PSBub2RlLmdldENoaWxkcmVuU2l6ZSgpO1xufVxuXG4vKipcbiAqIFRyaW1zIHRleHQgZnJvbSBhIG5vZGUgaW4gb3JkZXIgdG8gc2hvcnRlbiBpdCwgZWcuIHRvIGVuZm9yY2UgYSB0ZXh0J3MgbWF4IGxlbmd0aC4gSWYgaXQgZGVsZXRlcyB0ZXh0XG4gKiB0aGF0IGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBhbmNob3IgdGhlbiBpdCB3aWxsIGxlYXZlIDIgaW5kZW50cywgb3RoZXJ3aXNlLCBpZiBubyB0ZXh0IGNvbnRlbnQgZXhpc3RzLCBpdCBkZWxldGVzXG4gKiB0aGUgVGV4dE5vZGUuIEl0IHdpbGwgbW92ZSB0aGUgZm9jdXMgdG8gZWl0aGVyIHRoZSBlbmQgb2YgYW55IGxlZnQgb3ZlciB0ZXh0IG9yIGJlZ2lubmluZyBvZiBhIG5ldyBUZXh0Tm9kZS5cbiAqIEBwYXJhbSBlZGl0b3IgLSBUaGUgbGV4aWNhbCBlZGl0b3IuXG4gKiBAcGFyYW0gYW5jaG9yIC0gVGhlIGFuY2hvciBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24sIHdoZXJlIHRoZSBzZWxlY3Rpb24gc2hvdWxkIGJlIHBvaW50aW5nLlxuICogQHBhcmFtIGRlbENvdW50IC0gVGhlIGFtb3VudCBvZiBjaGFyYWN0ZXJzIHRvIGRlbGV0ZS4gVXNlZnVsIGFzIGEgZHluYW1pYyB2YXJpYWJsZSBlZy4gdGV4dENvbnRlbnRTaXplIC0gbWF4TGVuZ3RoO1xuICovXG5mdW5jdGlvbiAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcihlZGl0b3IsIGFuY2hvciwgZGVsQ291bnQpIHtcbiAgLy8gV29yayBmcm9tIHRoZSBjdXJyZW50IHNlbGVjdGlvbiBhbmNob3IgcG9pbnRcbiAgbGV0IGN1cnJlbnROb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgbGV0IHJlbWFpbmluZyA9IGRlbENvdW50O1xuICBpZiAoJGlzRWxlbWVudE5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgY29uc3QgZGVzY2VuZGFudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXREZXNjZW5kYW50QnlJbmRleChhbmNob3Iub2Zmc2V0KTtcbiAgICBpZiAoZGVzY2VuZGFudE5vZGUgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gZGVzY2VuZGFudE5vZGU7XG4gICAgfVxuICB9XG4gIHdoaWxlIChyZW1haW5pbmcgPiAwICYmIGN1cnJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSkge1xuICAgICAgY29uc3QgbGFzdERlc2NlbmRhbnQgPSBjdXJyZW50Tm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgaWYgKGxhc3REZXNjZW5kYW50ICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gbGFzdERlc2NlbmRhbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBuZXh0Tm9kZSA9IGN1cnJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgIGxldCBhZGRpdGlvbmFsRWxlbWVudFdoaXRlc3BhY2UgPSAwO1xuICAgIGlmIChuZXh0Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgbGV0IHBhcmVudCA9IGN1cnJlbnROb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGxldCBwYXJlbnRTaWJsaW5nID0gcGFyZW50LmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgd2hpbGUgKHBhcmVudFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICBpZiAocGFyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dE5vZGUgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHBhcmVudFNpYmxpbmcgPSBwYXJlbnQuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGl0aW9uYWxFbGVtZW50V2hpdGVzcGFjZSA9IHBhcmVudC5pc0lubGluZSgpID8gMCA6IDI7XG4gICAgICAgIG5leHROb2RlID0gcGFyZW50U2libGluZztcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHRleHQgPSBjdXJyZW50Tm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIC8vIElmIHRoZSB0ZXh0IGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFkZGluZyBpbiB0d28gbGluZSBicmVha3MgdG8gbWF0Y2hcbiAgICAvLyB0aGUgY29udGVudCBpZiB3ZSB3ZXJlIHRvIGdldCBpdCBmcm9tIGl0cyBwYXJlbnQuXG4gICAgaWYgKHRleHQgPT09ICcnICYmICRpc0VsZW1lbnROb2RlKGN1cnJlbnROb2RlKSAmJiAhY3VycmVudE5vZGUuaXNJbmxpbmUoKSkge1xuICAgICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgaGFuZGxlZCBpbiBjb3JlP1xuICAgICAgdGV4dCA9ICdcXG5cXG4nO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50Tm9kZVNpemUgPSB0ZXh0Lmxlbmd0aDtcbiAgICBpZiAoISRpc1RleHROb2RlKGN1cnJlbnROb2RlKSB8fCByZW1haW5pbmcgPj0gY3VycmVudE5vZGVTaXplKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGN1cnJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgaWYgKHBhcmVudCAhPSBudWxsICYmIHBhcmVudC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCAmJiAhJGlzUm9vdE5vZGUocGFyZW50KSkge1xuICAgICAgICBwYXJlbnQucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgLT0gY3VycmVudE5vZGVTaXplICsgYWRkaXRpb25hbEVsZW1lbnRXaGl0ZXNwYWNlO1xuICAgICAgY3VycmVudE5vZGUgPSBuZXh0Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qga2V5ID0gY3VycmVudE5vZGUuZ2V0S2V5KCk7XG4gICAgICAvLyBTZWUgaWYgd2UgY2FuIGp1c3QgcmV2ZXJ0IGl0IHRvIHdoYXQgd2FzIGluIHRoZSBsYXN0IGVkaXRvciBzdGF0ZVxuICAgICAgY29uc3QgcHJldlRleHRDb250ZW50ID0gZWRpdG9yLmdldEVkaXRvclN0YXRlKCkucmVhZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZOb2RlID0gJGdldE5vZGVCeUtleShrZXkpO1xuICAgICAgICBpZiAoJGlzVGV4dE5vZGUocHJldk5vZGUpICYmIHByZXZOb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgICAgcmV0dXJuIHByZXZOb2RlLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGN1cnJlbnROb2RlU2l6ZSAtIHJlbWFpbmluZztcbiAgICAgIGNvbnN0IHNsaWNlZFRleHQgPSB0ZXh0LnNsaWNlKDAsIG9mZnNldCk7XG4gICAgICBpZiAocHJldlRleHRDb250ZW50ICE9PSBudWxsICYmIHByZXZUZXh0Q29udGVudCAhPT0gdGV4dCkge1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgICAgIGxldCB0YXJnZXQgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKCFjdXJyZW50Tm9kZS5pc1NpbXBsZVRleHQoKSkge1xuICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gJGNyZWF0ZVRleHROb2RlKHByZXZUZXh0Q29udGVudCk7XG4gICAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICAgICAgdGFyZ2V0ID0gdGV4dE5vZGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE5vZGUuc2V0VGV4dENvbnRlbnQocHJldlRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgICAgICAgY29uc3QgcHJldk9mZnNldCA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLm9mZnNldDtcbiAgICAgICAgICB0YXJnZXQuc2VsZWN0KHByZXZPZmZzZXQsIHByZXZPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGN1cnJlbnROb2RlLmlzU2ltcGxlVGV4dCgpKSB7XG4gICAgICAgIC8vIFNwbGl0IHRleHRcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IGFuY2hvci5rZXkgPT09IGtleTtcbiAgICAgICAgbGV0IGFuY2hvck9mZnNldCA9IGFuY2hvci5vZmZzZXQ7XG4gICAgICAgIC8vIE1vdmUgb2Zmc2V0IHRvIGVuZCBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgcmVtYWluaW5nIG51bWJlciwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlJ2xsIGhhdmUgYSBuZWdhdGl2ZSBzcGxpdFN0YXJ0LlxuICAgICAgICBpZiAoYW5jaG9yT2Zmc2V0IDwgcmVtYWluaW5nKSB7XG4gICAgICAgICAgYW5jaG9yT2Zmc2V0ID0gY3VycmVudE5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNwbGl0U3RhcnQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IC0gcmVtYWluaW5nIDogMDtcbiAgICAgICAgY29uc3Qgc3BsaXRFbmQgPSBpc1NlbGVjdGVkID8gYW5jaG9yT2Zmc2V0IDogb2Zmc2V0O1xuICAgICAgICBpZiAoaXNTZWxlY3RlZCAmJiBzcGxpdFN0YXJ0ID09PSAwKSB7XG4gICAgICAgICAgY29uc3QgW2V4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IFssIGV4Y2Vzc05vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KHNwbGl0U3RhcnQsIHNwbGl0RW5kKTtcbiAgICAgICAgICBleGNlc3NOb2RlLnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShzbGljZWRUZXh0KTtcbiAgICAgICAgY3VycmVudE5vZGUucmVwbGFjZSh0ZXh0Tm9kZSk7XG4gICAgICB9XG4gICAgICByZW1haW5pbmcgPSAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldHMgdGhlIFRleHROb2RlJ3Mgc3R5bGUgb2JqZWN0IGFuZCBhZGRzIHRoZSBzdHlsZXMgdG8gdGhlIENTUy5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIFRleHROb2RlIHRvIGFkZCBzdHlsZXMgdG8uXG4gKi9cbmZ1bmN0aW9uICRhZGROb2RlU3R5bGUobm9kZSkge1xuICBjb25zdCBDU1NUZXh0ID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZXMgPSBnZXRTdHlsZU9iamVjdEZyb21SYXdDU1MoQ1NTVGV4dCk7XG4gIENTU19UT19TVFlMRVMuc2V0KENTU1RleHQsIHN0eWxlcyk7XG59XG5cbi8qKlxuICogQXBwbGllcyB0aGUgcHJvdmlkZWQgc3R5bGVzIHRvIHRoZSBnaXZlbiBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yXG4gKiBjb2xsYXBzZWQgUmFuZ2VTZWxlY3Rpb24uXG4gKlxuICogQHBhcmFtIHRhcmdldCAtIFRoZSBUZXh0Tm9kZSwgRWxlbWVudE5vZGUsIG9yIGNvbGxhcHNlZCBSYW5nZVNlbGVjdGlvbiB0byBhcHBseSB0aGUgc3R5bGVzIHRvXG4gKiBAcGFyYW0gcGF0Y2ggLSBUaGUgcGF0Y2ggdG8gYXBwbHksIHdoaWNoIGNhbiBpbmNsdWRlIG11bHRpcGxlIHN0eWxlcy4gXFxcXHtDU1NQcm9wZXJ0eTogdmFsdWVcXFxcfSAuIENhbiBhbHNvIGFjY2VwdCBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgbmV3IHByb3BlcnR5IHZhbHVlLlxuICovXG5mdW5jdGlvbiAkcGF0Y2hTdHlsZSh0YXJnZXQsIHBhdGNoKSB7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHRhcmdldCkgPyB0YXJnZXQuaXNDb2xsYXBzZWQoKSA6ICRpc1RleHROb2RlKHRhcmdldCkgfHwgJGlzRWxlbWVudE5vZGUodGFyZ2V0KSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCRwYXRjaFN0eWxlIG11c3Qgb25seSBiZSBjYWxsZWQgd2l0aCBhIFRleHROb2RlLCBFbGVtZW50Tm9kZSwgb3IgY29sbGFwc2VkIFJhbmdlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgcHJldlN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUygkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpID8gdGFyZ2V0LnN0eWxlIDogJGlzVGV4dE5vZGUodGFyZ2V0KSA/IHRhcmdldC5nZXRTdHlsZSgpIDogdGFyZ2V0LmdldFRleHRTdHlsZSgpKTtcbiAgY29uc3QgbmV3U3R5bGVzID0gT2JqZWN0LmVudHJpZXMocGF0Y2gpLnJlZHVjZSgoc3R5bGVzLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdHlsZXNba2V5XSA9IHZhbHVlKHByZXZTdHlsZXNba2V5XSwgdGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICBkZWxldGUgc3R5bGVzW2tleV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZXM7XG4gIH0sIHtcbiAgICAuLi5wcmV2U3R5bGVzXG4gIH0pO1xuICBjb25zdCBuZXdDU1NUZXh0ID0gZ2V0Q1NTRnJvbVN0eWxlT2JqZWN0KG5ld1N0eWxlcyk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbih0YXJnZXQpIHx8ICRpc1RleHROb2RlKHRhcmdldCkpIHtcbiAgICB0YXJnZXQuc2V0U3R5bGUobmV3Q1NTVGV4dCk7XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0LnNldFRleHRTdHlsZShuZXdDU1NUZXh0KTtcbiAgfVxuICBDU1NfVE9fU1RZTEVTLnNldChuZXdDU1NUZXh0LCBuZXdTdHlsZXMpO1xufVxuXG4vKipcbiAqIEFwcGxpZXMgdGhlIHByb3ZpZGVkIHN0eWxlcyB0byB0aGUgVGV4dE5vZGVzIGluIHRoZSBwcm92aWRlZCBTZWxlY3Rpb24uXG4gKiBXaWxsIHVwZGF0ZSBwYXJ0aWFsbHkgc2VsZWN0ZWQgVGV4dE5vZGVzIGJ5IHNwbGl0dGluZyB0aGUgVGV4dE5vZGUgYW5kIGFwcGx5aW5nXG4gKiB0aGUgc3R5bGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBvbmUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGVkIG5vZGUocykgdG8gdXBkYXRlLlxuICogQHBhcmFtIHBhdGNoIC0gVGhlIHBhdGNoIHRvIGFwcGx5LCB3aGljaCBjYW4gaW5jbHVkZSBtdWx0aXBsZSBzdHlsZXMuIFxcXFx7Q1NTUHJvcGVydHk6IHZhbHVlXFxcXH0gLiBDYW4gYWxzbyBhY2NlcHQgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIG5ldyBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gJHBhdGNoU3R5bGVUZXh0KHNlbGVjdGlvbiwgcGF0Y2gpIHtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAkcGF0Y2hTdHlsZShzZWxlY3Rpb24sIHBhdGNoKTtcbiAgICBjb25zdCBlbXB0eU5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZW1wdHlOb2RlKSAmJiBlbXB0eU5vZGUuaXNFbXB0eSgpKSB7XG4gICAgICAkcGF0Y2hTdHlsZShlbXB0eU5vZGUsIHBhdGNoKTtcbiAgICB9XG4gIH1cbiAgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlKHRleHROb2RlID0+IHtcbiAgICAkcGF0Y2hTdHlsZSh0ZXh0Tm9kZSwgcGF0Y2gpO1xuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoU2VsZWN0ZWRUZXh0Tm9kZShmbikge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghc2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNsaWNlZFRleHROb2RlcyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZ2V0U2xpY2VJbmRpY2VzID0gbm9kZSA9PiBzbGljZWRUZXh0Tm9kZXMuZ2V0KG5vZGUuZ2V0S2V5KCkpIHx8IFswLCBub2RlLmdldFRleHRDb250ZW50U2l6ZSgpXTtcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBmb3IgKGNvbnN0IHNsaWNlIG9mICRjYXJldFJhbmdlRnJvbVNlbGVjdGlvbihzZWxlY3Rpb24pLmdldFRleHRTbGljZXMoKSkge1xuICAgICAgaWYgKHNsaWNlKSB7XG4gICAgICAgIHNsaWNlZFRleHROb2Rlcy5zZXQoc2xpY2UuY2FyZXQub3JpZ2luLmdldEtleSgpLCBzbGljZS5nZXRTbGljZUluZGljZXMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlbGVjdGVkTm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgZm9yIChjb25zdCBzZWxlY3RlZE5vZGUgb2Ygc2VsZWN0ZWROb2Rlcykge1xuICAgIGlmICghKCRpc1RleHROb2RlKHNlbGVjdGVkTm9kZSkgJiYgc2VsZWN0ZWROb2RlLmNhbkhhdmVGb3JtYXQoKSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBbc3RhcnRPZmZzZXQsIGVuZE9mZnNldF0gPSBnZXRTbGljZUluZGljZXMoc2VsZWN0ZWROb2RlKTtcbiAgICAvLyBObyBhY3R1YWwgdGV4dCBpcyBzZWxlY3RlZCwgc28gZG8gbm90aGluZy5cbiAgICBpZiAoZW5kT2Zmc2V0ID09PSBzdGFydE9mZnNldCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhlIGVudGlyZSBub2RlIGlzIHNlbGVjdGVkIG9yIGEgdG9rZW4vc2VnbWVudCwgc28ganVzdCBmb3JtYXQgaXRcbiAgICBpZiAoJGlzVG9rZW5PclNlZ21lbnRlZChzZWxlY3RlZE5vZGUpIHx8IHN0YXJ0T2Zmc2V0ID09PSAwICYmIGVuZE9mZnNldCA9PT0gc2VsZWN0ZWROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBmbihzZWxlY3RlZE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgbm9kZSBpcyBwYXJ0aWFsbHkgc2VsZWN0ZWQsIHNvIHNwbGl0IGl0IGludG8gdHdvIG9yIHRocmVlIG5vZGVzXG4gICAgICAvLyBhbmQgc3R5bGUgdGhlIHNlbGVjdGVkIG9uZS5cbiAgICAgIGNvbnN0IHNwbGl0Tm9kZXMgPSBzZWxlY3RlZE5vZGUuc3BsaXRUZXh0KHN0YXJ0T2Zmc2V0LCBlbmRPZmZzZXQpO1xuICAgICAgY29uc3QgcmVwbGFjZW1lbnQgPSBzcGxpdE5vZGVzW3N0YXJ0T2Zmc2V0ID09PSAwID8gMCA6IDFdO1xuICAgICAgZm4ocmVwbGFjZW1lbnQpO1xuICAgIH1cbiAgfVxuICAvLyBQcmlvciB0byBOb2RlQ2FyZXQgIzcwNDYgdGhpcyB3b3VsZCBoYXZlIGJlZW4gYSBzaWRlLWVmZmVjdFxuICAvLyBzbyB3ZSBkbyB0aGlzIGZvciB0ZXN0IGNvbXBhdGliaWxpdHkuXG4gIC8vIFRPRE86IHdlIG1heSB3YW50IHRvIGNvbnNpZGVyIHNpbXBsaWZ5aW5nIGJ5IHJlbW92aW5nIHRoaXNcbiAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmFuY2hvci50eXBlID09PSAndGV4dCcgJiYgc2VsZWN0aW9uLmZvY3VzLnR5cGUgPT09ICd0ZXh0JyAmJiBzZWxlY3Rpb24uYW5jaG9yLmtleSA9PT0gc2VsZWN0aW9uLmZvY3VzLmtleSkge1xuICAgICRlbnN1cmVGb3J3YXJkUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgfVxufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBnaXZlbiBSYW5nZVNlbGVjdGlvbiBpcyBub3QgYmFja3dhcmRzLiBJZiBpdFxuICogaXMgYmFja3dhcmRzLCB0aGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIHBvaW50cyB3aWxsIGJlIHN3YXBwZWRcbiAqIGluLXBsYWNlLiBFbnN1cmluZyB0aGF0IHRoZSBzZWxlY3Rpb24gaXMgYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICogaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSBjYWxsZXIgKGUuZy4gaW4gYSByZWFkLW9ubHkgY29udGV4dFxuICogeW91IHdpbGwgd2FudCB0byBjbG9uZSAkZ2V0U2VsZWN0aW9uKCkgYmVmb3JlIHVzaW5nIHRoaXMpLlxuICpcbiAqIEBwYXJhbSBzZWxlY3Rpb24gYSB3cml0YWJsZSBSYW5nZVNlbGVjdGlvblxuICovXG5mdW5jdGlvbiAkZW5zdXJlRm9yd2FyZFJhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikge1xuICBpZiAoc2VsZWN0aW9uLmlzQmFja3dhcmQoKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICAvLyBzdGFzaCBmb3IgdGhlIGluLXBsYWNlIHN3YXBcbiAgICBjb25zdCB7XG4gICAgICBrZXksXG4gICAgICBvZmZzZXQsXG4gICAgICB0eXBlXG4gICAgfSA9IGFuY2hvcjtcbiAgICBhbmNob3Iuc2V0KGZvY3VzLmtleSwgZm9jdXMub2Zmc2V0LCBmb2N1cy50eXBlKTtcbiAgICBmb2N1cy5zZXQoa2V5LCBvZmZzZXQsIHR5cGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uICRjb3B5QmxvY2tGb3JtYXRJbmRlbnQoc3JjTm9kZSwgZGVzdE5vZGUpIHtcbiAgY29uc3QgZm9ybWF0ID0gc3JjTm9kZS5nZXRGb3JtYXRUeXBlKCk7XG4gIGNvbnN0IGluZGVudCA9IHNyY05vZGUuZ2V0SW5kZW50KCk7XG4gIGlmIChmb3JtYXQgIT09IGRlc3ROb2RlLmdldEZvcm1hdFR5cGUoKSkge1xuICAgIGRlc3ROb2RlLnNldEZvcm1hdChmb3JtYXQpO1xuICB9XG4gIGlmIChpbmRlbnQgIT09IGRlc3ROb2RlLmdldEluZGVudCgpKSB7XG4gICAgZGVzdE5vZGUuc2V0SW5kZW50KGluZGVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbGwgbm9kZXMgaW4gdGhlIHNlbGVjdGlvbiB0aGF0IGFyZSBvZiBvbmUgYmxvY2sgdHlwZSB0byBhbm90aGVyLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCBibG9ja3MgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtICRjcmVhdGVFbGVtZW50IC0gVGhlIGZ1bmN0aW9uIHRoYXQgY3JlYXRlcyB0aGUgbm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtICRhZnRlckNyZWF0ZUVsZW1lbnQgLSBUaGUgZnVuY3Rpb24gdGhhdCB1cGRhdGVzIHRoZSBuZXcgbm9kZSBiYXNlZCBvbiB0aGUgcHJldmlvdXMgb25lICgkY29weUJsb2NrRm9ybWF0SW5kZW50IGJ5IGRlZmF1bHQpXG4gKi9cbmZ1bmN0aW9uICRzZXRCbG9ja3NUeXBlKHNlbGVjdGlvbiwgJGNyZWF0ZUVsZW1lbnQsICRhZnRlckNyZWF0ZUVsZW1lbnQgPSAkY29weUJsb2NrRm9ybWF0SW5kZW50KSB7XG4gIGlmIChzZWxlY3Rpb24gPT09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gU2VsZWN0aW9ucyB0ZW5kIHRvIG5vdCBpbmNsdWRlIHRoZWlyIGNvbnRhaW5pbmcgYmxvY2tzIHNvIHdlIGVmZmVjdGl2ZWx5XG4gIC8vIGV4cGFuZCBpdCBoZXJlXG4gIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gIGNvbnN0IGJsb2NrTWFwID0gbmV3IE1hcCgpO1xuICBsZXQgbmV3U2VsZWN0aW9uID0gbnVsbDtcbiAgaWYgKGFuY2hvckFuZEZvY3VzKSB7XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoYW5jaG9yLmtleSwgYW5jaG9yLm9mZnNldCwgYW5jaG9yLnR5cGUpO1xuICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZm9jdXMua2V5LCBmb2N1cy5vZmZzZXQsIGZvY3VzLnR5cGUpO1xuICAgIGNvbnN0IGFuY2hvckJsb2NrID0gJGdldEFuY2VzdG9yKGFuY2hvci5nZXROb2RlKCksIElOVEVSTkFMXyRpc0Jsb2NrKTtcbiAgICBjb25zdCBmb2N1c0Jsb2NrID0gJGdldEFuY2VzdG9yKGZvY3VzLmdldE5vZGUoKSwgSU5URVJOQUxfJGlzQmxvY2spO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShhbmNob3JCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChhbmNob3JCbG9jay5nZXRLZXkoKSwgYW5jaG9yQmxvY2spO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoZm9jdXNCbG9jaykpIHtcbiAgICAgIGJsb2NrTWFwLnNldChmb2N1c0Jsb2NrLmdldEtleSgpLCBmb2N1c0Jsb2NrKTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBub2RlIG9mIHNlbGVjdGlvbi5nZXROb2RlcygpKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIElOVEVSTkFMXyRpc0Jsb2NrKG5vZGUpKSB7XG4gICAgICBibG9ja01hcC5zZXQobm9kZS5nZXRLZXkoKSwgbm9kZSk7XG4gICAgfSBlbHNlIGlmIChhbmNob3JBbmRGb2N1cyA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jZXN0b3JCbG9jayA9ICRnZXRBbmNlc3Rvcihub2RlLCBJTlRFUk5BTF8kaXNCbG9jayk7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jZXN0b3JCbG9jaykpIHtcbiAgICAgICAgYmxvY2tNYXAuc2V0KGFuY2VzdG9yQmxvY2suZ2V0S2V5KCksIGFuY2VzdG9yQmxvY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IFtrZXksIHByZXZOb2RlXSBvZiBibG9ja01hcCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSAkY3JlYXRlRWxlbWVudCgpO1xuICAgICRhZnRlckNyZWF0ZUVsZW1lbnQocHJldk5vZGUsIGVsZW1lbnQpO1xuICAgIHByZXZOb2RlLnJlcGxhY2UoZWxlbWVudCwgdHJ1ZSk7XG4gICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgaWYgKGtleSA9PT0gbmV3U2VsZWN0aW9uLmFuY2hvci5rZXkpIHtcbiAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIG5ld1NlbGVjdGlvbi5hbmNob3IudHlwZSk7XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSBuZXdTZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoZWxlbWVudC5nZXRLZXkoKSwgbmV3U2VsZWN0aW9uLmZvY3VzLm9mZnNldCwgbmV3U2VsZWN0aW9uLmZvY3VzLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobmV3U2VsZWN0aW9uICYmIHNlbGVjdGlvbi5pcygkZ2V0U2VsZWN0aW9uKCkpKSB7XG4gICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICB9XG59XG5mdW5jdGlvbiBpc1BvaW50QXR0YWNoZWQocG9pbnQpIHtcbiAgcmV0dXJuIHBvaW50LmdldE5vZGUoKS5pc0F0dGFjaGVkKCk7XG59XG5mdW5jdGlvbiAkcmVtb3ZlUGFyZW50RW1wdHlFbGVtZW50cyhzdGFydGluZ05vZGUpIHtcbiAgbGV0IG5vZGUgPSBzdGFydGluZ05vZGU7XG4gIHdoaWxlIChub2RlICE9PSBudWxsICYmICEkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgY29uc3QgbGF0ZXN0ID0gbm9kZS5nZXRMYXRlc3QoKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICBpZiAobGF0ZXN0LmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBub2RlLnJlbW92ZSh0cnVlKTtcbiAgICB9XG4gICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBJbiBmYXZvciBvZiAkc2V0QmxvY2tUeXBlc1xuICogV3JhcHMgYWxsIG5vZGVzIGluIHRoZSBzZWxlY3Rpb24gaW50byBhbm90aGVyIG5vZGUgb2YgdGhlIHR5cGUgcmV0dXJuZWQgYnkgY3JlYXRlRWxlbWVudC5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIG5vZGVzIHRvIGJlIHdyYXBwZWQuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gYXBwZW5kIHRoZSB3cmFwcGVkIHNlbGVjdGlvbiBhbmQgaXRzIGNoaWxkcmVuIHRvLlxuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzKHNlbGVjdGlvbiwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICBjb25zdCBhbmNob3IgPSBhbmNob3JBbmRGb2N1cyA/IGFuY2hvckFuZEZvY3VzWzBdIDogbnVsbDtcbiAgY29uc3Qgbm9kZXMgPSBzZWxlY3Rpb24uZ2V0Tm9kZXMoKTtcbiAgY29uc3Qgbm9kZXNMZW5ndGggPSBub2Rlcy5sZW5ndGg7XG4gIGlmIChhbmNob3IgIT09IG51bGwgJiYgKG5vZGVzTGVuZ3RoID09PSAwIHx8IG5vZGVzTGVuZ3RoID09PSAxICYmIGFuY2hvci50eXBlID09PSAnZWxlbWVudCcgJiYgYW5jaG9yLmdldE5vZGUoKS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBhbmNob3IudHlwZSA9PT0gJ3RleHQnID8gYW5jaG9yLmdldE5vZGUoKS5nZXRQYXJlbnRPclRocm93KCkgOiBhbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGNoaWxkcmVuID0gdGFyZ2V0LmdldENoaWxkcmVuKCk7XG4gICAgbGV0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCk7XG4gICAgZWxlbWVudC5zZXRGb3JtYXQodGFyZ2V0LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgZWxlbWVudC5zZXRJbmRlbnQodGFyZ2V0LmdldEluZGVudCgpKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IGVsZW1lbnQuYXBwZW5kKGNoaWxkKSk7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHdyYXBwaW5nRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XG4gICAgfVxuICAgIHRhcmdldC5yZXBsYWNlKGVsZW1lbnQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgdG9wTGV2ZWxOb2RlID0gbnVsbDtcbiAgbGV0IGRlc2NlbmRhbnRzID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXNMZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAvLyBEZXRlcm1pbmUgd2hldGhlciB3cmFwcGluZyBoYXMgdG8gYmUgYnJva2VuIGRvd24gaW50byBtdWx0aXBsZSBjaHVua3MuIFRoaXMgY2FuIGhhcHBlbiBpZiB0aGVcbiAgICAvLyB1c2VyIHNlbGVjdGVkIG11bHRpcGxlIFJvb3QtbGlrZSBub2RlcyB0aGF0IGhhdmUgdG8gYmUgdHJlYXRlZCBzZXBhcmF0ZWx5IGFzIGlmIHRoZXkgYXJlXG4gICAgLy8gdGhlaXIgb3duIGJyYW5jaC4gSS5lLiB5b3UgZG9uJ3Qgd2FudCB0byB3cmFwIGEgd2hvbGUgdGFibGUsIGJ1dCByYXRoZXIgdGhlIGNvbnRlbnRzIG9mIGVhY2hcbiAgICAvLyBvZiBlYWNoIG9mIHRoZSBjZWxsIG5vZGVzLlxuICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5vZGUpKSB7XG4gICAgICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICBkZXNjZW5kYW50cyA9IFtdO1xuICAgICAgdG9wTGV2ZWxOb2RlID0gbm9kZTtcbiAgICB9IGVsc2UgaWYgKHRvcExldmVsTm9kZSA9PT0gbnVsbCB8fCB0b3BMZXZlbE5vZGUgIT09IG51bGwgJiYgJGhhc0FuY2VzdG9yKG5vZGUsIHRvcExldmVsTm9kZSkpIHtcbiAgICAgIGRlc2NlbmRhbnRzLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICR3cmFwTm9kZXNJbXBsKHNlbGVjdGlvbiwgZGVzY2VuZGFudHMsIGRlc2NlbmRhbnRzLmxlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50KTtcbiAgICAgIGRlc2NlbmRhbnRzID0gW25vZGVdO1xuICAgIH1cbiAgfVxuICAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIGRlc2NlbmRhbnRzLCBkZXNjZW5kYW50cy5sZW5ndGgsIGNyZWF0ZUVsZW1lbnQsIHdyYXBwaW5nRWxlbWVudCk7XG59XG5cbi8qKlxuICogV3JhcHMgZWFjaCBub2RlIGludG8gYSBuZXcgRWxlbWVudE5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBub2RlcyB0byB3cmFwLlxuICogQHBhcmFtIG5vZGVzIC0gQW4gYXJyYXkgb2Ygbm9kZXMsIGdlbmVyYWxseSB0aGUgZGVzY2VuZGFudHMgb2YgdGhlIHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBub2Rlc0xlbmd0aCAtIFRoZSBsZW5ndGggb2Ygbm9kZXMuXG4gKiBAcGFyYW0gY3JlYXRlRWxlbWVudCAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIHRoZSB3cmFwcGluZyBFbGVtZW50Tm9kZS4gZWcuICRjcmVhdGVQYXJhZ3JhcGhOb2RlLlxuICogQHBhcmFtIHdyYXBwaW5nRWxlbWVudCAtIEFuIGVsZW1lbnQgdG8gd3JhcCBhbGwgdGhlIG5vZGVzIGludG8uXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiAkd3JhcE5vZGVzSW1wbChzZWxlY3Rpb24sIG5vZGVzLCBub2Rlc0xlbmd0aCwgY3JlYXRlRWxlbWVudCwgd3JhcHBpbmdFbGVtZW50ID0gbnVsbCkge1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGZpcnN0Tm9kZSA9IG5vZGVzWzBdO1xuICBjb25zdCBlbGVtZW50TWFwcGluZyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgLy8gVGhlIGJlbG93IGxvZ2ljIGlzIHRvIGZpbmQgdGhlIHJpZ2h0IHRhcmdldCBmb3IgdXMgdG9cbiAgLy8gZWl0aGVyIGluc2VydEFmdGVyL2luc2VydEJlZm9yZS9hcHBlbmQgdGhlIGNvcnJlc3BvbmRpbmdcbiAgLy8gZWxlbWVudHMgdG8uIFRoaXMgaXMgbWFkZSBtb3JlIGNvbXBsaWNhdGVkIGR1ZSB0byBuZXN0ZWRcbiAgLy8gc3RydWN0dXJlcy5cbiAgbGV0IHRhcmdldCA9ICRpc0VsZW1lbnROb2RlKGZpcnN0Tm9kZSkgPyBmaXJzdE5vZGUgOiBmaXJzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICBpZiAodGFyZ2V0LmlzSW5saW5lKCkpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIGxldCB0YXJnZXRJc1ByZXZTaWJsaW5nID0gZmFsc2U7XG4gIHdoaWxlICh0YXJnZXQgIT09IG51bGwpIHtcbiAgICBjb25zdCBwcmV2U2libGluZyA9IHRhcmdldC5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAocHJldlNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHRhcmdldCA9IHByZXZTaWJsaW5nO1xuICAgICAgdGFyZ2V0SXNQcmV2U2libGluZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY29uc3QgZW1wdHlFbGVtZW50cyA9IG5ldyBTZXQoKTtcblxuICAvLyBGaW5kIGFueSB0b3AgbGV2ZWwgZW1wdHkgZWxlbWVudHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiBub2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKSB7XG4gICAgICBlbXB0eUVsZW1lbnRzLmFkZChub2RlLmdldEtleSgpKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbW92ZWROb2RlcyA9IG5ldyBTZXQoKTtcblxuICAvLyBNb3ZlIG91dCBhbGwgbGVhZiBub2RlcyBpbnRvIG91ciBlbGVtZW50cyBhcnJheS5cbiAgLy8gSWYgd2UgZmluZCBhIHRvcCBsZXZlbCBlbXB0eSBlbGVtZW50LCBhbHNvIG1vdmUgbWFrZVxuICAvLyBhbiBlbGVtZW50IGZvciB0aGF0LlxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQuaXNJbmxpbmUoKSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBpZiAocGFyZW50ICE9PSBudWxsICYmICRpc0xlYWZOb2RlKG5vZGUpICYmICFtb3ZlZE5vZGVzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgaWYgKGVsZW1lbnRNYXBwaW5nLmdldChwYXJlbnRLZXkpID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRGb3JtYXQocGFyZW50LmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KHBhcmVudC5nZXRJbmRlbnQoKSk7XG4gICAgICAgIGVsZW1lbnRzLnB1c2godGFyZ2V0RWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnRNYXBwaW5nLnNldChwYXJlbnRLZXksIHRhcmdldEVsZW1lbnQpO1xuICAgICAgICAvLyBNb3ZlIG5vZGUgYW5kIGl0cyBzaWJsaW5ncyB0byB0aGUgbmV3XG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHBhcmVudC5nZXRDaGlsZHJlbigpLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICBtb3ZlZE5vZGVzLmFkZChjaGlsZC5nZXRLZXkoKSk7XG4gICAgICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgLy8gU2tpcCBuZXN0ZWQgbGVhZiBub2RlcyBpZiB0aGUgcGFyZW50IGhhcyBhbHJlYWR5IGJlZW4gbW92ZWRcbiAgICAgICAgICAgIGNoaWxkLmdldENoaWxkcmVuS2V5cygpLmZvckVhY2goa2V5ID0+IG1vdmVkTm9kZXMuYWRkKGtleSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgICRyZW1vdmVQYXJlbnRFbXB0eUVsZW1lbnRzKHBhcmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbXB0eUVsZW1lbnRzLmhhcyhub2RlLmdldEtleSgpKSkge1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIG5vZGUgaW4gZW1wdHlFbGVtZW50cyB0byBiZSBhbiBFbGVtZW50Tm9kZWApO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0Rm9ybWF0KG5vZGUuZ2V0Rm9ybWF0VHlwZSgpKTtcbiAgICAgIHRhcmdldEVsZW1lbnQuc2V0SW5kZW50KG5vZGUuZ2V0SW5kZW50KCkpO1xuICAgICAgZWxlbWVudHMucHVzaCh0YXJnZXRFbGVtZW50KTtcbiAgICAgIG5vZGUucmVtb3ZlKHRydWUpO1xuICAgIH1cbiAgfVxuICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgd3JhcHBpbmdFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgbGV0IGxhc3RFbGVtZW50ID0gbnVsbDtcblxuICAvLyBJZiBvdXIgdGFyZ2V0IGlzIFJvb3QtbGlrZSwgbGV0J3Mgc2VlIGlmIHdlIGNhbiByZS1hZGp1c3RcbiAgLy8gc28gdGhhdCB0aGUgdGFyZ2V0IGlzIHRoZSBmaXJzdCBjaGlsZCBpbnN0ZWFkLlxuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdCh0YXJnZXQpKSB7XG4gICAgaWYgKHRhcmdldElzUHJldlNpYmxpbmcpIHtcbiAgICAgIGlmICh3cmFwcGluZ0VsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gZWxlbWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgICAgIHRhcmdldCA9IGZpcnN0Q2hpbGQ7XG4gICAgICB9XG4gICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50KSB7XG4gICAgICAgICAgdGFyZ2V0LmFwcGVuZCh3cmFwcGluZ0VsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIHRhcmdldC5hcHBlbmQoZWxlbWVudCk7XG4gICAgICAgICAgICBsYXN0RWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAod3JhcHBpbmdFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUod3JhcHBpbmdFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgICAgICBmaXJzdENoaWxkLmluc2VydEJlZm9yZShlbGVtZW50KTtcbiAgICAgICAgICAgIGxhc3RFbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHdyYXBwaW5nRWxlbWVudCkge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKHdyYXBwaW5nRWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGkgPSBlbGVtZW50cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICAgIHRhcmdldC5pbnNlcnRBZnRlcihlbGVtZW50KTtcbiAgICAgICAgbGFzdEVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBpc1BvaW50QXR0YWNoZWQocHJldlNlbGVjdGlvbi5hbmNob3IpICYmIGlzUG9pbnRBdHRhY2hlZChwcmV2U2VsZWN0aW9uLmZvY3VzKSkge1xuICAgICRzZXRTZWxlY3Rpb24ocHJldlNlbGVjdGlvbi5jbG9uZSgpKTtcbiAgfSBlbHNlIGlmIChsYXN0RWxlbWVudCAhPT0gbnVsbCkge1xuICAgIGxhc3RFbGVtZW50LnNlbGVjdEVuZCgpO1xuICB9IGVsc2Uge1xuICAgIHNlbGVjdGlvbi5kaXJ0eSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUZXN0cyBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGVsZW1lbnQgaGFzIHZlcnRpY2FsIHdyaXRpbmcgbW9kZS5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIHBhcmVudCB0byB0ZXN0LlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9uJ3MgcGFyZW50IGhhcyB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUgKHdyaXRpbmctbW9kZTogdmVydGljYWwtcmwpLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGNvbXB1dGVkU3R5bGUgPSAkZ2V0Q29tcHV0ZWRTdHlsZShzZWxlY3Rpb24pO1xuICByZXR1cm4gY29tcHV0ZWRTdHlsZSAhPT0gbnVsbCAmJiBjb21wdXRlZFN0eWxlLndyaXRpbmdNb2RlID09PSAndmVydGljYWwtcmwnO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGNvbXB1dGVkIERPTSBzdHlsZXMgb2YgdGhlIHBhcmVudCBvZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB0byBjaGVjayB0aGUgc3R5bGVzIGZvci5cbiAqIEByZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZXMgb2YgdGhlIG5vZGUgb3IgbnVsbCBpZiB0aGVyZSBpcyBubyBET00gZWxlbWVudCBvciBubyBkZWZhdWx0IHZpZXcgZm9yIHRoZSBkb2N1bWVudC5cbiAqL1xuZnVuY3Rpb24gJGdldENvbXB1dGVkU3R5bGUoc2VsZWN0aW9uKSB7XG4gIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgaWYgKCRpc0VsZW1lbnROb2RlKGFuY2hvck5vZGUpKSB7XG4gICAgcmV0dXJuICRnZXRDb21wdXRlZFN0eWxlRm9yRWxlbWVudChhbmNob3JOb2RlKTtcbiAgfVxuICByZXR1cm4gJGdldENvbXB1dGVkU3R5bGVGb3JQYXJlbnQoYW5jaG9yTm9kZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0aGUgZGVmYXVsdCBjaGFyYWN0ZXIgc2VsZWN0aW9uIHNob3VsZCBiZSBvdmVycmlkZGVuLiBVc2VkIHdpdGggRGVjb3JhdG9yTm9kZXNcbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIHdob3NlIGRlZmF1bHQgY2hhcmFjdGVyIHNlbGVjdGlvbiBtYXkgbmVlZCB0byBiZSBvdmVycmlkZGVuLlxuICogQHBhcmFtIGlzQmFja3dhcmQgLSBJcyB0aGUgc2VsZWN0aW9uIGJhY2t3YXJkcyAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqIEByZXR1cm5zIHRydWUgaWYgaXQgc2hvdWxkIGJlIG92ZXJyaWRkZW4sIGZhbHNlIGlmIG5vdC5cbiAqL1xuZnVuY3Rpb24gJHNob3VsZE92ZXJyaWRlRGVmYXVsdENoYXJhY3RlclNlbGVjdGlvbihzZWxlY3Rpb24sIGlzQmFja3dhcmQpIHtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9ICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKTtcblxuICAvLyBJbiB2ZXJ0aWNhbCB3cml0aW5nIG1vZGUsIHdlIGFkanVzdCB0aGUgZGlyZWN0aW9uIGZvciBjb3JyZWN0IGNhcmV0IG1vdmVtZW50XG4gIGxldCBhZGp1c3RlZElzQmFja3dhcmQgPSBpc1ZlcnRpY2FsID8gIWlzQmFja3dhcmQgOiBpc0JhY2t3YXJkO1xuXG4gIC8vIEluIHJpZ2h0LXRvLWxlZnQgd3JpdGluZyBtb2RlLCB3ZSBpbnZlcnQgdGhlIGRpcmVjdGlvbiBmb3IgY29ycmVjdCBjYXJldCBtb3ZlbWVudFxuICBpZiAoJGlzUGFyZW50RWxlbWVudFJUTChzZWxlY3Rpb24pKSB7XG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gIWFkanVzdGVkSXNCYWNrd2FyZDtcbiAgfVxuICBjb25zdCBmb2N1c0NhcmV0ID0gJGNhcmV0RnJvbVBvaW50KHNlbGVjdGlvbi5mb2N1cywgYWRqdXN0ZWRJc0JhY2t3YXJkID8gJ3ByZXZpb3VzJyA6ICduZXh0Jyk7XG4gIGlmICgkaXNFeHRlbmRhYmxlVGV4dFBvaW50Q2FyZXQoZm9jdXNDYXJldCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChjb25zdCBuZXh0Q2FyZXQgb2YgJGV4dGVuZENhcmV0VG9SYW5nZShmb2N1c0NhcmV0KSkge1xuICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgIHJldHVybiAhbmV4dENhcmV0Lm9yaWdpbi5pc0lubGluZSgpO1xuICAgIH0gZWxzZSBpZiAoJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzRGVjb3JhdG9yTm9kZShuZXh0Q2FyZXQub3JpZ2luKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBNb3ZlcyB0aGUgc2VsZWN0aW9uIGFjY29yZGluZyB0byB0aGUgYXJndW1lbnRzLlxuICogQHBhcmFtIHNlbGVjdGlvbiAtIFRoZSBzZWxlY3RlZCB0ZXh0IG9yIG5vZGVzLlxuICogQHBhcmFtIGlzSG9sZGluZ1NoaWZ0IC0gSXMgdGhlIHNoaWZ0IGtleSBiZWluZyBoZWxkIGRvd24gZHVyaW5nIHRoZSBvcGVyYXRpb24uXG4gKiBAcGFyYW0gaXNCYWNrd2FyZCAtIElzIHRoZSBzZWxlY3Rpb24gc2VsZWN0ZWQgYmFja3dhcmRzICh0aGUgZm9jdXMgY29tZXMgYmVmb3JlIHRoZSBhbmNob3IpP1xuICogQHBhcmFtIGdyYW51bGFyaXR5IC0gVGhlIGRpc3RhbmNlIHRvIGFkanVzdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKi9cbmZ1bmN0aW9uICRtb3ZlQ2FyZXRTZWxlY3Rpb24oc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCwgZ3JhbnVsYXJpdHkpIHtcbiAgc2VsZWN0aW9uLm1vZGlmeShpc0hvbGRpbmdTaGlmdCA/ICdleHRlbmQnIDogJ21vdmUnLCBpc0JhY2t3YXJkLCBncmFudWxhcml0eSk7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwYXJlbnQgZWxlbWVudCBmb3IgcmlnaHQgdG8gbGVmdCBkaXJlY3Rpb24uXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiB3aG9zZSBwYXJlbnQgaXMgdG8gYmUgdGVzdGVkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgc2VsZWN0aW9ucycgcGFyZW50IGVsZW1lbnQgaGFzIGEgZGlyZWN0aW9uIG9mICdydGwnIChyaWdodCB0byBsZWZ0KSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNQYXJlbnRFbGVtZW50UlRMKHNlbGVjdGlvbikge1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gJGdldENvbXB1dGVkU3R5bGUoc2VsZWN0aW9uKTtcbiAgcmV0dXJuIGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5kaXJlY3Rpb24gPT09ICdydGwnO1xufVxuXG4vKipcbiAqIE1vdmVzIHNlbGVjdGlvbiBieSBjaGFyYWN0ZXIgYWNjb3JkaW5nIHRvIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBzZWxlY3Rpb24gLSBUaGUgc2VsZWN0aW9uIG9mIHRoZSBjaGFyYWN0ZXJzIHRvIG1vdmUuXG4gKiBAcGFyYW0gaXNIb2xkaW5nU2hpZnQgLSBJcyB0aGUgc2hpZnQga2V5IGJlaW5nIGhlbGQgZG93biBkdXJpbmcgdGhlIG9wZXJhdGlvbi5cbiAqIEBwYXJhbSBpc0JhY2t3YXJkIC0gSXMgdGhlIHNlbGVjdGlvbiBiYWNrd2FyZCAodGhlIGZvY3VzIGNvbWVzIGJlZm9yZSB0aGUgYW5jaG9yKT9cbiAqL1xuZnVuY3Rpb24gJG1vdmVDaGFyYWN0ZXIoc2VsZWN0aW9uLCBpc0hvbGRpbmdTaGlmdCwgaXNCYWNrd2FyZCkge1xuICBjb25zdCBpc1JUTCA9ICRpc1BhcmVudEVsZW1lbnRSVEwoc2VsZWN0aW9uKTtcbiAgY29uc3QgaXNWZXJ0aWNhbCA9ICRpc0VkaXRvclZlcnRpY2FsT3JpZW50YXRpb24oc2VsZWN0aW9uKTtcblxuICAvLyBJbiB2ZXJ0aWNhbC1ybCB3cml0aW5nIG1vZGUsIGFycm93IGtleSBkaXJlY3Rpb25zIG5lZWQgdG8gYmUgZmxpcHBlZFxuICAvLyB0byBtYXRjaCB0aGUgdmlzdWFsIGZsb3cgb2YgdGV4dCAodG9wIHRvIGJvdHRvbSwgcmlnaHQgdG8gbGVmdClcbiAgbGV0IGFkanVzdGVkSXNCYWNrd2FyZDtcbiAgaWYgKGlzVmVydGljYWwpIHtcbiAgICAvLyBJbiB2ZXJ0aWNhbC1ybCBtb2RlLCB3ZSBuZWVkIHRvIGNvbXBsZXRlbHkgaW52ZXJ0IHRoZSBkaXJlY3Rpb25cbiAgICAvLyBMZWZ0IGFycm93IChiYWNrd2FyZCkgc2hvdWxkIG1vdmUgZG93biAoZm9yd2FyZClcbiAgICAvLyBSaWdodCBhcnJvdyAoZm9yd2FyZCkgc2hvdWxkIG1vdmUgdXAgKGJhY2t3YXJkKVxuICAgIGFkanVzdGVkSXNCYWNrd2FyZCA9ICFpc0JhY2t3YXJkO1xuICB9IGVsc2UgaWYgKGlzUlRMKSB7XG4gICAgLy8gSW4gaG9yaXpvbnRhbCBSVEwgbW9kZSwgdXNlIHRoZSBzdGFuZGFyZCBSVEwgYmVoYXZpb3JcbiAgICBhZGp1c3RlZElzQmFja3dhcmQgPSAhaXNCYWNrd2FyZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGFuZGFyZCBMVFIgaG9yaXpvbnRhbCB0ZXh0XG4gICAgYWRqdXN0ZWRJc0JhY2t3YXJkID0gaXNCYWNrd2FyZDtcbiAgfVxuXG4gIC8vIEFwcGx5IHRoZSBkaXJlY3Rpb24gYWRqdXN0bWVudCB0byBtb3ZlIHRoZSBjYXJldFxuICAkbW92ZUNhcmV0U2VsZWN0aW9uKHNlbGVjdGlvbiwgaXNIb2xkaW5nU2hpZnQsIGFkanVzdGVkSXNCYWNrd2FyZCwgJ2NoYXJhY3RlcicpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgYSBDU1MgcHJvcGVydHkgZm9yIE5vZGVzLCBpZiBzZXQuIElmIG5vdCBzZXQsIGl0IHJldHVybnMgdGhlIGRlZmF1bHRWYWx1ZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgd2hvc2Ugc3R5bGUgdmFsdWUgdG8gZ2V0LlxuICogQHBhcmFtIHN0eWxlUHJvcGVydHkgLSBUaGUgQ1NTIHN0eWxlIHByb3BlcnR5LlxuICogQHBhcmFtIGRlZmF1bHRWYWx1ZSAtIFRoZSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgcHJvcGVydHkuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciBub2RlLlxuICovXG5mdW5jdGlvbiAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpIHtcbiAgY29uc3QgY3NzID0gbm9kZS5nZXRTdHlsZSgpO1xuICBjb25zdCBzdHlsZU9iamVjdCA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhjc3MpO1xuICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwpIHtcbiAgICByZXR1cm4gc3R5bGVPYmplY3Rbc3R5bGVQcm9wZXJ0eV0gfHwgZGVmYXVsdFZhbHVlO1xuICB9XG4gIHJldHVybiBkZWZhdWx0VmFsdWU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZSBvZiBhIENTUyBwcm9wZXJ0eSBmb3IgVGV4dE5vZGVzIGluIHRoZSBTZWxlY3Rpb24sIGlmIHNldC4gSWYgbm90IHNldCwgaXQgcmV0dXJucyB0aGUgZGVmYXVsdFZhbHVlLlxuICogSWYgYWxsIFRleHROb2RlcyBkbyBub3QgaGF2ZSB0aGUgc2FtZSB2YWx1ZSwgaXQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcGFyYW0gc2VsZWN0aW9uIC0gVGhlIHNlbGVjdGlvbiBvZiBUZXh0Tm9kZXMgd2hvc2UgdmFsdWUgdG8gZmluZC5cbiAqIEBwYXJhbSBzdHlsZVByb3BlcnR5IC0gVGhlIENTUyBzdHlsZSBwcm9wZXJ0eS5cbiAqIEBwYXJhbSBkZWZhdWx0VmFsdWUgLSBUaGUgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIHByb3BlcnR5LCBkZWZhdWx0cyB0byBhbiBlbXB0eSBzdHJpbmcuXG4gKiBAcmV0dXJucyBUaGUgdmFsdWUgb2YgdGhlIHByb3BlcnR5IGZvciB0aGUgc2VsZWN0ZWQgVGV4dE5vZGVzLlxuICovXG5mdW5jdGlvbiAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5KHNlbGVjdGlvbiwgc3R5bGVQcm9wZXJ0eSwgZGVmYXVsdFZhbHVlID0gJycpIHtcbiAgbGV0IHN0eWxlVmFsdWUgPSBudWxsO1xuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICBjb25zdCBhbmNob3IgPSBzZWxlY3Rpb24uYW5jaG9yO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gIGNvbnN0IGVuZE9mZnNldCA9IGlzQmFja3dhcmQgPyBmb2N1cy5vZmZzZXQgOiBhbmNob3Iub2Zmc2V0O1xuICBjb25zdCBlbmROb2RlID0gaXNCYWNrd2FyZCA/IGZvY3VzLmdldE5vZGUoKSA6IGFuY2hvci5nZXROb2RlKCk7XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpICYmIHNlbGVjdGlvbi5zdHlsZSAhPT0gJycpIHtcbiAgICBjb25zdCBjc3MgPSBzZWxlY3Rpb24uc3R5bGU7XG4gICAgY29uc3Qgc3R5bGVPYmplY3QgPSBnZXRTdHlsZU9iamVjdEZyb21DU1MoY3NzKTtcbiAgICBpZiAoc3R5bGVPYmplY3QgIT09IG51bGwgJiYgc3R5bGVQcm9wZXJ0eSBpbiBzdHlsZU9iamVjdCkge1xuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0W3N0eWxlUHJvcGVydHldO1xuICAgIH1cbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuXG4gICAgLy8gaWYgbm8gYWN0dWFsIGNoYXJhY3RlcnMgaW4gdGhlIGVuZCBub2RlIGFyZSBzZWxlY3RlZCwgd2UgZG9uJ3RcbiAgICAvLyBpbmNsdWRlIGl0IGluIHRoZSBzZWxlY3Rpb24gZm9yIHB1cnBvc2VzIG9mIGRldGVybWluaW5nIHN0eWxlXG4gICAgLy8gdmFsdWVcbiAgICBpZiAoaSAhPT0gMCAmJiBlbmRPZmZzZXQgPT09IDAgJiYgbm9kZS5pcyhlbmROb2RlKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICgkaXNUZXh0Tm9kZShub2RlKSkge1xuICAgICAgY29uc3Qgbm9kZVN0eWxlVmFsdWUgPSAkZ2V0Tm9kZVN0eWxlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBzdHlsZVByb3BlcnR5LCBkZWZhdWx0VmFsdWUpO1xuICAgICAgaWYgKHN0eWxlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgc3R5bGVWYWx1ZSA9IG5vZGVTdHlsZVZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChzdHlsZVZhbHVlICE9PSBub2RlU3R5bGVWYWx1ZSkge1xuICAgICAgICAvLyBtdWx0aXBsZSB0ZXh0IG5vZGVzIGFyZSBpbiB0aGUgc2VsZWN0aW9uIGFuZCB0aGV5IGRvbid0IGFsbFxuICAgICAgICAvLyBoYXZlIHRoZSBzYW1lIHN0eWxlLlxuICAgICAgICBzdHlsZVZhbHVlID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVWYWx1ZSA9PT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IHN0eWxlVmFsdWU7XG59XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICR0cmltVGV4dENvbnRlbnRGcm9tQW5jaG9yfSBieSBAbGV4aWNhbC9lc2xpbnQtcGx1Z2luIHJ1bGVzLW9mLWxleGljYWwgKi9cbmNvbnN0IHRyaW1UZXh0Q29udGVudEZyb21BbmNob3IgPSAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvcjtcblxuZXhwb3J0IHsgJGFkZE5vZGVTdHlsZSwgJGNvcHlCbG9ja0Zvcm1hdEluZGVudCwgJGVuc3VyZUZvcndhcmRSYW5nZVNlbGVjdGlvbiwgJGZvckVhY2hTZWxlY3RlZFRleHROb2RlLCAkZ2V0Q29tcHV0ZWRTdHlsZUZvckVsZW1lbnQsICRnZXRDb21wdXRlZFN0eWxlRm9yUGFyZW50LCAkZ2V0U2VsZWN0aW9uU3R5bGVWYWx1ZUZvclByb3BlcnR5LCAkaXNBdE5vZGVFbmQsICRpc1BhcmVudEVsZW1lbnRSVEwsICRpc1BhcmVudFJUTCwgJG1vdmVDYXJldFNlbGVjdGlvbiwgJG1vdmVDaGFyYWN0ZXIsICRwYXRjaFN0eWxlVGV4dCwgJHNldEJsb2Nrc1R5cGUsICRzaG91bGRPdmVycmlkZURlZmF1bHRDaGFyYWN0ZXJTZWxlY3Rpb24sICRzbGljZVNlbGVjdGVkVGV4dE5vZGVDb250ZW50LCAkdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciwgJHdyYXBOb2RlcywgY3JlYXRlRE9NUmFuZ2UsIGNyZWF0ZVJlY3RzRnJvbURPTVJhbmdlLCBnZXRDU1NGcm9tU3R5bGVPYmplY3QsIGdldFN0eWxlT2JqZWN0RnJvbUNTUywgdHJpbVRleHRDb250ZW50RnJvbUFuY2hvciB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\n");

/***/ })

};
;