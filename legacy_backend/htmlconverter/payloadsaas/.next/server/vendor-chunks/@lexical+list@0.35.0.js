"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+list@0.35.0";
exports.ids = ["vendor-chunks/@lexical+list@0.35.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $insertList: () => (/* binding */ $insertList),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   $removeList: () => (/* binding */ $removeList),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   UPDATE_LIST_START_COMMAND: () => (/* binding */ UPDATE_LIST_START_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   registerCheckList: () => (/* binding */ registerCheckList),\n/* harmony export */   registerList: () => (/* binding */ registerList),\n/* harmony export */   registerListStrictIndentTransform: () => (/* binding */ registerListStrictIndentTransform),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(rsc)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !($isListNode(node) || node.isInline()) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.calculateZoomLevel)(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(event.target)) {\n      const domNode = event.target;\n      const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getNearestEditorFromDOMNode)(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlzdEAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtTDtBQUN1VztBQUMvZDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5REFBZ0I7QUFDcEQ7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7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VSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0MsNkNBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUFtQjtBQUNwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThZIiwic291cmNlcyI6WyIvVXNlcnMvbWFjL1N5bmMvcHJvamVjdC9lY29tbWVyY2Uvc2hvcHNhYXMvaHRtbGNvbnZlcnRlci9wYXlsb2Fkc2Fhcy9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlzdEAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZXROZWFyZXN0Tm9kZU9mVHlwZSwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBpc0hUTUxFbGVtZW50LCBtZXJnZVJlZ2lzdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCBjYWxjdWxhdGVab29tTGV2ZWwgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNMZWFmTm9kZSwgJHNldFBvaW50RnJvbUNhcmV0LCAkbm9ybWFsaXplQ2FyZXQsICRnZXRDaGlsZENhcmV0LCBFbGVtZW50Tm9kZSwgYnVpbGRJbXBvcnRNYXAsICRpc1BhcmFncmFwaE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGNyZWF0ZVRleHROb2RlLCBjcmVhdGVDb21tYW5kLCBDT01NQU5EX1BSSU9SSVRZX0xPVywgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX1NQQUNFX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUsICRnZXROb2RlQnlLZXksIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgJGlzVGV4dE5vZGUsIFRleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBnZXRTdHlsZU9iamVjdEZyb21DU1MgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBkZXB0aCBvZiBsaXN0Tm9kZSBmcm9tIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gbGlzdE5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRoZSBkZXB0aCBvZiB0aGUgTGlzdE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRnZXRMaXN0RGVwdGgobGlzdE5vZGUpIHtcbiAgbGV0IGRlcHRoID0gMTtcbiAgbGV0IHBhcmVudCA9IGxpc3ROb2RlLmdldFBhcmVudCgpO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudExpc3QgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50TGlzdC5nZXRQYXJlbnQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmV0dXJucyBpdCwgdGhyb3dzIGFuIGludmFyaWFudCBpZiBsaXN0SXRlbSBpcyBub3QgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW0gLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIExpc3ROb2RlIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW0pIHtcbiAgbGV0IGxpc3QgPSBsaXN0SXRlbS5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgIH1cbiAgfVxuICBsZXQgcGFyZW50ID0gbGlzdDtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQSByZWN1cnNpdmUgRGVwdGgtRmlyc3QgU2VhcmNoIChQb3N0b3JkZXIgVHJhdmVyc2FsKSB0aGF0IGZpbmRzIGFsbCBvZiBhIG5vZGUncyBjaGlsZHJlblxuICogdGhhdCBhcmUgb2YgdHlwZSBMaXN0SXRlbU5vZGUgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIExpc3ROb2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBub2RlcyBvZiB0eXBlIExpc3RJdGVtTm9kZSBmb3VuZC5cbiAqL1xuLy8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgJGdldEFsbENoaWxkcmVuT2ZUeXBlXG5mdW5jdGlvbiAkZ2V0QWxsTGlzdEl0ZW1zKG5vZGUpIHtcbiAgbGV0IGxpc3RJdGVtTm9kZXMgPSBbXTtcbiAgY29uc3QgbGlzdENoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpLmZpbHRlcigkaXNMaXN0SXRlbU5vZGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9IGxpc3RDaGlsZHJlbltpXTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGxpc3RJdGVtTm9kZXMgPSBsaXN0SXRlbU5vZGVzLmNvbmNhdCgkZ2V0QWxsTGlzdEl0ZW1zKGZpcnN0Q2hpbGQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdEl0ZW1Ob2Rlcy5wdXNoKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0SXRlbU5vZGVzO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHBhc3NlZCBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBhcyBhIGNoaWxkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSBhbmQgaGFzIGEgTGlzdE5vZGUgY2hpbGQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOZXN0ZWRMaXN0Tm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgJGlzTGlzdE5vZGUobm9kZS5nZXRGaXJzdENoaWxkKCkpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgZGVlcGx5IG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgYW5kIHRyYXZlcnNlcyB1cCB0aGUgYnJhbmNoIHRvIGRlbGV0ZSB0aGUgZmlyc3RcbiAqIGFuY2VzdHJhbCBMaXN0Tm9kZSAod2hpY2ggY291bGQgYmUgdGhlIHJvb3QgTGlzdE5vZGUpIG9yIExpc3RJdGVtTm9kZSB3aXRoIHNpYmxpbmdzLCBlc3NlbnRpYWxseVxuICogYnJpbmdpbmcgdGhlIGRlZXBseSBuZXN0ZWQgbm9kZSB1cCB0aGUgYnJhbmNoIG9uY2UuIFdvdWxkIHJlbW92ZSBzdWJsaXN0IGlmIGl0IGhhcyBzaWJsaW5ncy5cbiAqIFNob3VsZCBub3QgYnJlYWsgTGlzdEl0ZW0gLT4gTGlzdCAtPiBMaXN0SXRlbSBjaGFpbiBhcyBlbXB0eSBMaXN0L0l0ZW1Ob2RlcyBzaG91bGQgYmUgcmVtb3ZlZCBvbiAucmVtb3ZlKCkuXG4gKiBAcGFyYW0gc3VibGlzdCAtIFRoZSBuZXN0ZWQgTGlzdE5vZGUgb3IgTGlzdEl0ZW1Ob2RlIHRvIGJlIGJyb3VnaHQgdXAgdGhlIGJyYW5jaC5cbiAqL1xuZnVuY3Rpb24gJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoc3VibGlzdCkge1xuICAvLyBOb2RlcyBtYXkgYmUgcmVwZWF0ZWRseSBpbmRlbnRlZCwgdG8gY3JlYXRlIGRlZXBseSBuZXN0ZWQgbGlzdHMgdGhhdCBlYWNoXG4gIC8vIGNvbnRhaW4ganVzdCBvbmUgYnVsbGV0LlxuICAvLyBPdXIgZ29hbCBpcyB0byByZW1vdmUgdGhlc2UgKGVtcHR5KSBkZWVwbHkgbmVzdGVkIGxpc3RzLiBUaGUgZWFzaWVzdFxuICAvLyB3YXkgdG8gZG8gdGhhdCBpcyBjcmF3bCBiYWNrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBub2RlIHRoYXQgaGFzIHNpYmxpbmdzXG4gIC8vIChlLmcuIGlzIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgY29udGVudHMpIGFuZCBkZWxldGUgdGhhdCwgb3IgZGVsZXRlXG4gIC8vIHRoZSByb290IG9mIHRoZSBsaXN0IChpZiBubyBsaXN0IG5vZGVzIGhhdmUgc2libGluZ3MuKVxuICBsZXQgZW1wdHlMaXN0UHRyID0gc3VibGlzdDtcbiAgd2hpbGUgKGVtcHR5TGlzdFB0ci5nZXROZXh0U2libGluZygpID09IG51bGwgJiYgZW1wdHlMaXN0UHRyLmdldFByZXZpb3VzU2libGluZygpID09IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbXB0eUxpc3RQdHIuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICEoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkgfHwgJGlzTGlzdE5vZGUocGFyZW50KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbXB0eUxpc3RQdHIgPSBwYXJlbnQ7XG4gIH1cbiAgZW1wdHlMaXN0UHRyLnJlbW92ZSgpO1xufVxuXG4vKipcbiAqIFdyYXBzIGEgbm9kZSBpbnRvIGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSB3cmFwcGVkIGludG8gYSBMaXN0SXRlbU5vZGVcbiAqIEByZXR1cm5zIFRoZSBMaXN0SXRlbU5vZGUgd2hpY2ggdGhlIHBhc3NlZCBub2RlIGlzIHdyYXBwZWQgaW4uXG4gKi9cbmZ1bmN0aW9uICR3cmFwSW5MaXN0SXRlbShub2RlKSB7XG4gIGNvbnN0IGxpc3RJdGVtV3JhcHBlciA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgcmV0dXJuIGxpc3RJdGVtV3JhcHBlci5hcHBlbmQobm9kZSk7XG59XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSAmJiAobm9kZXMubGVuZ3RoID09PSAwIHx8IG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBhbmNob3JOb2RlLmlzKG5vZGVzWzBdKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IExpc3ROb2RlLiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlIGFuZCBpcyBhIGNoaWxkIG9mXG4gKiB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCByZXBsYWNlIHRoZSBMaXN0SXRlbU5vZGUgd2l0aCBhIExpc3ROb2RlIGFuZCB0aGUgb2xkIExpc3RJdGVtTm9kZS5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHJlcGxhY2UgaXRzIHBhcmVudCB3aXRoIGEgbmV3IExpc3ROb2RlIGFuZCByZS1pbnNlcnQgdGhlIExpc3RJdGVtTm9kZSBhbmQgYW55IHByZXZpb3VzIGNoaWxkcmVuLlxuICogSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIG5vdCBhbiBlbXB0eSBMaXN0SXRlbU5vZGUsIGl0IHdpbGwgYWRkIGEgbmV3IExpc3ROb2RlIG9yIG1lcmdlIGFuIGV4aXN0aW5nIExpc3ROb2RlLFxuICogdW5sZXNzIHRoZSB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIExpc3ROb2RlIHVwIHRoZSBicmFuY2ggYW5kIHJlcGxhY2UgaXQgd2l0aFxuICogYSBuZXcgTGlzdE5vZGUsIG9yIGNyZWF0ZSBhIG5ldyBMaXN0Tm9kZSBhdCB0aGUgbmVhcmVzdCByb290L3NoYWRvdyByb290LlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCwgXCJudW1iZXJcIiB8IFwiYnVsbGV0XCIgfCBcImNoZWNrXCIuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRMaXN0KGxpc3RUeXBlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGxldCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICAgICAgaWYgKCEoYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0TGlzdDogYW5jaG9yIHNob3VsZCBiZSBkZWZpbmVkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBbYW5jaG9yXSA9IGFuY2hvckFuZEZvY3VzO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBhbmNob3JOb2RlUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBhbmNob3JOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBub2RlcyA9IGZpcnN0Q2hpbGQuc2VsZWN0U3RhcnQoKS5nZXROb2RlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgYW5jaG9yTm9kZS5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgICBub2RlcyA9IHBhcmFncmFwaC5zZWxlY3QoKS5nZXROb2RlcygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlUGFyZW50KSkge1xuICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLnNldEZvcm1hdChhbmNob3JOb2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRJbmRlbnQoYW5jaG9yTm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgIHBhcmVudC5yZXBsYWNlKGxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgISRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAhaGFuZGxlZC5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgJGNyZWF0ZUxpc3RPck1lcmdlKG5vZGUsIGxpc3RUeXBlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50ID0gJGlzTGVhZk5vZGUobm9kZSkgPyBub2RlLmdldFBhcmVudCgpIDogJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmIG5vZGUuaXNFbXB0eSgpID8gbm9kZSA6IG51bGw7XG4gICAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgIGlmICghaGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xpc3ROb2RlLCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgICBwYXJlbnQucmVwbGFjZShuZXdMaXN0Tm9kZSk7XG4gICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5leHRQYXJlbnQpICYmICFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgJGNyZWF0ZUxpc3RPck1lcmdlKHBhcmVudCwgbGlzdFR5cGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZChub2RlLCBub2Rlc1RvQXBwZW5kKSB7XG4gIG5vZGUuc3BsaWNlKG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIG5vZGVzVG9BcHBlbmQpO1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpc3RPck1lcmdlKG5vZGUsIGxpc3RUeXBlKSB7XG4gIGlmICgkaXNMaXN0Tm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuICBsZXQgdGFyZ2V0TGlzdDtcbiAgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzU2libGluZykgJiYgbGlzdFR5cGUgPT09IHByZXZpb3VzU2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgcHJldmlvdXNTaWJsaW5nLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgLy8gaWYgdGhlIHNhbWUgdHlwZSBvZiBsaXN0IGlzIG9uIGJvdGggc2lkZXMsIG1lcmdlIHRoZW0uXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGFyZ2V0TGlzdCA9IHByZXZpb3VzU2libGluZztcbiAgfSBlbHNlIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdFR5cGUgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmluc2VydEJlZm9yZShsaXN0SXRlbSk7XG4gICAgdGFyZ2V0TGlzdCA9IG5leHRTaWJsaW5nO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlcGxhY2UobGlzdCk7XG4gICAgdGFyZ2V0TGlzdCA9IGxpc3Q7XG4gIH1cbiAgLy8gbGlzdEl0ZW0gbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gcm9vdCBwcmlvciB0byBzZXR0aW5nIGluZGVudFxuICBsaXN0SXRlbS5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICBsaXN0SXRlbS5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gIG5vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YXJnZXRMaXN0O1xufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZ29lcyB0aHJvdWdoIGVhY2ggbGlzdCBhbmQgdGhlaXIgY2hpbGRyZW4sIGluY2x1ZGluZyBuZXN0ZWQgbGlzdHMsXG4gKiBhcHBlbmRpbmcgbGlzdDIgY2hpbGRyZW4gYWZ0ZXIgbGlzdDEgY2hpbGRyZW4gYW5kIHVwZGF0aW5nIExpc3RJdGVtTm9kZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbGlzdDEgLSBUaGUgZmlyc3QgbGlzdCB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0gbGlzdDIgLSBUaGUgc2Vjb25kIGxpc3QgdG8gYmUgbWVyZ2VkLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBjb25zdCBsaXN0SXRlbTEgPSBsaXN0MS5nZXRMYXN0Q2hpbGQoKTtcbiAgY29uc3QgbGlzdEl0ZW0yID0gbGlzdDIuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAobGlzdEl0ZW0xICYmIGxpc3RJdGVtMiAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMSkgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTIpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0SXRlbTEuZ2V0Rmlyc3RDaGlsZCgpLCBsaXN0SXRlbTIuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICBsaXN0SXRlbTIucmVtb3ZlKCk7XG4gIH1cbiAgY29uc3QgdG9NZXJnZSA9IGxpc3QyLmdldENoaWxkcmVuKCk7XG4gIGlmICh0b01lcmdlLmxlbmd0aCA+IDApIHtcbiAgICBsaXN0MS5hcHBlbmQoLi4udG9NZXJnZSk7XG4gIH1cbiAgbGlzdDIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlTGlzdCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGxpc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGFuY2hvck5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmICgkaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9ICRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBMaXN0SXRlbU5vZGUpO1xuICAgICAgICAgIGlmIChsaXN0SXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGlzdE5vZGUgb2YgbGlzdE5vZGVzKSB7XG4gICAgICBsZXQgaW5zZXJ0aW9uUG9pbnQgPSBsaXN0Tm9kZTtcbiAgICAgIGNvbnN0IGxpc3RJdGVtcyA9ICRnZXRBbGxMaXN0SXRlbXMobGlzdE5vZGUpO1xuICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuc2V0VGV4dFN0eWxlKHNlbGVjdGlvbi5zdHlsZSkuc2V0VGV4dEZvcm1hdChzZWxlY3Rpb24uZm9ybWF0KTtcbiAgICAgICAgYXBwZW5kKHBhcmFncmFwaCwgbGlzdEl0ZW1Ob2RlLmdldENoaWxkcmVuKCkpO1xuICAgICAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihwYXJhZ3JhcGgpO1xuICAgICAgICBpbnNlcnRpb25Qb2ludCA9IHBhcmFncmFwaDtcblxuICAgICAgICAvLyBXaGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIGZhbGwgb24gdGhlIHRleHROb2RlXG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gYmVjYXVzZSB0aGUgdGV4dE5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0b1xuICAgICAgICAvLyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgLy8gV2hlbiBzZWxlY3Rpb24gaXMgaW4gZW1wdHkgbmVzdGVkIGxpc3QgaXRlbSwgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IG9uIHRoZSBsaXN0SXRlbU5vZGUuXG4gICAgICAgIC8vIFdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgbGlzdEl0ZW1Ob2RlIGlzIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIGJ5IHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoXG4gICAgICAgIC8vIHdlIHNob3VsZCBtYW51YWxseSBzZXQgdGhlIHNlbGVjdGlvbidzIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGUuX19rZXkgPT09IHNlbGVjdGlvbi5hbmNob3Iua2V5KSB7XG4gICAgICAgICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsICRub3JtYWxpemVDYXJldCgkZ2V0Q2hpbGRDYXJldChwYXJhZ3JhcGgsICduZXh0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgJG5vcm1hbGl6ZUNhcmV0KCRnZXRDaGlsZENhcmV0KHBhcmFncmFwaCwgJ25leHQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtTm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIGNoaWxkIExpc3RJdGVtTm9kZSBhbmQgbWFrZXMgaXQgdGhlIHZhbHVlIHRoZSBMaXN0SXRlbU5vZGVcbiAqIHNob3VsZCBiZSBpZiBpdCBpc24ndCBhbHJlYWR5LiBBbHNvIGVuc3VyZXMgdGhhdCBjaGVja2VkIGlzIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHBhcmVudCBkb2VzIG5vdCBoYXZlIGEgbGlzdCB0eXBlIG9mICdjaGVjaycuXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIGNoaWxkcmVuIGFyZSB1cGRhdGVkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdCkge1xuICBjb25zdCBpc05vdENoZWNrbGlzdCA9IGxpc3QuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJztcbiAgbGV0IHZhbHVlID0gbGlzdC5nZXRTdGFydCgpO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpc3QuZ2V0Q2hpbGRyZW4oKSkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQuZ2V0VmFsdWUoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hpbGQuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTm90Q2hlY2tsaXN0ICYmIGNoaWxkLmdldExhdGVzdCgpLl9fY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIGNoaWxkLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghJGlzTGlzdE5vZGUoY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgICB2YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBuZXh0IHNpYmxpbmcgbGlzdCBpZiBzYW1lIHR5cGUuXG4gKiA8dWw+IHdpbGwgbWVyZ2Ugd2l0aCA8dWw+LCBidXQgTk9UIDx1bD4gd2l0aCA8b2w+LlxuICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCB3aG9zZSBuZXh0IHNpYmxpbmcgc2hvdWxkIGJlIHBvdGVudGlhbGx5IG1lcmdlZFxuICovXG5mdW5jdGlvbiBtZXJnZU5leHRTaWJsaW5nTGlzdElmU2FtZVR5cGUobGlzdCkge1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3QuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0LmdldExpc3RUeXBlKCkgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluIGF0IGxpc3RJdGVtTm9kZSwgc28gYXMgdG9cbiAqIGNyZWF0ZSBhbiBpbmRlbnQgZWZmZWN0LiBXb24ndCBpbmRlbnQgTGlzdEl0ZW1Ob2RlcyB0aGF0IGhhdmUgYSBMaXN0Tm9kZSBhc1xuICogYSBjaGlsZCwgYnV0IGRvZXMgbWVyZ2Ugc2libGluZyBMaXN0SXRlbU5vZGVzIGlmIG9uZSBoYXMgYSBuZXN0ZWQgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byBiZSBpbmRlbnRlZC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUluZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuICBjb25zdCByZW1vdmVkID0gbmV3IFNldCgpO1xuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpIHx8IHJlbW92ZWQuaGFzKGxpc3RJdGVtTm9kZS5nZXRLZXkoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuXG4gIC8vIFdlIGNhbiBjYXN0IGJvdGggb2YgdGhlIGJlbG93IGBpc05lc3RlZExpc3ROb2RlYCBvbmx5IHJldHVybnMgYSBib29sZWFuIHR5cGUgaW5zdGVhZCBvZiBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkc1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBpbm5lckxpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBjb25zdCBuZXh0SW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKG5leHRJbm5lckxpc3QpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV4dElubmVyTGlzdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBhcHBlbmQoaW5uZXJMaXN0LCBjaGlsZHJlbik7XG4gICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICByZW1vdmVkLmFkZChuZXh0U2libGluZy5nZXRLZXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgLy8gaWYgdGhlIExpc3RJdGVtTm9kZSBpcyBuZXh0IHRvIGEgbmVzdGVkIExpc3ROb2RlLCBtZXJnZSB0aGVtXG4gICAgY29uc3QgaW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gaW5uZXJMaXN0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBuZXN0ZWQgTGlzdE5vZGVcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKS5zZXRUZXh0Rm9ybWF0KGxpc3RJdGVtTm9kZS5nZXRUZXh0Rm9ybWF0KCkpLnNldFRleHRTdHlsZShsaXN0SXRlbU5vZGUuZ2V0VGV4dFN0eWxlKCkpO1xuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSkuc2V0VGV4dEZvcm1hdChwYXJlbnQuZ2V0VGV4dEZvcm1hdCgpKS5zZXRUZXh0U3R5bGUocGFyZW50LmdldFRleHRTdHlsZSgpKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIG5ld0xpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIHByZXZpb3VzU2libGluZy5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIG5leHRTaWJsaW5nLmluc2VydEJlZm9yZShuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kKG5ld0xpc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGluZGVudCBieSByZW1vdmluZyBhbiBlbXB0eSBMaXN0Tm9kZS9MaXN0SXRlbU5vZGUgY2hhaW4uIEFuIGluZGVudGVkIExpc3RJdGVtTm9kZVxuICogaGFzIGEgZ3JlYXQgZ3JhbmRwYXJlbnQgbm9kZSBvZiB0eXBlIExpc3ROb2RlLCB3aGljaCBpcyB3aGVyZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpbGwgcmVzaWRlXG4gKiB3aXRoaW4gYXMgYSBjaGlsZC5cbiAqIEBwYXJhbSBsaXN0SXRlbU5vZGUgLSBUaGUgTGlzdEl0ZW1Ob2RlIHRvIHJlbW92ZSB0aGUgaW5kZW50IChvdXRkZW50KS5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZU91dGRlbnQobGlzdEl0ZW1Ob2RlKSB7XG4gIC8vIGdvIHRocm91Z2ggZWFjaCBub2RlIGFuZCBkZWNpZGUgd2hlcmUgdG8gbW92ZSBpdC5cblxuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudExpc3QgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gIGNvbnN0IGdyYW5kcGFyZW50TGlzdEl0ZW0gPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZ3JlYXRHcmFuZHBhcmVudExpc3QgPSBncmFuZHBhcmVudExpc3RJdGVtID8gZ3JhbmRwYXJlbnRMaXN0SXRlbS5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgLy8gSWYgaXQgZG9lc24ndCBoYXZlIHRoZXNlIGFuY2VzdG9ycywgaXQncyBub3QgaW5kZW50ZWQuXG5cbiAgaWYgKCRpc0xpc3ROb2RlKGdyZWF0R3JhbmRwYXJlbnRMaXN0KSAmJiAkaXNMaXN0SXRlbU5vZGUoZ3JhbmRwYXJlbnRMaXN0SXRlbSkgJiYgJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGJlZm9yZSB0aGUgZ3JhbmRwYXJlbnRcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0Rmlyc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldExhc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuICAgIGlmIChsaXN0SXRlbU5vZGUuaXMoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGl0J3MgdGhlIGxhc3QgY2hpbGQgaW4gaXQncyBwYXJlbnQgbGlzdCwgaW5zZXJ0IGl0IGludG8gdGhlXG4gICAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGFmdGVyIHRoZSBncmFuZHBhcmVudC5cbiAgICB9IGVsc2UgaWYgKGxpc3RJdGVtTm9kZS5pcyhsYXN0Q2hpbGQpKSB7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBzaWJsaW5ncyBpbnRvIHR3byBuZXcgbmVzdGVkIGxpc3RzXG4gICAgICBjb25zdCBsaXN0VHlwZSA9IHBhcmVudExpc3QuZ2V0TGlzdFR5cGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIHByZXZpb3VzU2libGluZ3NMaXN0SXRlbS5hcHBlbmQocHJldmlvdXNTaWJsaW5nc0xpc3QpO1xuICAgICAgbGlzdEl0ZW1Ob2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5mb3JFYWNoKHNpYmxpbmcgPT4gcHJldmlvdXNTaWJsaW5nc0xpc3QuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICBuZXh0U2libGluZ3NMaXN0SXRlbS5hcHBlbmQobmV4dFNpYmxpbmdzTGlzdCk7XG4gICAgICBhcHBlbmQobmV4dFNpYmxpbmdzTGlzdCwgbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5ncygpKTtcbiAgICAgIC8vIHB1dCB0aGUgc2libGluZyBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSBpbiB0aGUgZ3JlYXQgZ3JhbmRwYXJlbnQuXG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEJlZm9yZShwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0pO1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRBZnRlcihuZXh0U2libGluZ3NMaXN0SXRlbSk7XG4gICAgICAvLyByZXBsYWNlIHRoZSBncmFuZHBhcmVudCBsaXN0IGl0ZW0gKG5vdyBiZXR3ZWVuIHRoZSBzaWJsaW5ncykgd2l0aCB0aGUgb3V0ZGVudGVkIGxpc3QgaXRlbS5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVwbGFjZShsaXN0SXRlbU5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBhIFBhcmFncmFwaE5vZGUgYXQgc2VsZWN0aW9uIGFuZCBzZWxlY3RzIHRoZSBuZXcgbm9kZS4gVGhlIHNlbGVjdGlvbiBtdXN0IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGVcbiAqIG9yIGEgbm9kZSB0aGF0IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiB0ZXh0LiBJZiBpdHMgZ3JhbmRwYXJlbnQgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgZ2V0IHRoZSBMaXN0Tm9kZVxuICogKHdoaWNoIHNob3VsZCBiZSB0aGUgcGFyZW50IG5vZGUpIGFuZCBpbnNlcnQgdGhlIFBhcmFncmFwaE5vZGUgYXMgYSBzaWJsaW5nIHRvIHRoZSBMaXN0Tm9kZS4gSWYgdGhlIExpc3ROb2RlIGlzXG4gKiBuZXN0ZWQgaW4gYSBMaXN0SXRlbU5vZGUgaW5zdGVhZCwgaXQgd2lsbCBhZGQgdGhlIFBhcmFncmFwaE5vZGUgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50IExpc3RJdGVtTm9kZS5cbiAqIFRocm93cyBhbiBpbnZhcmlhbnQgaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgYSBjaGlsZCBvZiBhIExpc3ROb2RlLlxuICogQHJldHVybnMgdHJ1ZSBpZiBhIFBhcmFncmFwaE5vZGUgd2FzIGluc2VydGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uXG4gKiBvciB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGUgb3IgdGhlIG5vZGUgYWxyZWFkeSBob2xkcyB0ZXh0LlxuICovXG5mdW5jdGlvbiAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9ubHkgcnVuIHRoaXMgY29kZSBvbiBlbXB0eSBsaXN0IGl0ZW1zXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0xpc3RJdGVtTm9kZShhbmNob3IpIHx8IGFuY2hvci5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0b3BMaXN0Tm9kZSA9ICRnZXRUb3BMaXN0Tm9kZShhbmNob3IpO1xuICBjb25zdCBwYXJlbnQgPSBhbmNob3IuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICB9XG4gIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICBsZXQgcmVwbGFjZW1lbnROb2RlO1xuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIHRvcExpc3ROb2RlLmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBncmFuZHBhcmVudC5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlbWVudE5vZGUuc2V0VGV4dFN0eWxlKHNlbGVjdGlvbi5zdHlsZSkuc2V0VGV4dEZvcm1hdChzZWxlY3Rpb24uZm9ybWF0KS5zZWxlY3QoKTtcbiAgY29uc3QgbmV4dFNpYmxpbmdzID0gYW5jaG9yLmdldE5leHRTaWJsaW5ncygpO1xuICBpZiAobmV4dFNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH1cbiAgICBuZXdMaXN0LmFwcGVuZCguLi5uZXh0U2libGluZ3MpO1xuICB9XG5cbiAgLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcbiAgJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoYW5jaG9yKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBhcHBseU1hcmtlclN0eWxlcyhkb20sIG5vZGUsIHByZXZOb2RlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhub2RlLl9fdGV4dFN0eWxlKTtcbiAgZm9yIChjb25zdCBrIGluIHN0eWxlcykge1xuICAgIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eShgLS1saXN0aXRlbS1tYXJrZXItJHtrfWAsIHN0eWxlc1trXSk7XG4gIH1cbiAgaWYgKHByZXZOb2RlKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhwcmV2Tm9kZS5fX3RleHRTdHlsZSkpIHtcbiAgICAgIGlmICghKGsgaW4gc3R5bGVzKSkge1xuICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkoYC0tbGlzdGl0ZW0tbWFya2VyLSR7a31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3RJdGVtTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gICRjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnKCdsaXN0aXRlbScsIHtcbiAgICAgICR0cmFuc2Zvcm06IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5fX2NoZWNrZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgIGlmIChwYXJlbnQuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJyAmJiBub2RlLmdldENoZWNrZWQoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHRlbmRzOiBFbGVtZW50Tm9kZSxcbiAgICAgIGltcG9ydERPTTogYnVpbGRJbXBvcnRNYXAoe1xuICAgICAgICBsaTogKCkgPT4gKHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3RJdGVtRWxlbWVudCxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih2YWx1ZSA9IDEsIGNoZWNrZWQgPSB1bmRlZmluZWQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gcHJldk5vZGUuX192YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IHByZXZOb2RlLl9fY2hlY2tlZDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgdGhpcy51cGRhdGVMaXN0SXRlbURPTShudWxsLCBlbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZUxpc3RJdGVtRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycpIHtcbiAgICAgIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgICB9XG4gICAgZG9tLnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgY29uc3QgcHJldlN0eWxlID0gcHJldk5vZGUgPyBwcmV2Tm9kZS5fX3N0eWxlIDogJyc7XG4gICAgY29uc3QgbmV4dFN0eWxlID0gdGhpcy5fX3N0eWxlO1xuICAgIGlmIChwcmV2U3R5bGUgIT09IG5leHRTdHlsZSkge1xuICAgICAgaWYgKG5leHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dFN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBhcHBseU1hcmtlclN0eWxlcyhkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgYWx3YXlzIEhUTUxMaXN0SXRlbUVsZW1lbnRcbiAgICBjb25zdCBlbGVtZW50ID0gZG9tO1xuICAgIHRoaXMudXBkYXRlTGlzdEl0ZW1ET00ocHJldk5vZGUsIGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRWYWx1ZShzZXJpYWxpemVkTm9kZS52YWx1ZSkuc2V0Q2hlY2tlZChzZXJpYWxpemVkTm9kZS5jaGVja2VkKTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnKTtcbiAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgaWYgKGZvcm1hdFR5cGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKVxuICAgIH07XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIHRoaXMuY2FuTWVyZ2VXaXRoKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2UocmVwbGFjZVdpdGhOb2RlLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5kZW50KDApO1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3QpKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVdpdGhOb2RlO1xuICAgIH1cbiAgICBpZiAobGlzdC5fX2ZpcnN0ID09PSB0aGlzLmdldEtleSgpKSB7XG4gICAgICBsaXN0Lmluc2VydEJlZm9yZShyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSBpZiAobGlzdC5fX2xhc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3BsaXQgdGhlIGxpc3RcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdC5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICBjb25zdCBub2RlVG9BcHBlbmQgPSBuZXh0U2libGluZztcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXROZXh0U2libGluZygpO1xuICAgICAgICBuZXdMaXN0LmFwcGVuZChub2RlVG9BcHBlbmQpO1xuICAgICAgfVxuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgICAgcmVwbGFjZVdpdGhOb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbmNsdWRlQ2hpbGRyZW4gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgRWxlbWVudE5vZGVzYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHJlcGxhY2VXaXRoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgaWYgKGxpc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGxpc3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGxpc3RzIGFuZCBpbnNlcnQgdGhlIG5vZGUgaW4gYmV0d2VlbiB0aGVtXG4gICAgbGlzdE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBzaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4gbmV3TGlzdE5vZGUuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdE5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBzdXBlci5yZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCk7XG4gICAgaWYgKHByZXZTaWJsaW5nICYmIG5leHRTaWJsaW5nICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldlNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBtZXJnZUxpc3RzKHByZXZTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSwgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCkudXBkYXRlRnJvbUpTT04odGhpcy5leHBvcnRKU09OKCkpLnNldENoZWNrZWQodGhpcy5nZXRDaGVja2VkKCkgPyBmYWxzZSA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGlzSW5kZW50ZWQgPSAkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpO1xuICAgIGlmIChsaXN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxpc3Qgbm9kZSBpcyBuZXN0ZWQsIHdlIGp1c3Qgd2FudCB0byByZW1vdmUgaXQsXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHVuaW5kZW50aW5nIGl0LlxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgbGlzdE5vZGVQYXJlbnQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIHRoZSBsaXN0IGl0ZW0sIHdlJ2xsIG5lZWQgdG8gbW92ZSBpdFxuICAgICAgICAvLyB0byB0aGUgcGFyYWdyYXBoXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhZ3JhcGguZ2V0S2V5KCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGtleSwgYW5jaG9yLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGZvY3VzLnNldChrZXksIGZvY3VzLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdmFsdWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldENoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgbGV0IGxpc3RUeXBlO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGxpc3RUeXBlID0gcGFyZW50LmdldExpc3RUeXBlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IEJvb2xlYW4oc2VsZi5fX2NoZWNrZWQpIDogdW5kZWZpbmVkO1xuICB9XG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRvZ2dsZUNoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICByZXR1cm4gc2VsZi5zZXRDaGVja2VkKCFzZWxmLl9fY2hlY2tlZCk7XG4gIH1cbiAgZ2V0SW5kZW50KCkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIHdlIGFyZSBsaWtlbHkgc2VyaWFsaXppbmdcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgIXRoaXMuaXNBdHRhY2hlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2luZGVudDtcbiAgICB9XG4gICAgLy8gTGlzdEl0ZW1Ob2RlIHNob3VsZCBhbHdheXMgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5cbiAgICBsZXQgbGlzdE5vZGVQYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGxldCBpbmRlbnRMZXZlbCA9IDA7XG4gICAgd2hpbGUgKCRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCkpIHtcbiAgICAgIGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGVQYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGluZGVudExldmVsKys7XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRMZXZlbDtcbiAgfVxuICBzZXRJbmRlbnQoaW5kZW50KSB7XG4gICAgaWYgKCEodHlwZW9mIGluZGVudCA9PT0gJ251bWJlcicpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEludmFsaWQgaW5kZW50IHZhbHVlLmApO1xuICAgIH1cbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGluZGVudCk7XG4gICAgaWYgKCEoaW5kZW50ID49IDApKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEluZGVudCB2YWx1ZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZS5gKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZW50ICE9PSBpbmRlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZW50IDwgaW5kZW50KSB7XG4gICAgICAgICRoYW5kbGVJbmRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRoYW5kbGVPdXRkZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuUmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50KTtcbiAgfVxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgfHwgJGlzUGFyYWdyYXBoTm9kZShub2RlKTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH1cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgfVxuICBjYW5NZXJnZVdoZW5FbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGNvbnN0IGxpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lID8gbGlzdFRoZW1lLmxpc3RpdGVtIDogdW5kZWZpbmVkO1xuICBsZXQgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWU7XG4gIGlmIChsaXN0VGhlbWUgJiYgbGlzdFRoZW1lLm5lc3RlZCkge1xuICAgIG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lLm5lc3RlZC5saXN0aXRlbTtcbiAgfVxuICBpZiAobGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdEl0ZW1DbGFzc05hbWUpKTtcbiAgfVxuICBpZiAobGlzdFRoZW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgY29uc3QgaXNDaGVja0xpc3QgPSAkaXNMaXN0Tm9kZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLmdldExpc3RUeXBlKCkgPT09ICdjaGVjayc7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5vZGUuZ2V0Q2hlY2tlZCgpO1xuICAgIGlmICghaXNDaGVja0xpc3QgfHwgY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCAhY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrTGlzdCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tlZCA/IGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQgOiBsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuICBpZiAobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUpO1xuICAgIGlmIChub2RlLmdldENoaWxkcmVuKCkuc29tZShjaGlsZCA9PiAkaXNMaXN0Tm9kZShjaGlsZCkpKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCBsaXN0SXRlbU5vZGUsIHByZXZMaXN0SXRlbU5vZGUsIGxpc3ROb2RlKSB7XG4gIC8vIE9ubHkgYWRkIGF0dHJpYnV0ZXMgZm9yIGxlYWYgbGlzdCBpdGVtc1xuICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICBpZiAoIXByZXZMaXN0SXRlbU5vZGUgfHwgbGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCAhPT0gcHJldkxpc3RJdGVtTm9kZS5fX2NoZWNrZWQpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGxpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNHaXRIdWJDaGVja0xpc3QgPSBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygndGFzay1saXN0LWl0ZW0nKTtcbiAgaWYgKGlzR2l0SHViQ2hlY2tMaXN0KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gJGNvbnZlcnRDaGVja2JveElucHV0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYXJpYUNoZWNrZWRBdHRyID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICBjb25zdCBjaGVja2VkID0gYXJpYUNoZWNrZWRBdHRyID09PSAndHJ1ZScgPyB0cnVlIDogYXJpYUNoZWNrZWRBdHRyID09PSAnZmFsc2UnID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRDaGVja2JveElucHV0KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNDaGVja2JveElucHV0ID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94JztcbiAgaWYgKCFpc0NoZWNrYm94SW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgY2hlY2tlZCA9IGRvbU5vZGUuaGFzQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBJdGVtIG5vZGUsIHBhc3NpbmcgdHJ1ZS9mYWxzZSB3aWxsIGNvbnZlcnQgaXQgdG8gYSBjaGVja2JveCBpbnB1dC5cbiAqIEBwYXJhbSBjaGVja2VkIC0gSXMgdGhlIExpc3QgSXRlbSBhIGNoZWNrYm94IGFuZCwgaWYgc28sIGlzIGl0IGNoZWNrZWQ/IHVuZGVmaW5lZC9udWxsOiBub3QgYSBjaGVja2JveCwgdHJ1ZS9mYWxzZSBpcyBhIGNoZWNrYm94IGFuZCBjaGVja2VkL3VuY2hlY2tlZCwgcmVzcGVjdGl2ZWx5LlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0IEl0ZW0uXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0SXRlbU5vZGUodW5kZWZpbmVkLCBjaGVja2VkKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gICRjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnKCdsaXN0Jywge1xuICAgICAgJHRyYW5zZm9ybTogbm9kZSA9PiB7XG4gICAgICAgIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShub2RlKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIGV4dGVuZHM6IEVsZW1lbnROb2RlLFxuICAgICAgaW1wb3J0RE9NOiBidWlsZEltcG9ydE1hcCh7XG4gICAgICAgIG9sOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIHVsOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IobGlzdFR5cGUgPSAnbnVtYmVyJywgc3RhcnQgPSAxLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIGNvbnN0IF9saXN0VHlwZSA9IFRBR19UT19MSVNUX1RZUEVbbGlzdFR5cGVdIHx8IGxpc3RUeXBlO1xuICAgIHRoaXMuX19saXN0VHlwZSA9IF9saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gX2xpc3RUeXBlID09PSAnbnVtYmVyJyA/ICdvbCcgOiAndWwnO1xuICAgIHRoaXMuX19zdGFydCA9IHN0YXJ0O1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX19saXN0VHlwZSA9IHByZXZOb2RlLl9fbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IHByZXZOb2RlLl9fdGFnO1xuICAgIHRoaXMuX19zdGFydCA9IHByZXZOb2RlLl9fc3RhcnQ7XG4gIH1cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGFnO1xuICB9XG4gIHNldExpc3RUeXBlKHR5cGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX2xpc3RUeXBlID0gdHlwZTtcbiAgICB3cml0YWJsZS5fX3RhZyA9IHR5cGUgPT09ICdudW1iZXInID8gJ29sJyA6ICd1bCc7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldExpc3RUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fbGlzdFR5cGU7XG4gIH1cbiAgZ2V0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19zdGFydDtcbiAgfVxuICBzZXRTdGFydChzdGFydCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3N0YXJ0ID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgX2VkaXRvcikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEludGVybmFsIGZpZWxkLlxuICAgIGRvbS5fX2xleGljYWxMaXN0VHlwZSA9IHRoaXMuX19saXN0VHlwZTtcbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fdGFnICE9PSB0aGlzLl9fdGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0TGlzdFR5cGUoc2VyaWFsaXplZE5vZGUubGlzdFR5cGUpLnNldFN0YXJ0KHNlcmlhbGl6ZWROb2RlLnN0YXJ0KTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnLCBlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbExpc3RUeXBlJywgJ2NoZWNrJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsaXN0VHlwZTogdGhpcy5nZXRMaXN0VHlwZSgpLFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U3RhcnQoKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKVxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgbGV0IGxpc3RJdGVtTm9kZXNUb0luc2VydCA9IG5vZGVzVG9JbnNlcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNUb0luc2VydFtpXTtcbiAgICAgIGlmICghJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGVzVG9JbnNlcnQgPT09IG5vZGVzVG9JbnNlcnQpIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGVzVG9JbnNlcnQgPSBbLi4ubm9kZXNUb0luc2VydF07XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0W2ldID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpLmFwcGVuZCgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhKCRpc0xpc3ROb2RlKG5vZGUpIHx8IG5vZGUuaXNJbmxpbmUoKSkgPyAkY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKSA6IG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0KTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShjaGlsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGlmIChsaXN0VGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxpc3RMZXZlbHNDbGFzc05hbWVzID0gbGlzdFRoZW1lW2Ake25vZGUuX190YWd9RGVwdGhgXSB8fCBbXTtcbiAgICBjb25zdCBsaXN0RGVwdGggPSAkZ2V0TGlzdERlcHRoKG5vZGUpIC0gMTtcbiAgICBjb25zdCBub3JtYWxpemVkTGlzdERlcHRoID0gbGlzdERlcHRoICUgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoO1xuICAgIGNvbnN0IGxpc3RMZXZlbENsYXNzTmFtZSA9IGxpc3RMZXZlbHNDbGFzc05hbWVzW25vcm1hbGl6ZWRMaXN0RGVwdGhdO1xuICAgIGNvbnN0IGxpc3RDbGFzc05hbWUgPSBsaXN0VGhlbWVbbm9kZS5fX3RhZ107XG4gICAgbGV0IG5lc3RlZExpc3RDbGFzc05hbWU7XG4gICAgY29uc3QgbmVzdGVkTGlzdFRoZW1lID0gbGlzdFRoZW1lLm5lc3RlZDtcbiAgICBjb25zdCBjaGVja2xpc3RDbGFzc05hbWUgPSBsaXN0VGhlbWUuY2hlY2tsaXN0O1xuICAgIGlmIChuZXN0ZWRMaXN0VGhlbWUgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRMaXN0VGhlbWUubGlzdCkge1xuICAgICAgbmVzdGVkTGlzdENsYXNzTmFtZSA9IG5lc3RlZExpc3RUaGVtZS5saXN0O1xuICAgIH1cbiAgICBpZiAobGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChsaXN0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKGNoZWNrbGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuX19saXN0VHlwZSA9PT0gJ2NoZWNrJykge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tsaXN0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKGxpc3RMZXZlbENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5ub3JtYWxpemVDbGFzc05hbWVzKGxpc3RMZXZlbENsYXNzTmFtZSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gbm9ybWFsaXplZExpc3REZXB0aCkge1xuICAgICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKG5vZGUuX190YWcgKyBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVzdGVkTGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbUNsYXNzZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKG5lc3RlZExpc3RDbGFzc05hbWUpO1xuICAgICAgaWYgKGxpc3REZXB0aCA+IDEpIHtcbiAgICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGUgY2hpbGRyZW4gb2YgYSBMaXN0Tm9kZSBhZnRlciB0aGUgY29udmVyc2lvbiBmcm9tIEhUTUwsXG4gKiBlbnN1cmluZyB0aGF0IHRoZXkgYXJlIGFsbCBMaXN0SXRlbU5vZGVzIGFuZCBjb250YWluIGVpdGhlciBhIHNpbmdsZSBuZXN0ZWQgTGlzdE5vZGVcbiAqIG9yIHNvbWUgb3RoZXIgaW5saW5lIGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uICRub3JtYWxpemVDaGlsZHJlbihub2Rlcykge1xuICBjb25zdCBub3JtYWxpemVkTGlzdEl0ZW1zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2goJHdyYXBJbkxpc3RJdGVtKGNoaWxkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKCR3cmFwSW5MaXN0SXRlbShub2RlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkTGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gaXNEb21DaGVja2xpc3QoZG9tTm9kZSkge1xuICBpZiAoZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbGxpc3R0eXBlJykgPT09ICdjaGVjaycgfHxcbiAgLy8gaXMgZ2l0aHViIGNoZWNrbGlzdFxuICBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygnY29udGFpbnMtdGFzay1saXN0JykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBpZiBjaGlsZHJlbiBhcmUgY2hlY2tsaXN0IGl0ZW1zLCB0aGUgbm9kZSBpcyBhIGNoZWNrbGlzdCB1bC4gQXBwbGljYWJsZSBmb3IgZ29vZ2xlZG9jIGNoZWNrbGlzdCBwYXN0aW5nLlxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGRvbU5vZGUuY2hpbGROb2Rlcykge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRMaXN0Tm9kZShkb21Ob2RlKSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChub2RlTmFtZSA9PT0gJ29sJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdGFydCA9IGRvbU5vZGUuc3RhcnQ7XG4gICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnbnVtYmVyJywgc3RhcnQpO1xuICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAndWwnKSB7XG4gICAgaWYgKGlzRG9tQ2hlY2tsaXN0KGRvbU5vZGUpKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdjaGVjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogJG5vcm1hbGl6ZUNoaWxkcmVuLFxuICAgIG5vZGVcbiAgfTtcbn1cbmNvbnN0IFRBR19UT19MSVNUX1RZUEUgPSB7XG4gIG9sOiAnbnVtYmVyJyxcbiAgdWw6ICdidWxsZXQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMaXN0Tm9kZSBvZiBsaXN0VHlwZS5cbiAqIEBwYXJhbSBsaXN0VHlwZSAtIFRoZSB0eXBlIG9mIGxpc3QgdG8gYmUgY3JlYXRlZC4gQ2FuIGJlICdudW1iZXInLCAnYnVsbGV0Jywgb3IgJ2NoZWNrJy5cbiAqIEBwYXJhbSBzdGFydCAtIFdoZXJlIGFuIG9yZGVyZWQgbGlzdCBzdGFydHMgaXRzIGNvdW50LCBzdGFydCA9IDEgaWYgbGVmdCB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyBUaGUgbmV3IExpc3ROb2RlXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSA9ICdudW1iZXInLCBzdGFydCA9IDEpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3ROb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0xpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCcpO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGVja0xpc3QoZWRpdG9yKSB7XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdjaGVjaycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIHJldHVybiBoYW5kbGVBcnJvd1VwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGZhbHNlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgdHJ1ZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpO1xuICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgICBpZiAoYWN0aXZlSXRlbSAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhY3RpdmVJdGVtKTtcbiAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFuY2hvclxuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0VsZW1lbnQgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnO1xuICAgICAgICBpZiAoaXNFbGVtZW50IHx8IGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGVsZW1lbnROb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJyAmJiAoaXNFbGVtZW50IHx8IGVsZW1lbnROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpID09PSBhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlbGVtZW50Tm9kZS5fX2tleSk7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyKChyb290RWxlbWVudCwgcHJldkVsZW1lbnQpID0+IHtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgfVxuICAgIGlmIChwcmV2RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcHJldkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICBwcmV2RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNIVE1MRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWdub3JlIGNsaWNrcyBvbiBMSSB0aGF0IGhhdmUgbmVzdGVkIGxpc3RzXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZmlyc3RDaGlsZCkgJiYgKGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ1VMJyB8fCBmaXJzdENoaWxkLnRhZ05hbWUgPT09ICdPTCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGlmICghcGFyZW50Tm9kZSB8fCBwYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlICE9PSAnY2hlY2snKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHpvb20gPSBjYWxjdWxhdGVab29tTGV2ZWwodGFyZ2V0KTtcbiAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNsaWVudFggLyB6b29tO1xuXG4gIC8vIFVzZSBnZXRDb21wdXRlZFN0eWxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIDBweCB3aWR0aFxuICBjb25zdCBiZWZvcmVTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzo6YmVmb3JlJykgOiB7XG4gICAgd2lkdGg6ICcwcHgnXG4gIH07XG4gIGNvbnN0IGJlZm9yZVdpZHRoSW5QaXhlbHMgPSBwYXJzZUZsb2F0KGJlZm9yZVN0eWxlcy53aWR0aCk7XG5cbiAgLy8gTWFrZSBjbGljayBhcmVhIHNsaWdodGx5IGxhcmdlciBmb3IgdG91Y2ggZGV2aWNlcyB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHlcbiAgY29uc3QgaXNUb3VjaEV2ZW50ID0gZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gIGNvbnN0IGNsaWNrQXJlYVBhZGRpbmcgPSBpc1RvdWNoRXZlbnQgPyAzMiA6IDA7IC8vIEFkZCAzMnB4IHBhZGRpbmcgZm9yIHRvdWNoIGV2ZW50c1xuXG4gIGlmICh0YXJnZXQuZGlyID09PSAncnRsJyA/IGNsaWVudFggPCByZWN0LnJpZ2h0ICsgY2xpY2tBcmVhUGFkZGluZyAmJiBjbGllbnRYID4gcmVjdC5yaWdodCAtIGJlZm9yZVdpZHRoSW5QaXhlbHMgLSBjbGlja0FyZWFQYWRkaW5nIDogY2xpZW50WCA+IHJlY3QubGVmdCAtIGNsaWNrQXJlYVBhZGRpbmcgJiYgY2xpZW50WCA8IHJlY3QubGVmdCArIGJlZm9yZVdpZHRoSW5QaXhlbHMgKyBjbGlja0FyZWFQYWRkaW5nKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpKSB7XG4gICAgICBjb25zdCBkb21Ob2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgZWRpdG9yID0gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGRvbU5vZGUpO1xuICAgICAgaWYgKGVkaXRvciAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbU5vZGUpO1xuICAgICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIG5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKGV2ZW50KSB7XG4gIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCAoKSA9PiB7XG4gICAgLy8gUHJldmVudHMgY2FyZXQgbW92aW5nIHdoZW4gY2xpY2tpbmcgb24gY2hlY2sgbWFya1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGFjdGl2ZUVsZW1lbnQpICYmIGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0xJJyAmJiBhY3RpdmVFbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCAmJlxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5fX2xleGljYWxMaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IGFjdGl2ZUVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuICBsZXQgcGFyZW50ID0gbm9kZTtcblxuICAvLyBHb2luZyB1cCBpbiBhIHRyZWUgdG8gZ2V0IG5vbi1udWxsIHNpYmxpbmdcbiAgd2hpbGUgKHNpYmxpbmcgPT0gbnVsbCAmJiAkaXNMaXN0SXRlbU5vZGUocGFyZW50KSkge1xuICAgIC8vIEdldCBsaSAtPiBwYXJlbnQgdWwvb2wgLT4gcGFyZW50IGxpXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKS5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdvaW5nIGRvd24gaW4gYSB0cmVlIHRvIGdldCBmaXJzdCBub24tbmVzdGVkIGxpc3QgaXRlbVxuICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKHNpYmxpbmcpKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0Q2hpbGQoKSA6IHNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgIH1cbiAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBmaXJzdENoaWxkLmdldExhc3RDaGlsZCgpIDogZmlyc3RDaGlsZC5nZXRGaXJzdENoaWxkKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJvd1VwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGJhY2t3YXJkKSB7XG4gIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYWN0aXZlSXRlbSk7XG4gICAgICBpZiAoISRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dExpc3RJdGVtID0gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKGxpc3RJdGVtLCBiYWNrd2FyZCk7XG4gICAgICBpZiAobmV4dExpc3RJdGVtICE9IG51bGwpIHtcbiAgICAgICAgbmV4dExpc3RJdGVtLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobmV4dExpc3RJdGVtLl9fa2V5KTtcbiAgICAgICAgaWYgKGRvbSAhPSBudWxsKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvbS5mb2N1cygpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdVUERBVEVfTElTVF9TVEFSVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfTElTVF9DT01NQU5EJyk7XG5mdW5jdGlvbiByZWdpc3Rlckxpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdudW1iZXInKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3ROb2RlS2V5LFxuICAgICAgbmV3U3RhcnRcbiAgICB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCBsaXN0Tm9kZSA9ICRnZXROb2RlQnlLZXkobGlzdE5vZGVLZXkpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgbGlzdE5vZGUuc2V0U3RhcnQobmV3U3RhcnQpO1xuICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3ROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdidWxsZXQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFJFTU9WRV9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAkcmVtb3ZlTGlzdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCgpLCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oTGlzdEl0ZW1Ob2RlLCBub2RlID0+IHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGZpcnN0Q2hpbGQuZ2V0U3R5bGUoKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZmlyc3RDaGlsZC5nZXRGb3JtYXQoKTtcbiAgICAgICAgaWYgKG5vZGUuZ2V0VGV4dFN0eWxlKCkgIT09IHN0eWxlKSB7XG4gICAgICAgICAgbm9kZS5zZXRUZXh0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmdldFRleHRGb3JtYXQoKSAhPT0gZm9ybWF0KSB7XG4gICAgICAgICAgbm9kZS5zZXRUZXh0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBlbXB0eSwgY2hlY2sgdGhlIHNlbGVjdGlvblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgKHNlbGVjdGlvbi5zdHlsZSAhPT0gbm9kZS5nZXRUZXh0U3R5bGUoKSB8fCBzZWxlY3Rpb24uZm9ybWF0ICE9PSBub2RlLmdldFRleHRGb3JtYXQoKSkgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbm9kZS5pcyhzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkpIHtcbiAgICAgICAgbm9kZS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsIG5vZGUgPT4ge1xuICAgIGNvbnN0IGxpc3RJdGVtUGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbVBhcmVudE5vZGUpICYmIG5vZGUuaXMobGlzdEl0ZW1QYXJlbnROb2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5nZXRTdHlsZSgpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gbm9kZS5nZXRGb3JtYXQoKTtcbiAgICAgIGlmIChzdHlsZSAhPT0gbGlzdEl0ZW1QYXJlbnROb2RlLmdldFRleHRTdHlsZSgpIHx8IGZvcm1hdCAhPT0gbGlzdEl0ZW1QYXJlbnROb2RlLmdldFRleHRGb3JtYXQoKSkge1xuICAgICAgICBsaXN0SXRlbVBhcmVudE5vZGUuc2V0VGV4dFN0eWxlKHN0eWxlKS5zZXRUZXh0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdFN0cmljdEluZGVudFRyYW5zZm9ybShlZGl0b3IpIHtcbiAgY29uc3QgJGZvcm1hdExpc3RJbmRlbnRTdHJpY3QgPSBsaXN0SXRlbU5vZGUgPT4ge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSB8fCAhJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChsaXN0SXRlbU5vZGUsIG5vZGUgPT4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICRpc0xpc3ROb2RlKG5vZGUuZ2V0UGFyZW50KCkpICYmICRpc0xpc3RJdGVtTm9kZShub2RlLmdldFByZXZpb3VzU2libGluZygpKSk7XG4gICAgaWYgKHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlID09PSBudWxsICYmIGxpc3RJdGVtTm9kZS5nZXRJbmRlbnQoKSA+IDApIHtcbiAgICAgIGxpc3RJdGVtTm9kZS5zZXRJbmRlbnQoMCk7XG4gICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoc3RhcnRpbmdMaXN0SXRlbU5vZGUpKSB7XG4gICAgICBjb25zdCBwcmV2TGlzdEl0ZW1Ob2RlID0gc3RhcnRpbmdMaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHByZXZMaXN0SXRlbU5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGVuZExpc3RJdGVtTm9kZSA9ICRmaW5kQ2hpbGRyZW5FbmRMaXN0SXRlbU5vZGUocHJldkxpc3RJdGVtTm9kZSk7XG4gICAgICAgIGNvbnN0IGVuZExpc3ROb2RlID0gZW5kTGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZW5kTGlzdE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldkRlcHRoID0gJGdldExpc3REZXB0aChlbmRMaXN0Tm9kZSk7XG4gICAgICAgICAgY29uc3QgZGVwdGggPSAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKTtcbiAgICAgICAgICBpZiAocHJldkRlcHRoICsgMSA8IGRlcHRoKSB7XG4gICAgICAgICAgICBsaXN0SXRlbU5vZGUuc2V0SW5kZW50KHByZXZEZXB0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCAkcHJvY2Vzc0xpc3RXaXRoU3RyaWN0SW5kZW50ID0gbGlzdE5vZGUgPT4ge1xuICAgIGNvbnN0IHF1ZXVlID0gW2xpc3ROb2RlXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoISRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmdldENoaWxkcmVuKCkpIHtcbiAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAkZm9ybWF0TGlzdEluZGVudFN0cmljdChjaGlsZCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShMaXN0Tm9kZSwgJHByb2Nlc3NMaXN0V2l0aFN0cmljdEluZGVudCk7XG59XG5mdW5jdGlvbiAkZmluZENoaWxkcmVuRW5kTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkge1xuICBsZXQgY3VycmVudCA9IGxpc3RJdGVtTm9kZTtcbiAgbGV0IGZpcnN0Q2hpbGQgPSBjdXJyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgd2hpbGUgKCRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gZmlyc3RDaGlsZC5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgIGN1cnJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICBmaXJzdENoaWxkID0gY3VycmVudC5nZXRGaXJzdENoaWxkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rICRpbnNlcnRMaXN0fSBmcm9tIGFuIHVwZGF0ZSBvciBjb21tYW5kIGxpc3RlbmVyLlxuICpcbiAqIEluc2VydHMgYSBuZXcgTGlzdE5vZGUuIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGUgYW5kIGlzIGEgY2hpbGQgb2ZcbiAqIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIHJlcGxhY2UgdGhlIExpc3RJdGVtTm9kZSB3aXRoIGEgTGlzdE5vZGUgYW5kIHRoZSBvbGQgTGlzdEl0ZW1Ob2RlLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgcmVwbGFjZSBpdHMgcGFyZW50IHdpdGggYSBuZXcgTGlzdE5vZGUgYW5kIHJlLWluc2VydCB0aGUgTGlzdEl0ZW1Ob2RlIGFuZCBhbnkgcHJldmlvdXMgY2hpbGRyZW4uXG4gKiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgbm90IGFuIGVtcHR5IExpc3RJdGVtTm9kZSwgaXQgd2lsbCBhZGQgYSBuZXcgTGlzdE5vZGUgb3IgbWVyZ2UgYW4gZXhpc3RpbmcgTGlzdE5vZGUsXG4gKiB1bmxlc3MgdGhlIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgTGlzdE5vZGUgdXAgdGhlIGJyYW5jaCBhbmQgcmVwbGFjZSBpdCB3aXRoXG4gKiBhIG5ldyBMaXN0Tm9kZSwgb3IgY3JlYXRlIGEgbmV3IExpc3ROb2RlIGF0IHRoZSBuZWFyZXN0IHJvb3Qvc2hhZG93IHJvb3QuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCwgXCJudW1iZXJcIiB8IFwiYnVsbGV0XCIgfCBcImNoZWNrXCIuXG4gKi9cbmZ1bmN0aW9uIGluc2VydExpc3QoZWRpdG9yLCBsaXN0VHlwZSkge1xuICBlZGl0b3IudXBkYXRlKCgpID0+ICRpbnNlcnRMaXN0KGxpc3RUeXBlKSk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayAkcmVtb3ZlTGlzdH0gZnJvbSBhbiB1cGRhdGUgb3IgY29tbWFuZCBsaXN0ZW5lci5cbiAqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZW1vdmVzIGl0LiBJZiBzZWxlY3Rpb24gaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlXG4gKiBpdCB3aWxsIHJlbW92ZSB0aGUgd2hvbGUgbGlzdCwgaW5jbHVkaW5nIHRoZSBMaXN0SXRlbU5vZGUuIEZvciBlYWNoIExpc3RJdGVtTm9kZSBpbiB0aGUgTGlzdE5vZGUsXG4gKiByZW1vdmVMaXN0IHdpbGwgYWxzbyBnZW5lcmF0ZSBuZXcgUGFyYWdyYXBoTm9kZXMgaW4gdGhlIHJlbW92ZWQgTGlzdE5vZGUncyBwbGFjZS4gQW55IGNoaWxkIG5vZGVcbiAqIGluc2lkZSBhIExpc3RJdGVtTm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBuZXcgUGFyYWdyYXBoTm9kZXMuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0KGVkaXRvcikge1xuICBlZGl0b3IudXBkYXRlKCgpID0+ICRyZW1vdmVMaXN0KCkpO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlTGlzdEl0ZW1Ob2RlLCAkY3JlYXRlTGlzdE5vZGUsICRnZXRMaXN0RGVwdGgsICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoLCAkaW5zZXJ0TGlzdCwgJGlzTGlzdEl0ZW1Ob2RlLCAkaXNMaXN0Tm9kZSwgJHJlbW92ZUxpc3QsIElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQsIElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQsIExpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIFJFTU9WRV9MSVNUX0NPTU1BTkQsIFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQsIGluc2VydExpc3QsIHJlZ2lzdGVyQ2hlY2tMaXN0LCByZWdpc3Rlckxpc3QsIHJlZ2lzdGVyTGlzdFN0cmljdEluZGVudFRyYW5zZm9ybSwgcmVtb3ZlTGlzdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createListItemNode: () => (/* binding */ $createListItemNode),\n/* harmony export */   $createListNode: () => (/* binding */ $createListNode),\n/* harmony export */   $getListDepth: () => (/* binding */ $getListDepth),\n/* harmony export */   $handleListInsertParagraph: () => (/* binding */ $handleListInsertParagraph),\n/* harmony export */   $insertList: () => (/* binding */ $insertList),\n/* harmony export */   $isListItemNode: () => (/* binding */ $isListItemNode),\n/* harmony export */   $isListNode: () => (/* binding */ $isListNode),\n/* harmony export */   $removeList: () => (/* binding */ $removeList),\n/* harmony export */   INSERT_CHECK_LIST_COMMAND: () => (/* binding */ INSERT_CHECK_LIST_COMMAND),\n/* harmony export */   INSERT_ORDERED_LIST_COMMAND: () => (/* binding */ INSERT_ORDERED_LIST_COMMAND),\n/* harmony export */   INSERT_UNORDERED_LIST_COMMAND: () => (/* binding */ INSERT_UNORDERED_LIST_COMMAND),\n/* harmony export */   ListItemNode: () => (/* binding */ ListItemNode),\n/* harmony export */   ListNode: () => (/* binding */ ListNode),\n/* harmony export */   REMOVE_LIST_COMMAND: () => (/* binding */ REMOVE_LIST_COMMAND),\n/* harmony export */   UPDATE_LIST_START_COMMAND: () => (/* binding */ UPDATE_LIST_START_COMMAND),\n/* harmony export */   insertList: () => (/* binding */ insertList),\n/* harmony export */   registerCheckList: () => (/* binding */ registerCheckList),\n/* harmony export */   registerList: () => (/* binding */ registerList),\n/* harmony export */   registerListStrictIndentTransform: () => (/* binding */ registerListStrictIndentTransform),\n/* harmony export */   removeList: () => (/* binding */ removeList)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_selection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/selection */ \"(ssr)/./node_modules/.pnpm/@lexical+selection@0.35.0/node_modules/@lexical/selection/LexicalSelection.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n      {\n        formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n    return depth;\n  }\n  return depth;\n}\n\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n  if (!$isListNode(list)) {\n    {\n      formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n  let parent = list;\n  while (parent !== null) {\n    parent = parent.getParent();\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n  return list;\n}\n\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n  return listItemNodes;\n}\n\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n    if (parent == null || !($isListItemNode(parent) || $isListNode(parent))) {\n      break;\n    }\n    emptyListPtr = parent;\n  }\n  emptyListPtr.remove();\n}\n\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\nfunction $wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction $insertList(listType) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection !== null) {\n    let nodes = selection.getNodes();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const anchorAndFocus = selection.getStartEndPoints();\n      if (!(anchorAndFocus !== null)) {\n        formatDevErrorMessage(`insertList: anchor should be defined`);\n      }\n      const [anchor] = anchorAndFocus;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNode)) {\n        const firstChild = anchorNode.getFirstChild();\n        if (firstChild) {\n          nodes = firstChild.selectStart().getNodes();\n        } else {\n          const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n          anchorNode.append(paragraph);\n          nodes = paragraph.select().getNodes();\n        }\n      } else if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n        return;\n      }\n    }\n    const handled = new Set();\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && node.isEmpty() && !$isListItemNode(node) && !handled.has(node.getKey())) {\n        $createListOrMerge(node, listType);\n        continue;\n      }\n      let parent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node) ? node.getParent() : $isListItemNode(node) && node.isEmpty() ? node : null;\n      while (parent != null) {\n        const parentKey = parent.getKey();\n        if ($isListNode(parent)) {\n          if (!handled.has(parentKey)) {\n            const newListNode = $createListNode(listType);\n            append(newListNode, parent.getChildren());\n            parent.replace(newListNode);\n            handled.add(parentKey);\n          }\n          break;\n        } else {\n          const nextParent = parent.getParent();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(nextParent) && !handled.has(parentKey)) {\n            handled.add(parentKey);\n            $createListOrMerge(parent, listType);\n            break;\n          }\n          parent = nextParent;\n        }\n      }\n    }\n  }\n}\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\nfunction $createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  append(listItem, node.getChildren());\n  let targetList;\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    // if the same type of list is on both sides, merge them.\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n    targetList = previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    targetList = nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    targetList = list;\n  }\n  // listItem needs to be attached to root prior to setting indent\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  node.remove();\n  return targetList;\n}\n\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n  const toMerge = list2.getChildren();\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n  }\n  list2.remove();\n}\n\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n */\nfunction $removeList() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    const listNodes = new Set();\n    const nodes = selection.getNodes();\n    const anchorNode = selection.anchor.getNode();\n    if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n      listNodes.add($getTopListNode(anchorNode));\n    } else {\n      for (let i = 0; i < nodes.length; i++) {\n        const node = nodes[i];\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLeafNode)(node)) {\n          const listItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$getNearestNodeOfType)(node, ListItemNode);\n          if (listItemNode != null) {\n            listNodes.add($getTopListNode(listItemNode));\n          }\n        }\n      }\n    }\n    for (const listNode of listNodes) {\n      let insertionPoint = listNode;\n      const listItems = $getAllListItems(listNode);\n      for (const listItemNode of listItems) {\n        const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().setTextStyle(selection.style).setTextFormat(selection.format);\n        append(paragraph, listItemNode.getChildren());\n        insertionPoint.insertAfter(paragraph);\n        insertionPoint = paragraph;\n\n        // When the anchor and focus fall on the textNode\n        // we don't have to change the selection because the textNode will be appended to\n        // the newly generated paragraph.\n        // When selection is in empty nested list item, selection is actually on the listItemNode.\n        // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n        // we should manually set the selection's focus and anchor to the newly generated paragraph.\n        if (listItemNode.__key === selection.anchor.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        if (listItemNode.__key === selection.focus.key) {\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(paragraph, 'next')));\n        }\n        listItemNode.remove();\n      }\n      listNode.remove();\n    }\n  }\n}\n\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. Also ensures that checked is undefined if the\n * parent does not have a list type of 'check'.\n * @param list - The list whose children are updated.\n */\nfunction updateChildrenListItemValue(list) {\n  const isNotChecklist = list.getListType() !== 'check';\n  let value = list.getStart();\n  for (const child of list.getChildren()) {\n    if ($isListItemNode(child)) {\n      if (child.getValue() !== value) {\n        child.setValue(value);\n      }\n      if (isNotChecklist && child.getLatest().__checked != null) {\n        child.setChecked(undefined);\n      }\n      if (!$isListNode(child.getFirstChild())) {\n        value++;\n      }\n    }\n  }\n}\n\n/**\n * Merge the next sibling list if same type.\n * <ul> will merge with <ul>, but NOT <ul> with <ol>.\n * @param list - The list whose next sibling should be potentially merged\n */\nfunction mergeNextSiblingListIfSameType(list) {\n  const nextSibling = list.getNextSibling();\n  if ($isListNode(nextSibling) && list.getListType() === nextSibling.getListType()) {\n    mergeLists(list, nextSibling);\n  }\n}\n\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n  const parent = listItemNode.getParent();\n\n  // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling();\n  // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode().setTextFormat(listItemNode.getTextFormat()).setTextStyle(listItemNode.getTextStyle());\n      const newList = $createListNode(parent.getListType()).setTextFormat(parent.getTextFormat()).setTextStyle(parent.getTextStyle());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n    }\n  }\n}\n\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined;\n  // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n      // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings());\n      // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem);\n      // replace the grandparent list item (now between the siblings) with the outdented list item.\n      grandparentListItem.replace(listItemNode);\n    }\n  }\n}\n\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted successfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\nfunction $handleListInsertParagraph() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed()) {\n    return false;\n  }\n  // Only run this code on empty list items\n  const anchor = selection.anchor.getNode();\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n  if (!$isListNode(parent)) {\n    formatDevErrorMessage(`A ListItemNode must have a ListNode for a parent.`);\n  }\n  const grandparent = parent.getParent();\n  let replacementNode;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(grandparent)) {\n    replacementNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n  replacementNode.setTextStyle(selection.style).setTextFormat(selection.format).select();\n  const nextSiblings = anchor.getNextSiblings();\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n    if ($isListItemNode(replacementNode)) {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    } else {\n      replacementNode.insertAfter(newList);\n    }\n    newList.append(...nextSiblings);\n  }\n\n  // Don't leave hanging nested empty lists\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction normalizeClassNames(...classNames) {\n  const rval = [];\n  for (const className of classNames) {\n    if (className && typeof className === 'string') {\n      for (const [s] of className.matchAll(/\\S+/g)) {\n        rval.push(s);\n      }\n    }\n  }\n  return rval;\n}\n\nfunction applyMarkerStyles(dom, node, prevNode) {\n  const styles = (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(node.__textStyle);\n  for (const k in styles) {\n    dom.style.setProperty(`--listitem-marker-${k}`, styles[k]);\n  }\n  if (prevNode) {\n    for (const k in (0,_lexical_selection__WEBPACK_IMPORTED_MODULE_2__.getStyleObjectFromCSS)(prevNode.__textStyle)) {\n      if (!(k in styles)) {\n        dom.style.removeProperty(`--listitem-marker-${k}`);\n      }\n    }\n  }\n}\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('listitem', {\n      $transform: node => {\n        if (node.__checked == null) {\n          return;\n        }\n        const parent = node.getParent();\n        if ($isListNode(parent)) {\n          if (parent.getListType() !== 'check' && node.getChecked() != null) {\n            node.setChecked(undefined);\n          }\n        }\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        li: () => ({\n          conversion: $convertListItemElement,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(value = 1, checked = undefined, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__value = prevNode.__value;\n    this.__checked = prevNode.__checked;\n  }\n  createDOM(config) {\n    const element = document.createElement('li');\n    this.updateListItemDOM(null, element, config);\n    return element;\n  }\n  updateListItemDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    }\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    const prevStyle = prevNode ? prevNode.__style : '';\n    const nextStyle = this.__style;\n    if (prevStyle !== nextStyle) {\n      if (nextStyle === '') {\n        dom.removeAttribute('style');\n      } else {\n        dom.style.cssText = nextStyle;\n      }\n    }\n    applyMarkerStyles(dom, this, prevNode);\n  }\n  updateDOM(prevNode, dom, config) {\n    // @ts-expect-error - this is always HTMLListItemElement\n    const element = dom;\n    this.updateListItemDOM(prevNode, element, config);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setValue(serializedNode.value).setChecked(serializedNode.checked);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config);\n    const formatType = this.getFormatType();\n    if (formatType) {\n      element.style.textAlign = formatType;\n    }\n    const direction = this.getDirection();\n    if (direction) {\n      element.dir = direction;\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      checked: this.getChecked(),\n      value: this.getValue()\n    };\n  }\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n    return this;\n  }\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) {\n      return replaceWithNode;\n    }\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n    if (includeChildren) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(replaceWithNode)) {\n        formatDevErrorMessage(`includeChildren should only be true for ElementNodes`);\n      }\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n    this.remove();\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n    return replaceWithNode;\n  }\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n    if (!$isListNode(listNode)) {\n      {\n        formatDevErrorMessage(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n    if ($isListItemNode(node)) {\n      return super.insertAfter(node, restoreSelection);\n    }\n    const siblings = this.getNextSiblings();\n\n    // Split the lists and insert the node in between them\n    listNode.insertAfter(node, restoreSelection);\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n    return node;\n  }\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    }\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode().updateFromJSON(this.exportJSON()).setChecked(this.getChecked() ? false : undefined);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n  collapseAtStart(selection) {\n    const paragraph = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove();\n        // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n    return true;\n  }\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n    return self;\n  }\n  getChecked() {\n    const self = this.getLatest();\n    let listType;\n    const parent = this.getParent();\n    if ($isListNode(parent)) {\n      listType = parent.getListType();\n    }\n    return listType === 'check' ? Boolean(self.__checked) : undefined;\n  }\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n    return self;\n  }\n  toggleChecked() {\n    const self = this.getWritable();\n    return self.setChecked(!self.__checked);\n  }\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n    if (parent === null || !this.isAttached()) {\n      return this.getLatest().__indent;\n    }\n    // ListItemNode should always have a ListNode for a parent.\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n    return indentLevel;\n  }\n  setIndent(indent) {\n    if (!(typeof indent === 'number')) {\n      formatDevErrorMessage(`Invalid indent value.`);\n    }\n    indent = Math.floor(indent);\n    if (!(indent >= 0)) {\n      formatDevErrorMessage(`Indent value must be non-negative.`);\n    }\n    let currentIndent = this.getIndent();\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n    return this;\n  }\n\n  /** @deprecated @internal */\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  /** @deprecated @internal */\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n  canMergeWith(node) {\n    return $isListItemNode(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(node);\n  }\n  extractWithChild(child, selection) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n  isParentRequired() {\n    return true;\n  }\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n  canMergeWhenEmpty() {\n    return true;\n  }\n}\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n  if (listItemClassName !== undefined) {\n    classesToAdd.push(...normalizeClassNames(listItemClassName));\n  }\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = normalizeClassNames(nestedListItemClassName);\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\nfunction $convertListItemElement(domNode) {\n  const isGitHubCheckList = domNode.classList.contains('task-list-item');\n  if (isGitHubCheckList) {\n    for (const child of domNode.children) {\n      if (child.tagName === 'INPUT') {\n        return $convertCheckboxInput(child);\n      }\n    }\n  }\n  const ariaCheckedAttr = domNode.getAttribute('aria-checked');\n  const checked = ariaCheckedAttr === 'true' ? true : ariaCheckedAttr === 'false' ? false : undefined;\n  return {\n    node: $createListItemNode(checked)\n  };\n}\nfunction $convertCheckboxInput(domNode) {\n  const isCheckboxInput = domNode.getAttribute('type') === 'checkbox';\n  if (!isCheckboxInput) {\n    return {\n      node: null\n    };\n  }\n  const checked = domNode.hasAttribute('checked');\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\nfunction $createListItemNode(checked) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListItemNode(undefined, checked));\n}\n\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  $config() {\n    return this.config('list', {\n      $transform: node => {\n        mergeNextSiblingListIfSameType(node);\n        updateChildrenListItemValue(node);\n      },\n      extends: lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode,\n      importDOM: (0,lexical__WEBPACK_IMPORTED_MODULE_0__.buildImportMap)({\n        ol: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        }),\n        ul: () => ({\n          conversion: $convertListNode,\n          priority: 0\n        })\n      })\n    });\n  }\n  constructor(listType = 'number', start = 1, key) {\n    super(key);\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__listType = prevNode.__listType;\n    this.__tag = prevNode.__tag;\n    this.__start = prevNode.__start;\n  }\n  getTag() {\n    return this.getLatest().__tag;\n  }\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n    return writable;\n  }\n  getListType() {\n    return this.getLatest().__listType;\n  }\n  getStart() {\n    return this.getLatest().__start;\n  }\n  setStart(start) {\n    const self = this.getWritable();\n    self.__start = start;\n    return self;\n  }\n\n  // View\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    }\n    // @ts-expect-error Internal field.\n    dom.__lexicalListType = this.__listType;\n    $setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n    $setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setListType(serializedNode.listType).setStart(serializedNode.start);\n  }\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n    return {\n      element\n    };\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag()\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n  splice(start, deleteCount, nodesToInsert) {\n    let listItemNodesToInsert = nodesToInsert;\n    for (let i = 0; i < nodesToInsert.length; i++) {\n      const node = nodesToInsert[i];\n      if (!$isListItemNode(node)) {\n        if (listItemNodesToInsert === nodesToInsert) {\n          listItemNodesToInsert = [...nodesToInsert];\n        }\n        listItemNodesToInsert[i] = $createListItemNode().append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !($isListNode(node) || node.isInline()) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent()) : node);\n      }\n    }\n    return super.splice(start, deleteCount, listItemNodesToInsert);\n  }\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n}\nfunction $setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n    const checklistClassName = listTheme.checklist;\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n    if (checklistClassName !== undefined && node.__listType === 'check') {\n      classesToAdd.push(checklistClassName);\n    }\n    if (listLevelClassName !== undefined) {\n      classesToAdd.push(...normalizeClassNames(listLevelClassName));\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = normalizeClassNames(nestedListClassName);\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n  if (classesToRemove.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...classesToRemove);\n  }\n  if (classesToAdd.length > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...classesToAdd);\n  }\n}\n\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\nfunction $normalizeChildren(nodes) {\n  const normalizedListItems = [];\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push($wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push($wrapInListItem(node));\n    }\n  }\n  return normalizedListItems;\n}\nfunction isDomChecklist(domNode) {\n  if (domNode.getAttribute('__lexicallisttype') === 'check' ||\n  // is github checklist\n  domNode.classList.contains('contains-task-list')) {\n    return true;\n  }\n  // if children are checklist items, the node is a checklist ul. Applicable for googledoc checklist pasting.\n  for (const child of domNode.childNodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(child) && child.hasAttribute('aria-checked')) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction $convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (isDomChecklist(domNode)) {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n  return {\n    after: $normalizeChildren,\n    node\n  };\n}\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\nfunction $createListNode(listType = 'number', start = 1) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new ListNode(listType, start));\n}\n\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_CHECK_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_CHECK_LIST_COMMAND');\nfunction registerCheckList(editor) {\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_CHECK_LIST_COMMAND, () => {\n    $insertList('check');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, false);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, event => {\n    return handleArrowUpOrDown(event, editor, true);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, () => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null) {\n      const rootElement = editor.getRootElement();\n      if (rootElement != null) {\n        rootElement.focus();\n      }\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_SPACE_COMMAND, event => {\n    const activeItem = getActiveCheckListItem();\n    if (activeItem != null && editor.isEditable()) {\n      editor.update(() => {\n        const listItemNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n        if ($isListItemNode(listItemNode)) {\n          event.preventDefault();\n          listItemNode.toggleChecked();\n        }\n      });\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, event => {\n    return editor.getEditorState().read(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n        const {\n          anchor\n        } = selection;\n        const isElement = anchor.type === 'element';\n        if (isElement || anchor.offset === 0) {\n          const anchorNode = anchor.getNode();\n          const elementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n          if ($isListItemNode(elementNode)) {\n            const parent = elementNode.getParent();\n            if ($isListNode(parent) && parent.getListType() === 'check' && (isElement || elementNode.getFirstDescendant() === anchorNode)) {\n              const domNode = editor.getElementByKey(elementNode.__key);\n              if (domNode != null && document.activeElement !== domNode) {\n                domNode.focus();\n                event.preventDefault();\n                return true;\n              }\n            }\n          }\n        }\n      }\n      return false;\n    });\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerRootListener((rootElement, prevElement) => {\n    if (rootElement !== null) {\n      rootElement.addEventListener('click', handleClick);\n      rootElement.addEventListener('pointerdown', handlePointerDown);\n    }\n    if (prevElement !== null) {\n      prevElement.removeEventListener('click', handleClick);\n      prevElement.removeEventListener('pointerdown', handlePointerDown);\n    }\n  }));\n}\nfunction handleCheckItemEvent(event, callback) {\n  const target = event.target;\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(target)) {\n    return;\n  }\n\n  // Ignore clicks on LI that have nested lists\n  const firstChild = target.firstChild;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(firstChild) && (firstChild.tagName === 'UL' || firstChild.tagName === 'OL')) {\n    return;\n  }\n  const parentNode = target.parentNode;\n\n  // @ts-ignore internal field\n  if (!parentNode || parentNode.__lexicalListType !== 'check') {\n    return;\n  }\n  const rect = target.getBoundingClientRect();\n  const zoom = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.calculateZoomLevel)(target);\n  const clientX = event.clientX / zoom;\n\n  // Use getComputedStyle if available, otherwise fallback to 0px width\n  const beforeStyles = window.getComputedStyle ? window.getComputedStyle(target, '::before') : {\n    width: '0px'\n  };\n  const beforeWidthInPixels = parseFloat(beforeStyles.width);\n\n  // Make click area slightly larger for touch devices to improve accessibility\n  const isTouchEvent = event.pointerType === 'touch';\n  const clickAreaPadding = isTouchEvent ? 32 : 0; // Add 32px padding for touch events\n\n  if (target.dir === 'rtl' ? clientX < rect.right + clickAreaPadding && clientX > rect.right - beforeWidthInPixels - clickAreaPadding : clientX > rect.left - clickAreaPadding && clientX < rect.left + beforeWidthInPixels + clickAreaPadding) {\n    callback();\n  }\n}\nfunction handleClick(event) {\n  handleCheckItemEvent(event, () => {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(event.target)) {\n      const domNode = event.target;\n      const editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getNearestEditorFromDOMNode)(domNode);\n      if (editor != null && editor.isEditable()) {\n        editor.update(() => {\n          const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domNode);\n          if ($isListItemNode(node)) {\n            domNode.focus();\n            node.toggleChecked();\n          }\n        });\n      }\n    }\n  });\n}\nfunction handlePointerDown(event) {\n  handleCheckItemEvent(event, () => {\n    // Prevents caret moving when clicking on check mark\n    event.preventDefault();\n  });\n}\nfunction getActiveCheckListItem() {\n  const activeElement = document.activeElement;\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(activeElement) && activeElement.tagName === 'LI' && activeElement.parentNode != null &&\n  // @ts-ignore internal field\n  activeElement.parentNode.__lexicalListType === 'check' ? activeElement : null;\n}\nfunction findCheckListItemSibling(node, backward) {\n  let sibling = backward ? node.getPreviousSibling() : node.getNextSibling();\n  let parent = node;\n\n  // Going up in a tree to get non-null sibling\n  while (sibling == null && $isListItemNode(parent)) {\n    // Get li -> parent ul/ol -> parent li\n    parent = parent.getParentOrThrow().getParent();\n    if (parent != null) {\n      sibling = backward ? parent.getPreviousSibling() : parent.getNextSibling();\n    }\n  }\n\n  // Going down in a tree to get first non-nested list item\n  while ($isListItemNode(sibling)) {\n    const firstChild = backward ? sibling.getLastChild() : sibling.getFirstChild();\n    if (!$isListNode(firstChild)) {\n      return sibling;\n    }\n    sibling = backward ? firstChild.getLastChild() : firstChild.getFirstChild();\n  }\n  return null;\n}\nfunction handleArrowUpOrDown(event, editor, backward) {\n  const activeItem = getActiveCheckListItem();\n  if (activeItem != null) {\n    editor.update(() => {\n      const listItem = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(activeItem);\n      if (!$isListItemNode(listItem)) {\n        return;\n      }\n      const nextListItem = findCheckListItemSibling(listItem, backward);\n      if (nextListItem != null) {\n        nextListItem.selectStart();\n        const dom = editor.getElementByKey(nextListItem.__key);\n        if (dom != null) {\n          event.preventDefault();\n          setTimeout(() => {\n            dom.focus();\n          }, 0);\n        }\n      }\n    });\n  }\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst UPDATE_LIST_START_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('UPDATE_LIST_START_COMMAND');\nconst INSERT_UNORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_ORDERED_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('REMOVE_LIST_COMMAND');\nfunction registerList(editor) {\n  const removeListener = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_ORDERED_LIST_COMMAND, () => {\n    $insertList('number');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(UPDATE_LIST_START_COMMAND, payload => {\n    const {\n      listNodeKey,\n      newStart\n    } = payload;\n    const listNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(listNodeKey);\n    if (!$isListNode(listNode)) {\n      return false;\n    }\n    if (listNode.getListType() === 'number') {\n      listNode.setStart(newStart);\n      updateChildrenListItemValue(listNode);\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(INSERT_UNORDERED_LIST_COMMAND, () => {\n    $insertList('bullet');\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(REMOVE_LIST_COMMAND, () => {\n    $removeList();\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => $handleListInsertParagraph(), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_LOW), editor.registerNodeTransform(ListItemNode, node => {\n    const firstChild = node.getFirstChild();\n    if (firstChild) {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstChild)) {\n        const style = firstChild.getStyle();\n        const format = firstChild.getFormat();\n        if (node.getTextStyle() !== style) {\n          node.setTextStyle(style);\n        }\n        if (node.getTextFormat() !== format) {\n          node.setTextFormat(format);\n        }\n      }\n    } else {\n      // If it's empty, check the selection\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && (selection.style !== node.getTextStyle() || selection.format !== node.getTextFormat()) && selection.isCollapsed() && node.is(selection.anchor.getNode())) {\n        node.setTextStyle(selection.style).setTextFormat(selection.format);\n      }\n    }\n  }), editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, node => {\n    const listItemParentNode = node.getParent();\n    if ($isListItemNode(listItemParentNode) && node.is(listItemParentNode.getFirstChild())) {\n      const style = node.getStyle();\n      const format = node.getFormat();\n      if (style !== listItemParentNode.getTextStyle() || format !== listItemParentNode.getTextFormat()) {\n        listItemParentNode.setTextStyle(style).setTextFormat(format);\n      }\n    }\n  }));\n  return removeListener;\n}\nfunction registerListStrictIndentTransform(editor) {\n  const $formatListIndentStrict = listItemNode => {\n    const listNode = listItemNode.getParent();\n    if ($isListNode(listItemNode.getFirstChild()) || !$isListNode(listNode)) {\n      return;\n    }\n    const startingListItemNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(listItemNode, node => $isListItemNode(node) && $isListNode(node.getParent()) && $isListItemNode(node.getPreviousSibling()));\n    if (startingListItemNode === null && listItemNode.getIndent() > 0) {\n      listItemNode.setIndent(0);\n    } else if ($isListItemNode(startingListItemNode)) {\n      const prevListItemNode = startingListItemNode.getPreviousSibling();\n      if ($isListItemNode(prevListItemNode)) {\n        const endListItemNode = $findChildrenEndListItemNode(prevListItemNode);\n        const endListNode = endListItemNode.getParent();\n        if ($isListNode(endListNode)) {\n          const prevDepth = $getListDepth(endListNode);\n          const depth = $getListDepth(listNode);\n          if (prevDepth + 1 < depth) {\n            listItemNode.setIndent(prevDepth);\n          }\n        }\n      }\n    }\n  };\n  const $processListWithStrictIndent = listNode => {\n    const queue = [listNode];\n    while (queue.length > 0) {\n      const node = queue.shift();\n      if (!$isListNode(node)) {\n        continue;\n      }\n      for (const child of node.getChildren()) {\n        if ($isListItemNode(child)) {\n          $formatListIndentStrict(child);\n          const firstChild = child.getFirstChild();\n          if ($isListNode(firstChild)) {\n            queue.push(firstChild);\n          }\n        }\n      }\n    }\n  };\n  return editor.registerNodeTransform(ListNode, $processListWithStrictIndent);\n}\nfunction $findChildrenEndListItemNode(listItemNode) {\n  let current = listItemNode;\n  let firstChild = current.getFirstChild();\n  while ($isListNode(firstChild)) {\n    const lastChild = firstChild.getLastChild();\n    if ($isListItemNode(lastChild)) {\n      current = lastChild;\n      firstChild = current.getFirstChild();\n    } else {\n      break;\n    }\n  }\n  return current;\n}\n\n/**\n * @deprecated use {@link $insertList} from an update or command listener.\n *\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\nfunction insertList(editor, listType) {\n  editor.update(() => $insertList(listType));\n}\n\n/**\n * @deprecated use {@link $removeList} from an update or command listener.\n *\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\nfunction removeList(editor) {\n  editor.update(() => $removeList());\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlzdEAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVtTDtBQUN1VztBQUMvZDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUJBQXlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx5REFBZ0I7QUFDcEQ7QUFDQTtBQUNBLFNBQVMsMERBQWlCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwyRUFBMkI7QUFDL0I7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7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VSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRyxnQ0FBZ0MsNkNBQVE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1FQUFtQjtBQUNwRDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRThZIiwic291cmNlcyI6WyIvVXNlcnMvbWFjL1N5bmMvcHJvamVjdC9lY29tbWVyY2Uvc2hvcHNhYXMvaHRtbGNvbnZlcnRlci9wYXlsb2Fkc2Fhcy9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlzdEAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpc3QvTGV4aWNhbExpc3QuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7ICRnZXROZWFyZXN0Tm9kZU9mVHlwZSwgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50LCBhZGRDbGFzc05hbWVzVG9FbGVtZW50LCBpc0hUTUxFbGVtZW50LCBtZXJnZVJlZ2lzdGVyLCAkZmluZE1hdGNoaW5nUGFyZW50LCBjYWxjdWxhdGVab29tTGV2ZWwgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE9yU2hhZG93Um9vdCwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNMZWFmTm9kZSwgJHNldFBvaW50RnJvbUNhcmV0LCAkbm9ybWFsaXplQ2FyZXQsICRnZXRDaGlsZENhcmV0LCBFbGVtZW50Tm9kZSwgYnVpbGRJbXBvcnRNYXAsICRpc1BhcmFncmFwaE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGNyZWF0ZVRleHROb2RlLCBjcmVhdGVDb21tYW5kLCBDT01NQU5EX1BSSU9SSVRZX0xPVywgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9FU0NBUEVfQ09NTUFORCwgS0VZX1NQQUNFX0NPTU1BTkQsICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlLCBLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBnZXROZWFyZXN0RWRpdG9yRnJvbURPTU5vZGUsICRnZXROb2RlQnlLZXksIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgJGlzVGV4dE5vZGUsIFRleHROb2RlIH0gZnJvbSAnbGV4aWNhbCc7XG5pbXBvcnQgeyBnZXRTdHlsZU9iamVjdEZyb21DU1MgfSBmcm9tICdAbGV4aWNhbC9zZWxlY3Rpb24nO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRoZSBkZXB0aCBvZiBsaXN0Tm9kZSBmcm9tIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0gbGlzdE5vZGUgLSBUaGUgTGlzdE5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIFRoZSBkZXB0aCBvZiB0aGUgTGlzdE5vZGUuXG4gKi9cbmZ1bmN0aW9uICRnZXRMaXN0RGVwdGgobGlzdE5vZGUpIHtcbiAgbGV0IGRlcHRoID0gMTtcbiAgbGV0IHBhcmVudCA9IGxpc3ROb2RlLmdldFBhcmVudCgpO1xuICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkpIHtcbiAgICAgIGNvbnN0IHBhcmVudExpc3QgPSBwYXJlbnQuZ2V0UGFyZW50KCk7XG4gICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAgICAgZGVwdGgrKztcbiAgICAgICAgcGFyZW50ID0gcGFyZW50TGlzdC5nZXRQYXJlbnQoKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGVwdGg7XG4gIH1cbiAgcmV0dXJuIGRlcHRoO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmV0dXJucyBpdCwgdGhyb3dzIGFuIGludmFyaWFudCBpZiBsaXN0SXRlbSBpcyBub3QgYSBMaXN0SXRlbU5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW0gLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgVGhlIExpc3ROb2RlIGZvdW5kLlxuICovXG5mdW5jdGlvbiAkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW0pIHtcbiAgbGV0IGxpc3QgPSBsaXN0SXRlbS5nZXRQYXJlbnQoKTtcbiAgaWYgKCEkaXNMaXN0Tm9kZShsaXN0KSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICAgIH1cbiAgfVxuICBsZXQgcGFyZW50ID0gbGlzdDtcbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudCA9IHBhcmVudC5nZXRQYXJlbnQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgbGlzdCA9IHBhcmVudDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQSByZWN1cnNpdmUgRGVwdGgtRmlyc3QgU2VhcmNoIChQb3N0b3JkZXIgVHJhdmVyc2FsKSB0aGF0IGZpbmRzIGFsbCBvZiBhIG5vZGUncyBjaGlsZHJlblxuICogdGhhdCBhcmUgb2YgdHlwZSBMaXN0SXRlbU5vZGUgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIExpc3ROb2RlIHRvIHN0YXJ0IHRoZSBzZWFyY2guXG4gKiBAcmV0dXJucyBBbiBhcnJheSBjb250YWluaW5nIGFsbCBub2RlcyBvZiB0eXBlIExpc3RJdGVtTm9kZSBmb3VuZC5cbiAqL1xuLy8gVGhpcyBzaG91bGQgcHJvYmFibHkgYmUgJGdldEFsbENoaWxkcmVuT2ZUeXBlXG5mdW5jdGlvbiAkZ2V0QWxsTGlzdEl0ZW1zKG5vZGUpIHtcbiAgbGV0IGxpc3RJdGVtTm9kZXMgPSBbXTtcbiAgY29uc3QgbGlzdENoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpLmZpbHRlcigkaXNMaXN0SXRlbU5vZGUpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9IGxpc3RDaGlsZHJlbltpXTtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGxpc3RJdGVtTm9kZXMgPSBsaXN0SXRlbU5vZGVzLmNvbmNhdCgkZ2V0QWxsTGlzdEl0ZW1zKGZpcnN0Q2hpbGQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdEl0ZW1Ob2Rlcy5wdXNoKGxpc3RJdGVtTm9kZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBsaXN0SXRlbU5vZGVzO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgdGhlIHBhc3NlZCBub2RlIGlzIGEgTGlzdEl0ZW1Ob2RlIGFuZCBoYXMgYSBMaXN0Tm9kZSBhcyBhIGNoaWxkLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZSBhbmQgaGFzIGEgTGlzdE5vZGUgY2hpbGQsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNOZXN0ZWRMaXN0Tm9kZShub2RlKSB7XG4gIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgJiYgJGlzTGlzdE5vZGUobm9kZS5nZXRGaXJzdENoaWxkKCkpO1xufVxuXG4vKipcbiAqIFRha2VzIGEgZGVlcGx5IG5lc3RlZCBMaXN0Tm9kZSBvciBMaXN0SXRlbU5vZGUgYW5kIHRyYXZlcnNlcyB1cCB0aGUgYnJhbmNoIHRvIGRlbGV0ZSB0aGUgZmlyc3RcbiAqIGFuY2VzdHJhbCBMaXN0Tm9kZSAod2hpY2ggY291bGQgYmUgdGhlIHJvb3QgTGlzdE5vZGUpIG9yIExpc3RJdGVtTm9kZSB3aXRoIHNpYmxpbmdzLCBlc3NlbnRpYWxseVxuICogYnJpbmdpbmcgdGhlIGRlZXBseSBuZXN0ZWQgbm9kZSB1cCB0aGUgYnJhbmNoIG9uY2UuIFdvdWxkIHJlbW92ZSBzdWJsaXN0IGlmIGl0IGhhcyBzaWJsaW5ncy5cbiAqIFNob3VsZCBub3QgYnJlYWsgTGlzdEl0ZW0gLT4gTGlzdCAtPiBMaXN0SXRlbSBjaGFpbiBhcyBlbXB0eSBMaXN0L0l0ZW1Ob2RlcyBzaG91bGQgYmUgcmVtb3ZlZCBvbiAucmVtb3ZlKCkuXG4gKiBAcGFyYW0gc3VibGlzdCAtIFRoZSBuZXN0ZWQgTGlzdE5vZGUgb3IgTGlzdEl0ZW1Ob2RlIHRvIGJlIGJyb3VnaHQgdXAgdGhlIGJyYW5jaC5cbiAqL1xuZnVuY3Rpb24gJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoc3VibGlzdCkge1xuICAvLyBOb2RlcyBtYXkgYmUgcmVwZWF0ZWRseSBpbmRlbnRlZCwgdG8gY3JlYXRlIGRlZXBseSBuZXN0ZWQgbGlzdHMgdGhhdCBlYWNoXG4gIC8vIGNvbnRhaW4ganVzdCBvbmUgYnVsbGV0LlxuICAvLyBPdXIgZ29hbCBpcyB0byByZW1vdmUgdGhlc2UgKGVtcHR5KSBkZWVwbHkgbmVzdGVkIGxpc3RzLiBUaGUgZWFzaWVzdFxuICAvLyB3YXkgdG8gZG8gdGhhdCBpcyBjcmF3bCBiYWNrIHVwIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBub2RlIHRoYXQgaGFzIHNpYmxpbmdzXG4gIC8vIChlLmcuIGlzIGFjdHVhbGx5IHBhcnQgb2YgdGhlIGxpc3QgY29udGVudHMpIGFuZCBkZWxldGUgdGhhdCwgb3IgZGVsZXRlXG4gIC8vIHRoZSByb290IG9mIHRoZSBsaXN0IChpZiBubyBsaXN0IG5vZGVzIGhhdmUgc2libGluZ3MuKVxuICBsZXQgZW1wdHlMaXN0UHRyID0gc3VibGlzdDtcbiAgd2hpbGUgKGVtcHR5TGlzdFB0ci5nZXROZXh0U2libGluZygpID09IG51bGwgJiYgZW1wdHlMaXN0UHRyLmdldFByZXZpb3VzU2libGluZygpID09IG51bGwpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbXB0eUxpc3RQdHIuZ2V0UGFyZW50KCk7XG4gICAgaWYgKHBhcmVudCA9PSBudWxsIHx8ICEoJGlzTGlzdEl0ZW1Ob2RlKHBhcmVudCkgfHwgJGlzTGlzdE5vZGUocGFyZW50KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBlbXB0eUxpc3RQdHIgPSBwYXJlbnQ7XG4gIH1cbiAgZW1wdHlMaXN0UHRyLnJlbW92ZSgpO1xufVxuXG4vKipcbiAqIFdyYXBzIGEgbm9kZSBpbnRvIGEgTGlzdEl0ZW1Ob2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSB3cmFwcGVkIGludG8gYSBMaXN0SXRlbU5vZGVcbiAqIEByZXR1cm5zIFRoZSBMaXN0SXRlbU5vZGUgd2hpY2ggdGhlIHBhc3NlZCBub2RlIGlzIHdyYXBwZWQgaW4uXG4gKi9cbmZ1bmN0aW9uICR3cmFwSW5MaXN0SXRlbShub2RlKSB7XG4gIGNvbnN0IGxpc3RJdGVtV3JhcHBlciA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgcmV0dXJuIGxpc3RJdGVtV3JhcHBlci5hcHBlbmQobm9kZSk7XG59XG5cbmZ1bmN0aW9uICRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpIHtcbiAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShhbmNob3JOb2RlKSAmJiAobm9kZXMubGVuZ3RoID09PSAwIHx8IG5vZGVzLmxlbmd0aCA9PT0gMSAmJiBhbmNob3JOb2RlLmlzKG5vZGVzWzBdKSAmJiBhbmNob3JOb2RlLmdldENoaWxkcmVuU2l6ZSgpID09PSAwKTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgbmV3IExpc3ROb2RlLiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlIGFuZCBpcyBhIGNoaWxkIG9mXG4gKiB0aGUgcm9vdC9zaGFkb3cgcm9vdCwgaXQgd2lsbCByZXBsYWNlIHRoZSBMaXN0SXRlbU5vZGUgd2l0aCBhIExpc3ROb2RlIGFuZCB0aGUgb2xkIExpc3RJdGVtTm9kZS5cbiAqIE90aGVyd2lzZSBpdCB3aWxsIHJlcGxhY2UgaXRzIHBhcmVudCB3aXRoIGEgbmV3IExpc3ROb2RlIGFuZCByZS1pbnNlcnQgdGhlIExpc3RJdGVtTm9kZSBhbmQgYW55IHByZXZpb3VzIGNoaWxkcmVuLlxuICogSWYgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBub2RlIGlzIG5vdCBhbiBlbXB0eSBMaXN0SXRlbU5vZGUsIGl0IHdpbGwgYWRkIGEgbmV3IExpc3ROb2RlIG9yIG1lcmdlIGFuIGV4aXN0aW5nIExpc3ROb2RlLFxuICogdW5sZXNzIHRoZSB0aGUgbm9kZSBpcyBhIGxlYWYgbm9kZSwgaW4gd2hpY2ggY2FzZSBpdCB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIExpc3ROb2RlIHVwIHRoZSBicmFuY2ggYW5kIHJlcGxhY2UgaXQgd2l0aFxuICogYSBuZXcgTGlzdE5vZGUsIG9yIGNyZWF0ZSBhIG5ldyBMaXN0Tm9kZSBhdCB0aGUgbmVhcmVzdCByb290L3NoYWRvdyByb290LlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCwgXCJudW1iZXJcIiB8IFwiYnVsbGV0XCIgfCBcImNoZWNrXCIuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRMaXN0KGxpc3RUeXBlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKHNlbGVjdGlvbiAhPT0gbnVsbCkge1xuICAgIGxldCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBhbmNob3JBbmRGb2N1cyA9IHNlbGVjdGlvbi5nZXRTdGFydEVuZFBvaW50cygpO1xuICAgICAgaWYgKCEoYW5jaG9yQW5kRm9jdXMgIT09IG51bGwpKSB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0TGlzdDogYW5jaG9yIHNob3VsZCBiZSBkZWZpbmVkYCk7XG4gICAgICB9XG4gICAgICBjb25zdCBbYW5jaG9yXSA9IGFuY2hvckFuZEZvY3VzO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBhbmNob3JOb2RlUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KGFuY2hvck5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0Q2hpbGQgPSBhbmNob3JOb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICBub2RlcyA9IGZpcnN0Q2hpbGQuc2VsZWN0U3RhcnQoKS5nZXROb2RlcygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgYW5jaG9yTm9kZS5hcHBlbmQocGFyYWdyYXBoKTtcbiAgICAgICAgICBub2RlcyA9IHBhcmFncmFwaC5zZWxlY3QoKS5nZXROb2RlcygpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCRpc1NlbGVjdGluZ0VtcHR5TGlzdEl0ZW0oYW5jaG9yTm9kZSwgbm9kZXMpKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChhbmNob3JOb2RlUGFyZW50KSkge1xuICAgICAgICAgIGFuY2hvck5vZGUucmVwbGFjZShsaXN0KTtcbiAgICAgICAgICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICAgIGxpc3RJdGVtLnNldEZvcm1hdChhbmNob3JOb2RlLmdldEZvcm1hdFR5cGUoKSk7XG4gICAgICAgICAgICBsaXN0SXRlbS5zZXRJbmRlbnQoYW5jaG9yTm9kZS5nZXRJbmRlbnQoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICAgICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoYW5jaG9yTm9kZSkpIHtcbiAgICAgICAgICBjb25zdCBwYXJlbnQgPSBhbmNob3JOb2RlLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgICAgICBhcHBlbmQobGlzdCwgcGFyZW50LmdldENoaWxkcmVuKCkpO1xuICAgICAgICAgIHBhcmVudC5yZXBsYWNlKGxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaGFuZGxlZCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkgJiYgbm9kZS5pc0VtcHR5KCkgJiYgISRpc0xpc3RJdGVtTm9kZShub2RlKSAmJiAhaGFuZGxlZC5oYXMobm9kZS5nZXRLZXkoKSkpIHtcbiAgICAgICAgJGNyZWF0ZUxpc3RPck1lcmdlKG5vZGUsIGxpc3RUeXBlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBsZXQgcGFyZW50ID0gJGlzTGVhZk5vZGUobm9kZSkgPyBub2RlLmdldFBhcmVudCgpIDogJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmIG5vZGUuaXNFbXB0eSgpID8gbm9kZSA6IG51bGw7XG4gICAgICB3aGlsZSAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgcGFyZW50S2V5ID0gcGFyZW50LmdldEtleSgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgIGlmICghaGFuZGxlZC5oYXMocGFyZW50S2V5KSkge1xuICAgICAgICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgICAgICAgICAgYXBwZW5kKG5ld0xpc3ROb2RlLCBwYXJlbnQuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICAgICAgICBwYXJlbnQucmVwbGFjZShuZXdMaXN0Tm9kZSk7XG4gICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXh0UGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgICAgICAgIGlmICgkaXNSb290T3JTaGFkb3dSb290KG5leHRQYXJlbnQpICYmICFoYW5kbGVkLmhhcyhwYXJlbnRLZXkpKSB7XG4gICAgICAgICAgICBoYW5kbGVkLmFkZChwYXJlbnRLZXkpO1xuICAgICAgICAgICAgJGNyZWF0ZUxpc3RPck1lcmdlKHBhcmVudCwgbGlzdFR5cGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IG5leHRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFwcGVuZChub2RlLCBub2Rlc1RvQXBwZW5kKSB7XG4gIG5vZGUuc3BsaWNlKG5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksIDAsIG5vZGVzVG9BcHBlbmQpO1xufVxuZnVuY3Rpb24gJGNyZWF0ZUxpc3RPck1lcmdlKG5vZGUsIGxpc3RUeXBlKSB7XG4gIGlmICgkaXNMaXN0Tm9kZShub2RlKSkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG4gIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBsaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgYXBwZW5kKGxpc3RJdGVtLCBub2RlLmdldENoaWxkcmVuKCkpO1xuICBsZXQgdGFyZ2V0TGlzdDtcbiAgaWYgKCRpc0xpc3ROb2RlKHByZXZpb3VzU2libGluZykgJiYgbGlzdFR5cGUgPT09IHByZXZpb3VzU2libGluZy5nZXRMaXN0VHlwZSgpKSB7XG4gICAgcHJldmlvdXNTaWJsaW5nLmFwcGVuZChsaXN0SXRlbSk7XG4gICAgLy8gaWYgdGhlIHNhbWUgdHlwZSBvZiBsaXN0IGlzIG9uIGJvdGggc2lkZXMsIG1lcmdlIHRoZW0uXG4gICAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0VHlwZSA9PT0gbmV4dFNpYmxpbmcuZ2V0TGlzdFR5cGUoKSkge1xuICAgICAgYXBwZW5kKHByZXZpb3VzU2libGluZywgbmV4dFNpYmxpbmcuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgICBuZXh0U2libGluZy5yZW1vdmUoKTtcbiAgICB9XG4gICAgdGFyZ2V0TGlzdCA9IHByZXZpb3VzU2libGluZztcbiAgfSBlbHNlIGlmICgkaXNMaXN0Tm9kZShuZXh0U2libGluZykgJiYgbGlzdFR5cGUgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBuZXh0U2libGluZy5nZXRGaXJzdENoaWxkT3JUaHJvdygpLmluc2VydEJlZm9yZShsaXN0SXRlbSk7XG4gICAgdGFyZ2V0TGlzdCA9IG5leHRTaWJsaW5nO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdFR5cGUpO1xuICAgIGxpc3QuYXBwZW5kKGxpc3RJdGVtKTtcbiAgICBub2RlLnJlcGxhY2UobGlzdCk7XG4gICAgdGFyZ2V0TGlzdCA9IGxpc3Q7XG4gIH1cbiAgLy8gbGlzdEl0ZW0gbmVlZHMgdG8gYmUgYXR0YWNoZWQgdG8gcm9vdCBwcmlvciB0byBzZXR0aW5nIGluZGVudFxuICBsaXN0SXRlbS5zZXRGb3JtYXQobm9kZS5nZXRGb3JtYXRUeXBlKCkpO1xuICBsaXN0SXRlbS5zZXRJbmRlbnQobm9kZS5nZXRJbmRlbnQoKSk7XG4gIG5vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YXJnZXRMaXN0O1xufVxuXG4vKipcbiAqIEEgcmVjdXJzaXZlIGZ1bmN0aW9uIHRoYXQgZ29lcyB0aHJvdWdoIGVhY2ggbGlzdCBhbmQgdGhlaXIgY2hpbGRyZW4sIGluY2x1ZGluZyBuZXN0ZWQgbGlzdHMsXG4gKiBhcHBlbmRpbmcgbGlzdDIgY2hpbGRyZW4gYWZ0ZXIgbGlzdDEgY2hpbGRyZW4gYW5kIHVwZGF0aW5nIExpc3RJdGVtTm9kZSB2YWx1ZXMuXG4gKiBAcGFyYW0gbGlzdDEgLSBUaGUgZmlyc3QgbGlzdCB0byBiZSBtZXJnZWQuXG4gKiBAcGFyYW0gbGlzdDIgLSBUaGUgc2Vjb25kIGxpc3QgdG8gYmUgbWVyZ2VkLlxuICovXG5mdW5jdGlvbiBtZXJnZUxpc3RzKGxpc3QxLCBsaXN0Mikge1xuICBjb25zdCBsaXN0SXRlbTEgPSBsaXN0MS5nZXRMYXN0Q2hpbGQoKTtcbiAgY29uc3QgbGlzdEl0ZW0yID0gbGlzdDIuZ2V0Rmlyc3RDaGlsZCgpO1xuICBpZiAobGlzdEl0ZW0xICYmIGxpc3RJdGVtMiAmJiBpc05lc3RlZExpc3ROb2RlKGxpc3RJdGVtMSkgJiYgaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbTIpKSB7XG4gICAgbWVyZ2VMaXN0cyhsaXN0SXRlbTEuZ2V0Rmlyc3RDaGlsZCgpLCBsaXN0SXRlbTIuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICBsaXN0SXRlbTIucmVtb3ZlKCk7XG4gIH1cbiAgY29uc3QgdG9NZXJnZSA9IGxpc3QyLmdldENoaWxkcmVuKCk7XG4gIGlmICh0b01lcmdlLmxlbmd0aCA+IDApIHtcbiAgICBsaXN0MS5hcHBlbmQoLi4udG9NZXJnZSk7XG4gIH1cbiAgbGlzdDIucmVtb3ZlKCk7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgZm9yIHRoZSBuZWFyZXN0IGFuY2VzdHJhbCBMaXN0Tm9kZSBhbmQgcmVtb3ZlcyBpdC4gSWYgc2VsZWN0aW9uIGlzIGFuIGVtcHR5IExpc3RJdGVtTm9kZVxuICogaXQgd2lsbCByZW1vdmUgdGhlIHdob2xlIGxpc3QsIGluY2x1ZGluZyB0aGUgTGlzdEl0ZW1Ob2RlLiBGb3IgZWFjaCBMaXN0SXRlbU5vZGUgaW4gdGhlIExpc3ROb2RlLFxuICogcmVtb3ZlTGlzdCB3aWxsIGFsc28gZ2VuZXJhdGUgbmV3IFBhcmFncmFwaE5vZGVzIGluIHRoZSByZW1vdmVkIExpc3ROb2RlJ3MgcGxhY2UuIEFueSBjaGlsZCBub2RlXG4gKiBpbnNpZGUgYSBMaXN0SXRlbU5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0byB0aGUgbmV3IFBhcmFncmFwaE5vZGVzLlxuICovXG5mdW5jdGlvbiAkcmVtb3ZlTGlzdCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGxpc3ROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpO1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBpZiAoJGlzU2VsZWN0aW5nRW1wdHlMaXN0SXRlbShhbmNob3JOb2RlLCBub2RlcykpIHtcbiAgICAgIGxpc3ROb2Rlcy5hZGQoJGdldFRvcExpc3ROb2RlKGFuY2hvck5vZGUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmICgkaXNMZWFmTm9kZShub2RlKSkge1xuICAgICAgICAgIGNvbnN0IGxpc3RJdGVtTm9kZSA9ICRnZXROZWFyZXN0Tm9kZU9mVHlwZShub2RlLCBMaXN0SXRlbU5vZGUpO1xuICAgICAgICAgIGlmIChsaXN0SXRlbU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbGlzdE5vZGVzLmFkZCgkZ2V0VG9wTGlzdE5vZGUobGlzdEl0ZW1Ob2RlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGlzdE5vZGUgb2YgbGlzdE5vZGVzKSB7XG4gICAgICBsZXQgaW5zZXJ0aW9uUG9pbnQgPSBsaXN0Tm9kZTtcbiAgICAgIGNvbnN0IGxpc3RJdGVtcyA9ICRnZXRBbGxMaXN0SXRlbXMobGlzdE5vZGUpO1xuICAgICAgZm9yIChjb25zdCBsaXN0SXRlbU5vZGUgb2YgbGlzdEl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkuc2V0VGV4dFN0eWxlKHNlbGVjdGlvbi5zdHlsZSkuc2V0VGV4dEZvcm1hdChzZWxlY3Rpb24uZm9ybWF0KTtcbiAgICAgICAgYXBwZW5kKHBhcmFncmFwaCwgbGlzdEl0ZW1Ob2RlLmdldENoaWxkcmVuKCkpO1xuICAgICAgICBpbnNlcnRpb25Qb2ludC5pbnNlcnRBZnRlcihwYXJhZ3JhcGgpO1xuICAgICAgICBpbnNlcnRpb25Qb2ludCA9IHBhcmFncmFwaDtcblxuICAgICAgICAvLyBXaGVuIHRoZSBhbmNob3IgYW5kIGZvY3VzIGZhbGwgb24gdGhlIHRleHROb2RlXG4gICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gY2hhbmdlIHRoZSBzZWxlY3Rpb24gYmVjYXVzZSB0aGUgdGV4dE5vZGUgd2lsbCBiZSBhcHBlbmRlZCB0b1xuICAgICAgICAvLyB0aGUgbmV3bHkgZ2VuZXJhdGVkIHBhcmFncmFwaC5cbiAgICAgICAgLy8gV2hlbiBzZWxlY3Rpb24gaXMgaW4gZW1wdHkgbmVzdGVkIGxpc3QgaXRlbSwgc2VsZWN0aW9uIGlzIGFjdHVhbGx5IG9uIHRoZSBsaXN0SXRlbU5vZGUuXG4gICAgICAgIC8vIFdoZW4gdGhlIGNvcnJlc3BvbmRpbmcgbGlzdEl0ZW1Ob2RlIGlzIGRlbGV0ZWQgYW5kIHJlcGxhY2VkIGJ5IHRoZSBuZXdseSBnZW5lcmF0ZWQgcGFyYWdyYXBoXG4gICAgICAgIC8vIHdlIHNob3VsZCBtYW51YWxseSBzZXQgdGhlIHNlbGVjdGlvbidzIGZvY3VzIGFuZCBhbmNob3IgdG8gdGhlIG5ld2x5IGdlbmVyYXRlZCBwYXJhZ3JhcGguXG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGUuX19rZXkgPT09IHNlbGVjdGlvbi5hbmNob3Iua2V5KSB7XG4gICAgICAgICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsICRub3JtYWxpemVDYXJldCgkZ2V0Q2hpbGRDYXJldChwYXJhZ3JhcGgsICduZXh0JykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdEl0ZW1Ob2RlLl9fa2V5ID09PSBzZWxlY3Rpb24uZm9jdXMua2V5KSB7XG4gICAgICAgICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgJG5vcm1hbGl6ZUNhcmV0KCRnZXRDaGlsZENhcmV0KHBhcmFncmFwaCwgJ25leHQnKSkpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RJdGVtTm9kZS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGxpc3ROb2RlLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIHRoZSB2YWx1ZSBvZiBhIGNoaWxkIExpc3RJdGVtTm9kZSBhbmQgbWFrZXMgaXQgdGhlIHZhbHVlIHRoZSBMaXN0SXRlbU5vZGVcbiAqIHNob3VsZCBiZSBpZiBpdCBpc24ndCBhbHJlYWR5LiBBbHNvIGVuc3VyZXMgdGhhdCBjaGVja2VkIGlzIHVuZGVmaW5lZCBpZiB0aGVcbiAqIHBhcmVudCBkb2VzIG5vdCBoYXZlIGEgbGlzdCB0eXBlIG9mICdjaGVjaycuXG4gKiBAcGFyYW0gbGlzdCAtIFRoZSBsaXN0IHdob3NlIGNoaWxkcmVuIGFyZSB1cGRhdGVkLlxuICovXG5mdW5jdGlvbiB1cGRhdGVDaGlsZHJlbkxpc3RJdGVtVmFsdWUobGlzdCkge1xuICBjb25zdCBpc05vdENoZWNrbGlzdCA9IGxpc3QuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJztcbiAgbGV0IHZhbHVlID0gbGlzdC5nZXRTdGFydCgpO1xuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGxpc3QuZ2V0Q2hpbGRyZW4oKSkge1xuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUoY2hpbGQpKSB7XG4gICAgICBpZiAoY2hpbGQuZ2V0VmFsdWUoKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgY2hpbGQuc2V0VmFsdWUodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGlzTm90Q2hlY2tsaXN0ICYmIGNoaWxkLmdldExhdGVzdCgpLl9fY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICAgIGNoaWxkLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICAgIGlmICghJGlzTGlzdE5vZGUoY2hpbGQuZ2V0Rmlyc3RDaGlsZCgpKSkge1xuICAgICAgICB2YWx1ZSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHRoZSBuZXh0IHNpYmxpbmcgbGlzdCBpZiBzYW1lIHR5cGUuXG4gKiA8dWw+IHdpbGwgbWVyZ2Ugd2l0aCA8dWw+LCBidXQgTk9UIDx1bD4gd2l0aCA8b2w+LlxuICogQHBhcmFtIGxpc3QgLSBUaGUgbGlzdCB3aG9zZSBuZXh0IHNpYmxpbmcgc2hvdWxkIGJlIHBvdGVudGlhbGx5IG1lcmdlZFxuICovXG5mdW5jdGlvbiBtZXJnZU5leHRTaWJsaW5nTGlzdElmU2FtZVR5cGUobGlzdCkge1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3QuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgaWYgKCRpc0xpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBsaXN0LmdldExpc3RUeXBlKCkgPT09IG5leHRTaWJsaW5nLmdldExpc3RUeXBlKCkpIHtcbiAgICBtZXJnZUxpc3RzKGxpc3QsIG5leHRTaWJsaW5nKTtcbiAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZW1wdHkgTGlzdE5vZGUvTGlzdEl0ZW1Ob2RlIGNoYWluIGF0IGxpc3RJdGVtTm9kZSwgc28gYXMgdG9cbiAqIGNyZWF0ZSBhbiBpbmRlbnQgZWZmZWN0LiBXb24ndCBpbmRlbnQgTGlzdEl0ZW1Ob2RlcyB0aGF0IGhhdmUgYSBMaXN0Tm9kZSBhc1xuICogYSBjaGlsZCwgYnV0IGRvZXMgbWVyZ2Ugc2libGluZyBMaXN0SXRlbU5vZGVzIGlmIG9uZSBoYXMgYSBuZXN0ZWQgTGlzdE5vZGUuXG4gKiBAcGFyYW0gbGlzdEl0ZW1Ob2RlIC0gVGhlIExpc3RJdGVtTm9kZSB0byBiZSBpbmRlbnRlZC5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZUluZGVudChsaXN0SXRlbU5vZGUpIHtcbiAgLy8gZ28gdGhyb3VnaCBlYWNoIG5vZGUgYW5kIGRlY2lkZSB3aGVyZSB0byBtb3ZlIGl0LlxuICBjb25zdCByZW1vdmVkID0gbmV3IFNldCgpO1xuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpIHx8IHJlbW92ZWQuaGFzKGxpc3RJdGVtTm9kZS5nZXRLZXkoKSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcGFyZW50ID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuXG4gIC8vIFdlIGNhbiBjYXN0IGJvdGggb2YgdGhlIGJlbG93IGBpc05lc3RlZExpc3ROb2RlYCBvbmx5IHJldHVybnMgYSBib29sZWFuIHR5cGUgaW5zdGVhZCBvZiBhIHVzZXItZGVmaW5lZCB0eXBlIGd1YXJkc1xuICBjb25zdCBuZXh0U2libGluZyA9IGxpc3RJdGVtTm9kZS5nZXROZXh0U2libGluZygpO1xuICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBsaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gIC8vIGlmIHRoZXJlIGFyZSBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUsIG1lcmdlIHRoZW0gYWxsIHRvZ2V0aGVyLlxuXG4gIGlmIChpc05lc3RlZExpc3ROb2RlKG5leHRTaWJsaW5nKSAmJiBpc05lc3RlZExpc3ROb2RlKHByZXZpb3VzU2libGluZykpIHtcbiAgICBjb25zdCBpbm5lckxpc3QgPSBwcmV2aW91c1NpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBpbm5lckxpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBjb25zdCBuZXh0SW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgaWYgKCRpc0xpc3ROb2RlKG5leHRJbm5lckxpc3QpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbmV4dElubmVyTGlzdC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBhcHBlbmQoaW5uZXJMaXN0LCBjaGlsZHJlbik7XG4gICAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgICAgICByZW1vdmVkLmFkZChuZXh0U2libGluZy5nZXRLZXkoKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgLy8gaWYgdGhlIExpc3RJdGVtTm9kZSBpcyBuZXh0IHRvIGEgbmVzdGVkIExpc3ROb2RlLCBtZXJnZSB0aGVtXG4gICAgY29uc3QgaW5uZXJMaXN0ID0gbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShpbm5lckxpc3QpKSB7XG4gICAgICBjb25zdCBmaXJzdENoaWxkID0gaW5uZXJMaXN0LmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpcnN0Q2hpbGQuaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzTmVzdGVkTGlzdE5vZGUocHJldmlvdXNTaWJsaW5nKSkge1xuICAgIGNvbnN0IGlubmVyTGlzdCA9IHByZXZpb3VzU2libGluZy5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKGlubmVyTGlzdCkpIHtcbiAgICAgIGlubmVyTGlzdC5hcHBlbmQobGlzdEl0ZW1Ob2RlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBuZXN0ZWQgTGlzdE5vZGVcblxuICAgIGlmICgkaXNMaXN0Tm9kZShwYXJlbnQpKSB7XG4gICAgICBjb25zdCBuZXdMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKS5zZXRUZXh0Rm9ybWF0KGxpc3RJdGVtTm9kZS5nZXRUZXh0Rm9ybWF0KCkpLnNldFRleHRTdHlsZShsaXN0SXRlbU5vZGUuZ2V0VGV4dFN0eWxlKCkpO1xuICAgICAgY29uc3QgbmV3TGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShwYXJlbnQuZ2V0TGlzdFR5cGUoKSkuc2V0VGV4dEZvcm1hdChwYXJlbnQuZ2V0VGV4dEZvcm1hdCgpKS5zZXRUZXh0U3R5bGUocGFyZW50LmdldFRleHRTdHlsZSgpKTtcbiAgICAgIG5ld0xpc3RJdGVtLmFwcGVuZChuZXdMaXN0KTtcbiAgICAgIG5ld0xpc3QuYXBwZW5kKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICAgIHByZXZpb3VzU2libGluZy5pbnNlcnRBZnRlcihuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2UgaWYgKG5leHRTaWJsaW5nKSB7XG4gICAgICAgIG5leHRTaWJsaW5nLmluc2VydEJlZm9yZShuZXdMaXN0SXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJlbnQuYXBwZW5kKG5ld0xpc3RJdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFuIGluZGVudCBieSByZW1vdmluZyBhbiBlbXB0eSBMaXN0Tm9kZS9MaXN0SXRlbU5vZGUgY2hhaW4uIEFuIGluZGVudGVkIExpc3RJdGVtTm9kZVxuICogaGFzIGEgZ3JlYXQgZ3JhbmRwYXJlbnQgbm9kZSBvZiB0eXBlIExpc3ROb2RlLCB3aGljaCBpcyB3aGVyZSB0aGUgTGlzdEl0ZW1Ob2RlIHdpbGwgcmVzaWRlXG4gKiB3aXRoaW4gYXMgYSBjaGlsZC5cbiAqIEBwYXJhbSBsaXN0SXRlbU5vZGUgLSBUaGUgTGlzdEl0ZW1Ob2RlIHRvIHJlbW92ZSB0aGUgaW5kZW50IChvdXRkZW50KS5cbiAqL1xuZnVuY3Rpb24gJGhhbmRsZU91dGRlbnQobGlzdEl0ZW1Ob2RlKSB7XG4gIC8vIGdvIHRocm91Z2ggZWFjaCBub2RlIGFuZCBkZWNpZGUgd2hlcmUgdG8gbW92ZSBpdC5cblxuICBpZiAoaXNOZXN0ZWRMaXN0Tm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudExpc3QgPSBsaXN0SXRlbU5vZGUuZ2V0UGFyZW50KCk7XG4gIGNvbnN0IGdyYW5kcGFyZW50TGlzdEl0ZW0gPSBwYXJlbnRMaXN0ID8gcGFyZW50TGlzdC5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgY29uc3QgZ3JlYXRHcmFuZHBhcmVudExpc3QgPSBncmFuZHBhcmVudExpc3RJdGVtID8gZ3JhbmRwYXJlbnRMaXN0SXRlbS5nZXRQYXJlbnQoKSA6IHVuZGVmaW5lZDtcbiAgLy8gSWYgaXQgZG9lc24ndCBoYXZlIHRoZXNlIGFuY2VzdG9ycywgaXQncyBub3QgaW5kZW50ZWQuXG5cbiAgaWYgKCRpc0xpc3ROb2RlKGdyZWF0R3JhbmRwYXJlbnRMaXN0KSAmJiAkaXNMaXN0SXRlbU5vZGUoZ3JhbmRwYXJlbnRMaXN0SXRlbSkgJiYgJGlzTGlzdE5vZGUocGFyZW50TGlzdCkpIHtcbiAgICAvLyBpZiBpdCdzIHRoZSBmaXJzdCBjaGlsZCBpbiBpdCdzIHBhcmVudCBsaXN0LCBpbnNlcnQgaXQgaW50byB0aGVcbiAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGJlZm9yZSB0aGUgZ3JhbmRwYXJlbnRcbiAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyZW50TGlzdCA/IHBhcmVudExpc3QuZ2V0Rmlyc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGxhc3RDaGlsZCA9IHBhcmVudExpc3QgPyBwYXJlbnRMaXN0LmdldExhc3RDaGlsZCgpIDogdW5kZWZpbmVkO1xuICAgIGlmIChsaXN0SXRlbU5vZGUuaXMoZmlyc3RDaGlsZCkpIHtcbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0uaW5zZXJ0QmVmb3JlKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGl0J3MgdGhlIGxhc3QgY2hpbGQgaW4gaXQncyBwYXJlbnQgbGlzdCwgaW5zZXJ0IGl0IGludG8gdGhlXG4gICAgICAvLyBncmVhdCBncmFuZHBhcmVudCBsaXN0IGFmdGVyIHRoZSBncmFuZHBhcmVudC5cbiAgICB9IGVsc2UgaWYgKGxpc3RJdGVtTm9kZS5pcyhsYXN0Q2hpbGQpKSB7XG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEFmdGVyKGxpc3RJdGVtTm9kZSk7XG4gICAgICBpZiAocGFyZW50TGlzdC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBzaWJsaW5ncyBpbnRvIHR3byBuZXcgbmVzdGVkIGxpc3RzXG4gICAgICBjb25zdCBsaXN0VHlwZSA9IHBhcmVudExpc3QuZ2V0TGlzdFR5cGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0SXRlbSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZ3NMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKGxpc3RUeXBlKTtcbiAgICAgIHByZXZpb3VzU2libGluZ3NMaXN0SXRlbS5hcHBlbmQocHJldmlvdXNTaWJsaW5nc0xpc3QpO1xuICAgICAgbGlzdEl0ZW1Ob2RlLmdldFByZXZpb3VzU2libGluZ3MoKS5mb3JFYWNoKHNpYmxpbmcgPT4gcHJldmlvdXNTaWJsaW5nc0xpc3QuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIGNvbnN0IG5leHRTaWJsaW5nc0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgY29uc3QgbmV4dFNpYmxpbmdzTGlzdCA9ICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSk7XG4gICAgICBuZXh0U2libGluZ3NMaXN0SXRlbS5hcHBlbmQobmV4dFNpYmxpbmdzTGlzdCk7XG4gICAgICBhcHBlbmQobmV4dFNpYmxpbmdzTGlzdCwgbGlzdEl0ZW1Ob2RlLmdldE5leHRTaWJsaW5ncygpKTtcbiAgICAgIC8vIHB1dCB0aGUgc2libGluZyBuZXN0ZWQgbGlzdHMgb24gZWl0aGVyIHNpZGUgb2YgdGhlIGdyYW5kcGFyZW50IGxpc3QgaXRlbSBpbiB0aGUgZ3JlYXQgZ3JhbmRwYXJlbnQuXG4gICAgICBncmFuZHBhcmVudExpc3RJdGVtLmluc2VydEJlZm9yZShwcmV2aW91c1NpYmxpbmdzTGlzdEl0ZW0pO1xuICAgICAgZ3JhbmRwYXJlbnRMaXN0SXRlbS5pbnNlcnRBZnRlcihuZXh0U2libGluZ3NMaXN0SXRlbSk7XG4gICAgICAvLyByZXBsYWNlIHRoZSBncmFuZHBhcmVudCBsaXN0IGl0ZW0gKG5vdyBiZXR3ZWVuIHRoZSBzaWJsaW5ncykgd2l0aCB0aGUgb3V0ZGVudGVkIGxpc3QgaXRlbS5cbiAgICAgIGdyYW5kcGFyZW50TGlzdEl0ZW0ucmVwbGFjZShsaXN0SXRlbU5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGluc2VydCBhIFBhcmFncmFwaE5vZGUgYXQgc2VsZWN0aW9uIGFuZCBzZWxlY3RzIHRoZSBuZXcgbm9kZS4gVGhlIHNlbGVjdGlvbiBtdXN0IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGVcbiAqIG9yIGEgbm9kZSB0aGF0IGRvZXMgbm90IGFscmVhZHkgY29udGFpbiB0ZXh0LiBJZiBpdHMgZ3JhbmRwYXJlbnQgaXMgdGhlIHJvb3Qvc2hhZG93IHJvb3QsIGl0IHdpbGwgZ2V0IHRoZSBMaXN0Tm9kZVxuICogKHdoaWNoIHNob3VsZCBiZSB0aGUgcGFyZW50IG5vZGUpIGFuZCBpbnNlcnQgdGhlIFBhcmFncmFwaE5vZGUgYXMgYSBzaWJsaW5nIHRvIHRoZSBMaXN0Tm9kZS4gSWYgdGhlIExpc3ROb2RlIGlzXG4gKiBuZXN0ZWQgaW4gYSBMaXN0SXRlbU5vZGUgaW5zdGVhZCwgaXQgd2lsbCBhZGQgdGhlIFBhcmFncmFwaE5vZGUgYWZ0ZXIgdGhlIGdyYW5kcGFyZW50IExpc3RJdGVtTm9kZS5cbiAqIFRocm93cyBhbiBpbnZhcmlhbnQgaWYgdGhlIHNlbGVjdGlvbiBpcyBub3QgYSBjaGlsZCBvZiBhIExpc3ROb2RlLlxuICogQHJldHVybnMgdHJ1ZSBpZiBhIFBhcmFncmFwaE5vZGUgd2FzIGluc2VydGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgdGhlcmUgaXMgbm8gc2VsZWN0aW9uXG4gKiBvciB0aGUgc2VsZWN0aW9uIGRvZXMgbm90IGNvbnRhaW4gYSBMaXN0SXRlbU5vZGUgb3IgdGhlIG5vZGUgYWxyZWFkeSBob2xkcyB0ZXh0LlxuICovXG5mdW5jdGlvbiAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgIXNlbGVjdGlvbi5pc0NvbGxhcHNlZCgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIE9ubHkgcnVuIHRoaXMgY29kZSBvbiBlbXB0eSBsaXN0IGl0ZW1zXG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBpZiAoISRpc0xpc3RJdGVtTm9kZShhbmNob3IpIHx8IGFuY2hvci5nZXRDaGlsZHJlblNpemUoKSAhPT0gMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCB0b3BMaXN0Tm9kZSA9ICRnZXRUb3BMaXN0Tm9kZShhbmNob3IpO1xuICBjb25zdCBwYXJlbnQgPSBhbmNob3IuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgQSBMaXN0SXRlbU5vZGUgbXVzdCBoYXZlIGEgTGlzdE5vZGUgZm9yIGEgcGFyZW50LmApO1xuICB9XG4gIGNvbnN0IGdyYW5kcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICBsZXQgcmVwbGFjZW1lbnROb2RlO1xuICBpZiAoJGlzUm9vdE9yU2hhZG93Um9vdChncmFuZHBhcmVudCkpIHtcbiAgICByZXBsYWNlbWVudE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgIHRvcExpc3ROb2RlLmluc2VydEFmdGVyKHJlcGxhY2VtZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGdyYW5kcGFyZW50KSkge1xuICAgIHJlcGxhY2VtZW50Tm9kZSA9ICRjcmVhdGVMaXN0SXRlbU5vZGUoKTtcbiAgICBncmFuZHBhcmVudC5pbnNlcnRBZnRlcihyZXBsYWNlbWVudE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXBsYWNlbWVudE5vZGUuc2V0VGV4dFN0eWxlKHNlbGVjdGlvbi5zdHlsZSkuc2V0VGV4dEZvcm1hdChzZWxlY3Rpb24uZm9ybWF0KS5zZWxlY3QoKTtcbiAgY29uc3QgbmV4dFNpYmxpbmdzID0gYW5jaG9yLmdldE5leHRTaWJsaW5ncygpO1xuICBpZiAobmV4dFNpYmxpbmdzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBuZXdMaXN0ID0gJGNyZWF0ZUxpc3ROb2RlKHBhcmVudC5nZXRMaXN0VHlwZSgpKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50Tm9kZSkpIHtcbiAgICAgIGNvbnN0IG5ld0xpc3RJdGVtID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpO1xuICAgICAgbmV3TGlzdEl0ZW0uYXBwZW5kKG5ld0xpc3QpO1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3RJdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVwbGFjZW1lbnROb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH1cbiAgICBuZXdMaXN0LmFwcGVuZCguLi5uZXh0U2libGluZ3MpO1xuICB9XG5cbiAgLy8gRG9uJ3QgbGVhdmUgaGFuZ2luZyBuZXN0ZWQgZW1wdHkgbGlzdHNcbiAgJHJlbW92ZUhpZ2hlc3RFbXB0eUxpc3RQYXJlbnQoYW5jaG9yKTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuZnVuY3Rpb24gbm9ybWFsaXplQ2xhc3NOYW1lcyguLi5jbGFzc05hbWVzKSB7XG4gIGNvbnN0IHJ2YWwgPSBbXTtcbiAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgY2xhc3NOYW1lcykge1xuICAgIGlmIChjbGFzc05hbWUgJiYgdHlwZW9mIGNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZvciAoY29uc3QgW3NdIG9mIGNsYXNzTmFtZS5tYXRjaEFsbCgvXFxTKy9nKSkge1xuICAgICAgICBydmFsLnB1c2gocyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG5mdW5jdGlvbiBhcHBseU1hcmtlclN0eWxlcyhkb20sIG5vZGUsIHByZXZOb2RlKSB7XG4gIGNvbnN0IHN0eWxlcyA9IGdldFN0eWxlT2JqZWN0RnJvbUNTUyhub2RlLl9fdGV4dFN0eWxlKTtcbiAgZm9yIChjb25zdCBrIGluIHN0eWxlcykge1xuICAgIGRvbS5zdHlsZS5zZXRQcm9wZXJ0eShgLS1saXN0aXRlbS1tYXJrZXItJHtrfWAsIHN0eWxlc1trXSk7XG4gIH1cbiAgaWYgKHByZXZOb2RlKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGdldFN0eWxlT2JqZWN0RnJvbUNTUyhwcmV2Tm9kZS5fX3RleHRTdHlsZSkpIHtcbiAgICAgIGlmICghKGsgaW4gc3R5bGVzKSkge1xuICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkoYC0tbGlzdGl0ZW0tbWFya2VyLSR7a31gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3RJdGVtTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gICRjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnKCdsaXN0aXRlbScsIHtcbiAgICAgICR0cmFuc2Zvcm06IG5vZGUgPT4ge1xuICAgICAgICBpZiAobm9kZS5fX2NoZWNrZWQgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSkge1xuICAgICAgICAgIGlmIChwYXJlbnQuZ2V0TGlzdFR5cGUoKSAhPT0gJ2NoZWNrJyAmJiBub2RlLmdldENoZWNrZWQoKSAhPSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLnNldENoZWNrZWQodW5kZWZpbmVkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleHRlbmRzOiBFbGVtZW50Tm9kZSxcbiAgICAgIGltcG9ydERPTTogYnVpbGRJbXBvcnRNYXAoe1xuICAgICAgICBsaTogKCkgPT4gKHtcbiAgICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydExpc3RJdGVtRWxlbWVudCxcbiAgICAgICAgICBwcmlvcml0eTogMFxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBjb25zdHJ1Y3Rvcih2YWx1ZSA9IDEsIGNoZWNrZWQgPSB1bmRlZmluZWQsIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gdmFsdWUgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IGNoZWNrZWQ7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX3ZhbHVlID0gcHJldk5vZGUuX192YWx1ZTtcbiAgICB0aGlzLl9fY2hlY2tlZCA9IHByZXZOb2RlLl9fY2hlY2tlZDtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG4gICAgdGhpcy51cGRhdGVMaXN0SXRlbURPTShudWxsLCBlbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHVwZGF0ZUxpc3RJdGVtRE9NKHByZXZOb2RlLCBkb20sIGNvbmZpZykge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkgJiYgcGFyZW50LmdldExpc3RUeXBlKCkgPT09ICdjaGVjaycpIHtcbiAgICAgIHVwZGF0ZUxpc3RJdGVtQ2hlY2tlZChkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgICB9XG4gICAgZG9tLnZhbHVlID0gdGhpcy5fX3ZhbHVlO1xuICAgICRzZXRMaXN0SXRlbVRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgY29uc3QgcHJldlN0eWxlID0gcHJldk5vZGUgPyBwcmV2Tm9kZS5fX3N0eWxlIDogJyc7XG4gICAgY29uc3QgbmV4dFN0eWxlID0gdGhpcy5fX3N0eWxlO1xuICAgIGlmIChwcmV2U3R5bGUgIT09IG5leHRTdHlsZSkge1xuICAgICAgaWYgKG5leHRTdHlsZSA9PT0gJycpIHtcbiAgICAgICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ID0gbmV4dFN0eWxlO1xuICAgICAgfVxuICAgIH1cbiAgICBhcHBseU1hcmtlclN0eWxlcyhkb20sIHRoaXMsIHByZXZOb2RlKTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtIHRoaXMgaXMgYWx3YXlzIEhUTUxMaXN0SXRlbUVsZW1lbnRcbiAgICBjb25zdCBlbGVtZW50ID0gZG9tO1xuICAgIHRoaXMudXBkYXRlTGlzdEl0ZW1ET00ocHJldk5vZGUsIGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRWYWx1ZShzZXJpYWxpemVkTm9kZS52YWx1ZSkuc2V0Q2hlY2tlZChzZXJpYWxpemVkTm9kZS5jaGVja2VkKTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnKTtcbiAgICBjb25zdCBmb3JtYXRUeXBlID0gdGhpcy5nZXRGb3JtYXRUeXBlKCk7XG4gICAgaWYgKGZvcm1hdFR5cGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudGV4dEFsaWduID0gZm9ybWF0VHlwZTtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gdGhpcy5nZXREaXJlY3Rpb24oKTtcbiAgICBpZiAoZGlyZWN0aW9uKSB7XG4gICAgICBlbGVtZW50LmRpciA9IGRpcmVjdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNoZWNrZWQ6IHRoaXMuZ2V0Q2hlY2tlZCgpLFxuICAgICAgdmFsdWU6IHRoaXMuZ2V0VmFsdWUoKVxuICAgIH07XG4gIH1cbiAgYXBwZW5kKC4uLm5vZGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpICYmIHRoaXMuY2FuTWVyZ2VXaXRoKG5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICB0aGlzLmFwcGVuZCguLi5jaGlsZHJlbik7XG4gICAgICAgIG5vZGUucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdXBlci5hcHBlbmQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHJlcGxhY2UocmVwbGFjZVdpdGhOb2RlLCBpbmNsdWRlQ2hpbGRyZW4pIHtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5yZXBsYWNlKHJlcGxhY2VXaXRoTm9kZSk7XG4gICAgfVxuICAgIHRoaXMuc2V0SW5kZW50KDApO1xuICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICBpZiAoISRpc0xpc3ROb2RlKGxpc3QpKSB7XG4gICAgICByZXR1cm4gcmVwbGFjZVdpdGhOb2RlO1xuICAgIH1cbiAgICBpZiAobGlzdC5fX2ZpcnN0ID09PSB0aGlzLmdldEtleSgpKSB7XG4gICAgICBsaXN0Lmluc2VydEJlZm9yZShyZXBsYWNlV2l0aE5vZGUpO1xuICAgIH0gZWxzZSBpZiAobGlzdC5fX2xhc3QgPT09IHRoaXMuZ2V0S2V5KCkpIHtcbiAgICAgIGxpc3QuaW5zZXJ0QWZ0ZXIocmVwbGFjZVdpdGhOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3BsaXQgdGhlIGxpc3RcbiAgICAgIGNvbnN0IG5ld0xpc3QgPSAkY3JlYXRlTGlzdE5vZGUobGlzdC5nZXRMaXN0VHlwZSgpKTtcbiAgICAgIGxldCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIHdoaWxlIChuZXh0U2libGluZykge1xuICAgICAgICBjb25zdCBub2RlVG9BcHBlbmQgPSBuZXh0U2libGluZztcbiAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5nZXROZXh0U2libGluZygpO1xuICAgICAgICBuZXdMaXN0LmFwcGVuZChub2RlVG9BcHBlbmQpO1xuICAgICAgfVxuICAgICAgbGlzdC5pbnNlcnRBZnRlcihyZXBsYWNlV2l0aE5vZGUpO1xuICAgICAgcmVwbGFjZVdpdGhOb2RlLmluc2VydEFmdGVyKG5ld0xpc3QpO1xuICAgIH1cbiAgICBpZiAoaW5jbHVkZUNoaWxkcmVuKSB7XG4gICAgICBpZiAoISRpc0VsZW1lbnROb2RlKHJlcGxhY2VXaXRoTm9kZSkpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbmNsdWRlQ2hpbGRyZW4gc2hvdWxkIG9ubHkgYmUgdHJ1ZSBmb3IgRWxlbWVudE5vZGVzYCk7XG4gICAgICB9XG4gICAgICB0aGlzLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgIHJlcGxhY2VXaXRoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgaWYgKGxpc3QuZ2V0Q2hpbGRyZW5TaXplKCkgPT09IDApIHtcbiAgICAgIGxpc3QucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiByZXBsYWNlV2l0aE5vZGU7XG4gIH1cbiAgaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICB7XG4gICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgaW5zZXJ0QWZ0ZXI6IGxpc3Qgbm9kZSBpcyBub3QgcGFyZW50IG9mIGxpc3QgaXRlbSBub2RlYCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBzdXBlci5pbnNlcnRBZnRlcihub2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgc2libGluZ3MgPSB0aGlzLmdldE5leHRTaWJsaW5ncygpO1xuXG4gICAgLy8gU3BsaXQgdGhlIGxpc3RzIGFuZCBpbnNlcnQgdGhlIG5vZGUgaW4gYmV0d2VlbiB0aGVtXG4gICAgbGlzdE5vZGUuaW5zZXJ0QWZ0ZXIobm9kZSwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKHNpYmxpbmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY29uc3QgbmV3TGlzdE5vZGUgPSAkY3JlYXRlTGlzdE5vZGUobGlzdE5vZGUuZ2V0TGlzdFR5cGUoKSk7XG4gICAgICBzaWJsaW5ncy5mb3JFYWNoKHNpYmxpbmcgPT4gbmV3TGlzdE5vZGUuYXBwZW5kKHNpYmxpbmcpKTtcbiAgICAgIG5vZGUuaW5zZXJ0QWZ0ZXIobmV3TGlzdE5vZGUsIHJlc3RvcmVTZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCkge1xuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBjb25zdCBuZXh0U2libGluZyA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBzdXBlci5yZW1vdmUocHJlc2VydmVFbXB0eVBhcmVudCk7XG4gICAgaWYgKHByZXZTaWJsaW5nICYmIG5leHRTaWJsaW5nICYmIGlzTmVzdGVkTGlzdE5vZGUocHJldlNpYmxpbmcpICYmIGlzTmVzdGVkTGlzdE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICBtZXJnZUxpc3RzKHByZXZTaWJsaW5nLmdldEZpcnN0Q2hpbGQoKSwgbmV4dFNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpKTtcbiAgICAgIG5leHRTaWJsaW5nLnJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IG5ld0VsZW1lbnQgPSAkY3JlYXRlTGlzdEl0ZW1Ob2RlKCkudXBkYXRlRnJvbUpTT04odGhpcy5leHBvcnRKU09OKCkpLnNldENoZWNrZWQodGhpcy5nZXRDaGVja2VkKCkgPyBmYWxzZSA6IHVuZGVmaW5lZCk7XG4gICAgdGhpcy5pbnNlcnRBZnRlcihuZXdFbGVtZW50LCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoc2VsZWN0aW9uKSB7XG4gICAgY29uc3QgcGFyYWdyYXBoID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKTtcbiAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHBhcmFncmFwaC5hcHBlbmQoY2hpbGQpKTtcbiAgICBjb25zdCBsaXN0Tm9kZSA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGUuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGNvbnN0IGlzSW5kZW50ZWQgPSAkaXNMaXN0SXRlbU5vZGUobGlzdE5vZGVQYXJlbnQpO1xuICAgIGlmIChsaXN0Tm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgaWYgKGlzSW5kZW50ZWQpIHtcbiAgICAgICAgLy8gaWYgdGhlIGxpc3Qgbm9kZSBpcyBuZXN0ZWQsIHdlIGp1c3Qgd2FudCB0byByZW1vdmUgaXQsXG4gICAgICAgIC8vIGVmZmVjdGl2ZWx5IHVuaW5kZW50aW5nIGl0LlxuICAgICAgICBsaXN0Tm9kZS5yZW1vdmUoKTtcbiAgICAgICAgbGlzdE5vZGVQYXJlbnQuc2VsZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgICAgbGlzdE5vZGUucmVtb3ZlKCk7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgc2VsZWN0aW9uIG9uIHRoZSBsaXN0IGl0ZW0sIHdlJ2xsIG5lZWQgdG8gbW92ZSBpdFxuICAgICAgICAvLyB0byB0aGUgcGFyYWdyYXBoXG4gICAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3I7XG4gICAgICAgIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzO1xuICAgICAgICBjb25zdCBrZXkgPSBwYXJhZ3JhcGguZ2V0S2V5KCk7XG4gICAgICAgIGlmIChhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGFuY2hvci5nZXROb2RlKCkuaXModGhpcykpIHtcbiAgICAgICAgICBhbmNob3Iuc2V0KGtleSwgYW5jaG9yLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9jdXMudHlwZSA9PT0gJ2VsZW1lbnQnICYmIGZvY3VzLmdldE5vZGUoKS5pcyh0aGlzKSkge1xuICAgICAgICAgIGZvY3VzLnNldChrZXksIGZvY3VzLm9mZnNldCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0Tm9kZS5pbnNlcnRCZWZvcmUocGFyYWdyYXBoKTtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldFZhbHVlKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fdmFsdWU7XG4gIH1cbiAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX192YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldENoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0TGF0ZXN0KCk7XG4gICAgbGV0IGxpc3RUeXBlO1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3ROb2RlKHBhcmVudCkpIHtcbiAgICAgIGxpc3RUeXBlID0gcGFyZW50LmdldExpc3RUeXBlKCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IEJvb2xlYW4oc2VsZi5fX2NoZWNrZWQpIDogdW5kZWZpbmVkO1xuICB9XG4gIHNldENoZWNrZWQoY2hlY2tlZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2NoZWNrZWQgPSBjaGVja2VkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRvZ2dsZUNoZWNrZWQoKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICByZXR1cm4gc2VsZi5zZXRDaGVja2VkKCFzZWxmLl9fY2hlY2tlZCk7XG4gIH1cbiAgZ2V0SW5kZW50KCkge1xuICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwYXJlbnQsIHdlIGFyZSBsaWtlbHkgc2VyaWFsaXppbmdcbiAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdldFBhcmVudCgpO1xuICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgIXRoaXMuaXNBdHRhY2hlZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2luZGVudDtcbiAgICB9XG4gICAgLy8gTGlzdEl0ZW1Ob2RlIHNob3VsZCBhbHdheXMgaGF2ZSBhIExpc3ROb2RlIGZvciBhIHBhcmVudC5cbiAgICBsZXQgbGlzdE5vZGVQYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICAgIGxldCBpbmRlbnRMZXZlbCA9IDA7XG4gICAgd2hpbGUgKCRpc0xpc3RJdGVtTm9kZShsaXN0Tm9kZVBhcmVudCkpIHtcbiAgICAgIGxpc3ROb2RlUGFyZW50ID0gbGlzdE5vZGVQYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpLmdldFBhcmVudE9yVGhyb3coKTtcbiAgICAgIGluZGVudExldmVsKys7XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRMZXZlbDtcbiAgfVxuICBzZXRJbmRlbnQoaW5kZW50KSB7XG4gICAgaWYgKCEodHlwZW9mIGluZGVudCA9PT0gJ251bWJlcicpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEludmFsaWQgaW5kZW50IHZhbHVlLmApO1xuICAgIH1cbiAgICBpbmRlbnQgPSBNYXRoLmZsb29yKGluZGVudCk7XG4gICAgaWYgKCEoaW5kZW50ID49IDApKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEluZGVudCB2YWx1ZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZS5gKTtcbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbmRlbnQgPSB0aGlzLmdldEluZGVudCgpO1xuICAgIHdoaWxlIChjdXJyZW50SW5kZW50ICE9PSBpbmRlbnQpIHtcbiAgICAgIGlmIChjdXJyZW50SW5kZW50IDwgaW5kZW50KSB7XG4gICAgICAgICRoYW5kbGVJbmRlbnQodGhpcyk7XG4gICAgICAgIGN1cnJlbnRJbmRlbnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICRoYW5kbGVPdXRkZW50KHRoaXMpO1xuICAgICAgICBjdXJyZW50SW5kZW50LS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIEBkZXByZWNhdGVkIEBpbnRlcm5hbCAqL1xuICBjYW5JbnNlcnRBZnRlcihub2RlKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShub2RlKTtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBAaW50ZXJuYWwgKi9cbiAgY2FuUmVwbGFjZVdpdGgocmVwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gJGlzTGlzdEl0ZW1Ob2RlKHJlcGxhY2VtZW50KTtcbiAgfVxuICBjYW5NZXJnZVdpdGgobm9kZSkge1xuICAgIHJldHVybiAkaXNMaXN0SXRlbU5vZGUobm9kZSkgfHwgJGlzUGFyYWdyYXBoTm9kZShub2RlKTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24pIHtcbiAgICBpZiAoISRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yTm9kZSA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgIGNvbnN0IGZvY3VzTm9kZSA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNQYXJlbnRPZihhbmNob3JOb2RlKSAmJiB0aGlzLmlzUGFyZW50T2YoZm9jdXNOb2RlKSAmJiB0aGlzLmdldFRleHRDb250ZW50KCkubGVuZ3RoID09PSBzZWxlY3Rpb24uZ2V0VGV4dENvbnRlbnQoKS5sZW5ndGg7XG4gIH1cbiAgaXNQYXJlbnRSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjcmVhdGVQYXJlbnRFbGVtZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgfVxuICBjYW5NZXJnZVdoZW5FbXB0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gJHNldExpc3RJdGVtVGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGNvbnN0IGxpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lID8gbGlzdFRoZW1lLmxpc3RpdGVtIDogdW5kZWZpbmVkO1xuICBsZXQgbmVzdGVkTGlzdEl0ZW1DbGFzc05hbWU7XG4gIGlmIChsaXN0VGhlbWUgJiYgbGlzdFRoZW1lLm5lc3RlZCkge1xuICAgIG5lc3RlZExpc3RJdGVtQ2xhc3NOYW1lID0gbGlzdFRoZW1lLm5lc3RlZC5saXN0aXRlbTtcbiAgfVxuICBpZiAobGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNsYXNzZXNUb0FkZC5wdXNoKC4uLm5vcm1hbGl6ZUNsYXNzTmFtZXMobGlzdEl0ZW1DbGFzc05hbWUpKTtcbiAgfVxuICBpZiAobGlzdFRoZW1lKSB7XG4gICAgY29uc3QgcGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgY29uc3QgaXNDaGVja0xpc3QgPSAkaXNMaXN0Tm9kZShwYXJlbnROb2RlKSAmJiBwYXJlbnROb2RlLmdldExpc3RUeXBlKCkgPT09ICdjaGVjayc7XG4gICAgY29uc3QgY2hlY2tlZCA9IG5vZGUuZ2V0Q2hlY2tlZCgpO1xuICAgIGlmICghaXNDaGVja0xpc3QgfHwgY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtVW5jaGVja2VkKTtcbiAgICB9XG4gICAgaWYgKCFpc0NoZWNrTGlzdCB8fCAhY2hlY2tlZCkge1xuICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2gobGlzdFRoZW1lLmxpc3RpdGVtQ2hlY2tlZCk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrTGlzdCkge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tlZCA/IGxpc3RUaGVtZS5saXN0aXRlbUNoZWNrZWQgOiBsaXN0VGhlbWUubGlzdGl0ZW1VbmNoZWNrZWQpO1xuICAgIH1cbiAgfVxuICBpZiAobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5lc3RlZExpc3RJdGVtQ2xhc3NlcyA9IG5vcm1hbGl6ZUNsYXNzTmFtZXMobmVzdGVkTGlzdEl0ZW1DbGFzc05hbWUpO1xuICAgIGlmIChub2RlLmdldENoaWxkcmVuKCkuc29tZShjaGlsZCA9PiAkaXNMaXN0Tm9kZShjaGlsZCkpKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGFzc2VzVG9SZW1vdmUucHVzaCguLi5uZXN0ZWRMaXN0SXRlbUNsYXNzZXMpO1xuICAgIH1cbiAgfVxuICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9SZW1vdmUpO1xuICB9XG4gIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5jbGFzc2VzVG9BZGQpO1xuICB9XG59XG5mdW5jdGlvbiB1cGRhdGVMaXN0SXRlbUNoZWNrZWQoZG9tLCBsaXN0SXRlbU5vZGUsIHByZXZMaXN0SXRlbU5vZGUsIGxpc3ROb2RlKSB7XG4gIC8vIE9ubHkgYWRkIGF0dHJpYnV0ZXMgZm9yIGxlYWYgbGlzdCBpdGVtc1xuICBpZiAoJGlzTGlzdE5vZGUobGlzdEl0ZW1Ob2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgndGFiSW5kZXgnKTtcbiAgICBkb20ucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWNoZWNrZWQnKTtcbiAgfSBlbHNlIHtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdyb2xlJywgJ2NoZWNrYm94Jyk7XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgndGFiSW5kZXgnLCAnLTEnKTtcbiAgICBpZiAoIXByZXZMaXN0SXRlbU5vZGUgfHwgbGlzdEl0ZW1Ob2RlLl9fY2hlY2tlZCAhPT0gcHJldkxpc3RJdGVtTm9kZS5fX2NoZWNrZWQpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcsIGxpc3RJdGVtTm9kZS5nZXRDaGVja2VkKCkgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uICRjb252ZXJ0TGlzdEl0ZW1FbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNHaXRIdWJDaGVja0xpc3QgPSBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygndGFzay1saXN0LWl0ZW0nKTtcbiAgaWYgKGlzR2l0SHViQ2hlY2tMaXN0KSB7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBkb21Ob2RlLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoY2hpbGQudGFnTmFtZSA9PT0gJ0lOUFVUJykge1xuICAgICAgICByZXR1cm4gJGNvbnZlcnRDaGVja2JveElucHV0KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgYXJpYUNoZWNrZWRBdHRyID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpO1xuICBjb25zdCBjaGVja2VkID0gYXJpYUNoZWNrZWRBdHRyID09PSAndHJ1ZScgPyB0cnVlIDogYXJpYUNoZWNrZWRBdHRyID09PSAnZmFsc2UnID8gZmFsc2UgOiB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuZnVuY3Rpb24gJGNvbnZlcnRDaGVja2JveElucHV0KGRvbU5vZGUpIHtcbiAgY29uc3QgaXNDaGVja2JveElucHV0ID0gZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ2NoZWNrYm94JztcbiAgaWYgKCFpc0NoZWNrYm94SW5wdXQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbm9kZTogbnVsbFxuICAgIH07XG4gIH1cbiAgY29uc3QgY2hlY2tlZCA9IGRvbU5vZGUuaGFzQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gIHJldHVybiB7XG4gICAgbm9kZTogJGNyZWF0ZUxpc3RJdGVtTm9kZShjaGVja2VkKVxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTGlzdCBJdGVtIG5vZGUsIHBhc3NpbmcgdHJ1ZS9mYWxzZSB3aWxsIGNvbnZlcnQgaXQgdG8gYSBjaGVja2JveCBpbnB1dC5cbiAqIEBwYXJhbSBjaGVja2VkIC0gSXMgdGhlIExpc3QgSXRlbSBhIGNoZWNrYm94IGFuZCwgaWYgc28sIGlzIGl0IGNoZWNrZWQ/IHVuZGVmaW5lZC9udWxsOiBub3QgYSBjaGVja2JveCwgdHJ1ZS9mYWxzZSBpcyBhIGNoZWNrYm94IGFuZCBjaGVja2VkL3VuY2hlY2tlZCwgcmVzcGVjdGl2ZWx5LlxuICogQHJldHVybnMgVGhlIG5ldyBMaXN0IEl0ZW0uXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0SXRlbU5vZGUoY2hlY2tlZCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaXN0SXRlbU5vZGUodW5kZWZpbmVkLCBjaGVja2VkKSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3RJdGVtTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgdGhlIG5vZGUgaXMgYSBMaXN0SXRlbU5vZGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0SXRlbU5vZGU7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpc3ROb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG4gICRjb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29uZmlnKCdsaXN0Jywge1xuICAgICAgJHRyYW5zZm9ybTogbm9kZSA9PiB7XG4gICAgICAgIG1lcmdlTmV4dFNpYmxpbmdMaXN0SWZTYW1lVHlwZShub2RlKTtcbiAgICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKG5vZGUpO1xuICAgICAgfSxcbiAgICAgIGV4dGVuZHM6IEVsZW1lbnROb2RlLFxuICAgICAgaW1wb3J0RE9NOiBidWlsZEltcG9ydE1hcCh7XG4gICAgICAgIG9sOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIHVsOiAoKSA9PiAoe1xuICAgICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0TGlzdE5vZGUsXG4gICAgICAgICAgcHJpb3JpdHk6IDBcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgY29uc3RydWN0b3IobGlzdFR5cGUgPSAnbnVtYmVyJywgc3RhcnQgPSAxLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIGNvbnN0IF9saXN0VHlwZSA9IFRBR19UT19MSVNUX1RZUEVbbGlzdFR5cGVdIHx8IGxpc3RUeXBlO1xuICAgIHRoaXMuX19saXN0VHlwZSA9IF9saXN0VHlwZTtcbiAgICB0aGlzLl9fdGFnID0gX2xpc3RUeXBlID09PSAnbnVtYmVyJyA/ICdvbCcgOiAndWwnO1xuICAgIHRoaXMuX19zdGFydCA9IHN0YXJ0O1xuICB9XG4gIGFmdGVyQ2xvbmVGcm9tKHByZXZOb2RlKSB7XG4gICAgc3VwZXIuYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpO1xuICAgIHRoaXMuX19saXN0VHlwZSA9IHByZXZOb2RlLl9fbGlzdFR5cGU7XG4gICAgdGhpcy5fX3RhZyA9IHByZXZOb2RlLl9fdGFnO1xuICAgIHRoaXMuX19zdGFydCA9IHByZXZOb2RlLl9fc3RhcnQ7XG4gIH1cbiAgZ2V0VGFnKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fdGFnO1xuICB9XG4gIHNldExpc3RUeXBlKHR5cGUpIHtcbiAgICBjb25zdCB3cml0YWJsZSA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICB3cml0YWJsZS5fX2xpc3RUeXBlID0gdHlwZTtcbiAgICB3cml0YWJsZS5fX3RhZyA9IHR5cGUgPT09ICdudW1iZXInID8gJ29sJyA6ICd1bCc7XG4gICAgcmV0dXJuIHdyaXRhYmxlO1xuICB9XG4gIGdldExpc3RUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fbGlzdFR5cGU7XG4gIH1cbiAgZ2V0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19zdGFydDtcbiAgfVxuICBzZXRTdGFydChzdGFydCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3N0YXJ0ID0gc3RhcnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cblxuICAvLyBWaWV3XG5cbiAgY3JlYXRlRE9NKGNvbmZpZywgX2VkaXRvcikge1xuICAgIGNvbnN0IHRhZyA9IHRoaXMuX190YWc7XG4gICAgY29uc3QgZG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmICh0aGlzLl9fc3RhcnQgIT09IDEpIHtcbiAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoJ3N0YXJ0JywgU3RyaW5nKHRoaXMuX19zdGFydCkpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIEludGVybmFsIGZpZWxkLlxuICAgIGRvbS5fX2xleGljYWxMaXN0VHlwZSA9IHRoaXMuX19saXN0VHlwZTtcbiAgICAkc2V0TGlzdFRoZW1lQ2xhc3NOYW1lcyhkb20sIGNvbmZpZy50aGVtZSwgdGhpcyk7XG4gICAgcmV0dXJuIGRvbTtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGRvbSwgY29uZmlnKSB7XG4gICAgaWYgKHByZXZOb2RlLl9fdGFnICE9PSB0aGlzLl9fdGFnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgJHNldExpc3RUaGVtZUNsYXNzTmFtZXMoZG9tLCBjb25maWcudGhlbWUsIHRoaXMpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB1cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSkuc2V0TGlzdFR5cGUoc2VyaWFsaXplZE5vZGUubGlzdFR5cGUpLnNldFN0YXJ0KHNlcmlhbGl6ZWROb2RlLnN0YXJ0KTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY3JlYXRlRE9NKGVkaXRvci5fY29uZmlnLCBlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICBpZiAodGhpcy5fX3N0YXJ0ICE9PSAxKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdGFydCcsIFN0cmluZyh0aGlzLl9fc3RhcnQpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fbGlzdFR5cGUgPT09ICdjaGVjaycpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbExpc3RUeXBlJywgJ2NoZWNrJyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICBsaXN0VHlwZTogdGhpcy5nZXRMaXN0VHlwZSgpLFxuICAgICAgc3RhcnQ6IHRoaXMuZ2V0U3RhcnQoKSxcbiAgICAgIHRhZzogdGhpcy5nZXRUYWcoKVxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCBub2Rlc1RvSW5zZXJ0KSB7XG4gICAgbGV0IGxpc3RJdGVtTm9kZXNUb0luc2VydCA9IG5vZGVzVG9JbnNlcnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlc1RvSW5zZXJ0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNUb0luc2VydFtpXTtcbiAgICAgIGlmICghJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpKSB7XG4gICAgICAgIGlmIChsaXN0SXRlbU5vZGVzVG9JbnNlcnQgPT09IG5vZGVzVG9JbnNlcnQpIHtcbiAgICAgICAgICBsaXN0SXRlbU5vZGVzVG9JbnNlcnQgPSBbLi4ubm9kZXNUb0luc2VydF07XG4gICAgICAgIH1cbiAgICAgICAgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0W2ldID0gJGNyZWF0ZUxpc3RJdGVtTm9kZSgpLmFwcGVuZCgkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhKCRpc0xpc3ROb2RlKG5vZGUpIHx8IG5vZGUuaXNJbmxpbmUoKSkgPyAkY3JlYXRlVGV4dE5vZGUobm9kZS5nZXRUZXh0Q29udGVudCgpKSA6IG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgbGlzdEl0ZW1Ob2Rlc1RvSW5zZXJ0KTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkKSB7XG4gICAgcmV0dXJuICRpc0xpc3RJdGVtTm9kZShjaGlsZCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRzZXRMaXN0VGhlbWVDbGFzc05hbWVzKGRvbSwgZWRpdG9yVGhlbWVDbGFzc2VzLCBub2RlKSB7XG4gIGNvbnN0IGNsYXNzZXNUb0FkZCA9IFtdO1xuICBjb25zdCBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgY29uc3QgbGlzdFRoZW1lID0gZWRpdG9yVGhlbWVDbGFzc2VzLmxpc3Q7XG4gIGlmIChsaXN0VGhlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGxpc3RMZXZlbHNDbGFzc05hbWVzID0gbGlzdFRoZW1lW2Ake25vZGUuX190YWd9RGVwdGhgXSB8fCBbXTtcbiAgICBjb25zdCBsaXN0RGVwdGggPSAkZ2V0TGlzdERlcHRoKG5vZGUpIC0gMTtcbiAgICBjb25zdCBub3JtYWxpemVkTGlzdERlcHRoID0gbGlzdERlcHRoICUgbGlzdExldmVsc0NsYXNzTmFtZXMubGVuZ3RoO1xuICAgIGNvbnN0IGxpc3RMZXZlbENsYXNzTmFtZSA9IGxpc3RMZXZlbHNDbGFzc05hbWVzW25vcm1hbGl6ZWRMaXN0RGVwdGhdO1xuICAgIGNvbnN0IGxpc3RDbGFzc05hbWUgPSBsaXN0VGhlbWVbbm9kZS5fX3RhZ107XG4gICAgbGV0IG5lc3RlZExpc3RDbGFzc05hbWU7XG4gICAgY29uc3QgbmVzdGVkTGlzdFRoZW1lID0gbGlzdFRoZW1lLm5lc3RlZDtcbiAgICBjb25zdCBjaGVja2xpc3RDbGFzc05hbWUgPSBsaXN0VGhlbWUuY2hlY2tsaXN0O1xuICAgIGlmIChuZXN0ZWRMaXN0VGhlbWUgIT09IHVuZGVmaW5lZCAmJiBuZXN0ZWRMaXN0VGhlbWUubGlzdCkge1xuICAgICAgbmVzdGVkTGlzdENsYXNzTmFtZSA9IG5lc3RlZExpc3RUaGVtZS5saXN0O1xuICAgIH1cbiAgICBpZiAobGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaChsaXN0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKGNoZWNrbGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkICYmIG5vZGUuX19saXN0VHlwZSA9PT0gJ2NoZWNrJykge1xuICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goY2hlY2tsaXN0Q2xhc3NOYW1lKTtcbiAgICB9XG4gICAgaWYgKGxpc3RMZXZlbENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjbGFzc2VzVG9BZGQucHVzaCguLi5ub3JtYWxpemVDbGFzc05hbWVzKGxpc3RMZXZlbENsYXNzTmFtZSkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0TGV2ZWxzQ2xhc3NOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gbm9ybWFsaXplZExpc3REZXB0aCkge1xuICAgICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKG5vZGUuX190YWcgKyBpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVzdGVkTGlzdENsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBuZXN0ZWRMaXN0SXRlbUNsYXNzZXMgPSBub3JtYWxpemVDbGFzc05hbWVzKG5lc3RlZExpc3RDbGFzc05hbWUpO1xuICAgICAgaWYgKGxpc3REZXB0aCA+IDEpIHtcbiAgICAgICAgY2xhc3Nlc1RvQWRkLnB1c2goLi4ubmVzdGVkTGlzdEl0ZW1DbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKC4uLm5lc3RlZExpc3RJdGVtQ2xhc3Nlcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChjbGFzc2VzVG9SZW1vdmUubGVuZ3RoID4gMCkge1xuICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb1JlbW92ZSk7XG4gIH1cbiAgaWYgKGNsYXNzZXNUb0FkZC5sZW5ndGggPiAwKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIC4uLmNsYXNzZXNUb0FkZCk7XG4gIH1cbn1cblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gbm9ybWFsaXplcyB0aGUgY2hpbGRyZW4gb2YgYSBMaXN0Tm9kZSBhZnRlciB0aGUgY29udmVyc2lvbiBmcm9tIEhUTUwsXG4gKiBlbnN1cmluZyB0aGF0IHRoZXkgYXJlIGFsbCBMaXN0SXRlbU5vZGVzIGFuZCBjb250YWluIGVpdGhlciBhIHNpbmdsZSBuZXN0ZWQgTGlzdE5vZGVcbiAqIG9yIHNvbWUgb3RoZXIgaW5saW5lIGNvbnRlbnQuXG4gKi9cbmZ1bmN0aW9uICRub3JtYWxpemVDaGlsZHJlbihub2Rlcykge1xuICBjb25zdCBub3JtYWxpemVkTGlzdEl0ZW1zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShub2RlKSkge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKG5vZGUpO1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBub3JtYWxpemVkTGlzdEl0ZW1zLnB1c2goJHdyYXBJbkxpc3RJdGVtKGNoaWxkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9ybWFsaXplZExpc3RJdGVtcy5wdXNoKCR3cmFwSW5MaXN0SXRlbShub2RlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemVkTGlzdEl0ZW1zO1xufVxuZnVuY3Rpb24gaXNEb21DaGVja2xpc3QoZG9tTm9kZSkge1xuICBpZiAoZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ19fbGV4aWNhbGxpc3R0eXBlJykgPT09ICdjaGVjaycgfHxcbiAgLy8gaXMgZ2l0aHViIGNoZWNrbGlzdFxuICBkb21Ob2RlLmNsYXNzTGlzdC5jb250YWlucygnY29udGFpbnMtdGFzay1saXN0JykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBpZiBjaGlsZHJlbiBhcmUgY2hlY2tsaXN0IGl0ZW1zLCB0aGUgbm9kZSBpcyBhIGNoZWNrbGlzdCB1bC4gQXBwbGljYWJsZSBmb3IgZ29vZ2xlZG9jIGNoZWNrbGlzdCBwYXN0aW5nLlxuICBmb3IgKGNvbnN0IGNoaWxkIG9mIGRvbU5vZGUuY2hpbGROb2Rlcykge1xuICAgIGlmIChpc0hUTUxFbGVtZW50KGNoaWxkKSAmJiBjaGlsZC5oYXNBdHRyaWJ1dGUoJ2FyaWEtY2hlY2tlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRMaXN0Tm9kZShkb21Ob2RlKSB7XG4gIGNvbnN0IG5vZGVOYW1lID0gZG9tTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgbm9kZSA9IG51bGw7XG4gIGlmIChub2RlTmFtZSA9PT0gJ29sJykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdGFydCA9IGRvbU5vZGUuc3RhcnQ7XG4gICAgbm9kZSA9ICRjcmVhdGVMaXN0Tm9kZSgnbnVtYmVyJywgc3RhcnQpO1xuICB9IGVsc2UgaWYgKG5vZGVOYW1lID09PSAndWwnKSB7XG4gICAgaWYgKGlzRG9tQ2hlY2tsaXN0KGRvbU5vZGUpKSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdjaGVjaycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gJGNyZWF0ZUxpc3ROb2RlKCdidWxsZXQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogJG5vcm1hbGl6ZUNoaWxkcmVuLFxuICAgIG5vZGVcbiAgfTtcbn1cbmNvbnN0IFRBR19UT19MSVNUX1RZUEUgPSB7XG4gIG9sOiAnbnVtYmVyJyxcbiAgdWw6ICdidWxsZXQnXG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBMaXN0Tm9kZSBvZiBsaXN0VHlwZS5cbiAqIEBwYXJhbSBsaXN0VHlwZSAtIFRoZSB0eXBlIG9mIGxpc3QgdG8gYmUgY3JlYXRlZC4gQ2FuIGJlICdudW1iZXInLCAnYnVsbGV0Jywgb3IgJ2NoZWNrJy5cbiAqIEBwYXJhbSBzdGFydCAtIFdoZXJlIGFuIG9yZGVyZWQgbGlzdCBzdGFydHMgaXRzIGNvdW50LCBzdGFydCA9IDEgaWYgbGVmdCB1bmRlZmluZWQuXG4gKiBAcmV0dXJucyBUaGUgbmV3IExpc3ROb2RlXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaXN0Tm9kZShsaXN0VHlwZSA9ICdudW1iZXInLCBzdGFydCA9IDEpIHtcbiAgcmV0dXJuICRhcHBseU5vZGVSZXBsYWNlbWVudChuZXcgTGlzdE5vZGUobGlzdFR5cGUsIHN0YXJ0KSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiB0aGUgbm9kZSBpcyBhIExpc3ROb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgbm9kZSBpcyBhIExpc3ROb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0xpc3ROb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaXN0Tm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBJTlNFUlRfQ0hFQ0tfTElTVF9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCcpO1xuZnVuY3Rpb24gcmVnaXN0ZXJDaGVja0xpc3QoZWRpdG9yKSB7XG4gIHJldHVybiBtZXJnZVJlZ2lzdGVyKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX0NIRUNLX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdjaGVjaycpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIHJldHVybiBoYW5kbGVBcnJvd1VwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGZhbHNlKTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9BUlJPV19VUF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGhhbmRsZUFycm93VXBPckRvd24oZXZlbnQsIGVkaXRvciwgdHJ1ZSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfRVNDQVBFX0NPTU1BTkQsICgpID0+IHtcbiAgICBjb25zdCBhY3RpdmVJdGVtID0gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpO1xuICAgIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gZWRpdG9yLmdldFJvb3RFbGVtZW50KCk7XG4gICAgICBpZiAocm9vdEVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICByb290RWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9TUEFDRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3QgYWN0aXZlSXRlbSA9IGdldEFjdGl2ZUNoZWNrTGlzdEl0ZW0oKTtcbiAgICBpZiAoYWN0aXZlSXRlbSAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgICBjb25zdCBsaXN0SXRlbU5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShhY3RpdmVJdGVtKTtcbiAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbU5vZGUpKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBsaXN0SXRlbU5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChLRVlfQVJST1dfTEVGVF9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgcmV0dXJuIGVkaXRvci5nZXRFZGl0b3JTdGF0ZSgpLnJlYWQoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFuY2hvclxuICAgICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0VsZW1lbnQgPSBhbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnO1xuICAgICAgICBpZiAoaXNFbGVtZW50IHx8IGFuY2hvci5vZmZzZXQgPT09IDApIHtcbiAgICAgICAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBlbGVtZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoYW5jaG9yTm9kZSwgbm9kZSA9PiAkaXNFbGVtZW50Tm9kZShub2RlKSAmJiAhbm9kZS5pc0lubGluZSgpKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGVsZW1lbnROb2RlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gZWxlbWVudE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUocGFyZW50KSAmJiBwYXJlbnQuZ2V0TGlzdFR5cGUoKSA9PT0gJ2NoZWNrJyAmJiAoaXNFbGVtZW50IHx8IGVsZW1lbnROb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpID09PSBhbmNob3JOb2RlKSkge1xuICAgICAgICAgICAgICBjb25zdCBkb21Ob2RlID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShlbGVtZW50Tm9kZS5fX2tleSk7XG4gICAgICAgICAgICAgIGlmIChkb21Ob2RlICE9IG51bGwgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyUm9vdExpc3RlbmVyKChyb290RWxlbWVudCwgcHJldkVsZW1lbnQpID0+IHtcbiAgICBpZiAocm9vdEVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJvb3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgcm9vdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcmRvd24nLCBoYW5kbGVQb2ludGVyRG93bik7XG4gICAgfVxuICAgIGlmIChwcmV2RWxlbWVudCAhPT0gbnVsbCkge1xuICAgICAgcHJldkVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICBwcmV2RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICB9XG4gIH0pKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCBjYWxsYmFjaykge1xuICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gIGlmICghaXNIVE1MRWxlbWVudCh0YXJnZXQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWdub3JlIGNsaWNrcyBvbiBMSSB0aGF0IGhhdmUgbmVzdGVkIGxpc3RzXG4gIGNvbnN0IGZpcnN0Q2hpbGQgPSB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgaWYgKGlzSFRNTEVsZW1lbnQoZmlyc3RDaGlsZCkgJiYgKGZpcnN0Q2hpbGQudGFnTmFtZSA9PT0gJ1VMJyB8fCBmaXJzdENoaWxkLnRhZ05hbWUgPT09ICdPTCcpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXQucGFyZW50Tm9kZTtcblxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGlmICghcGFyZW50Tm9kZSB8fCBwYXJlbnROb2RlLl9fbGV4aWNhbExpc3RUeXBlICE9PSAnY2hlY2snKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlY3QgPSB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHpvb20gPSBjYWxjdWxhdGVab29tTGV2ZWwodGFyZ2V0KTtcbiAgY29uc3QgY2xpZW50WCA9IGV2ZW50LmNsaWVudFggLyB6b29tO1xuXG4gIC8vIFVzZSBnZXRDb21wdXRlZFN0eWxlIGlmIGF2YWlsYWJsZSwgb3RoZXJ3aXNlIGZhbGxiYWNrIHRvIDBweCB3aWR0aFxuICBjb25zdCBiZWZvcmVTdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCwgJzo6YmVmb3JlJykgOiB7XG4gICAgd2lkdGg6ICcwcHgnXG4gIH07XG4gIGNvbnN0IGJlZm9yZVdpZHRoSW5QaXhlbHMgPSBwYXJzZUZsb2F0KGJlZm9yZVN0eWxlcy53aWR0aCk7XG5cbiAgLy8gTWFrZSBjbGljayBhcmVhIHNsaWdodGx5IGxhcmdlciBmb3IgdG91Y2ggZGV2aWNlcyB0byBpbXByb3ZlIGFjY2Vzc2liaWxpdHlcbiAgY29uc3QgaXNUb3VjaEV2ZW50ID0gZXZlbnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCc7XG4gIGNvbnN0IGNsaWNrQXJlYVBhZGRpbmcgPSBpc1RvdWNoRXZlbnQgPyAzMiA6IDA7IC8vIEFkZCAzMnB4IHBhZGRpbmcgZm9yIHRvdWNoIGV2ZW50c1xuXG4gIGlmICh0YXJnZXQuZGlyID09PSAncnRsJyA/IGNsaWVudFggPCByZWN0LnJpZ2h0ICsgY2xpY2tBcmVhUGFkZGluZyAmJiBjbGllbnRYID4gcmVjdC5yaWdodCAtIGJlZm9yZVdpZHRoSW5QaXhlbHMgLSBjbGlja0FyZWFQYWRkaW5nIDogY2xpZW50WCA+IHJlY3QubGVmdCAtIGNsaWNrQXJlYVBhZGRpbmcgJiYgY2xpZW50WCA8IHJlY3QubGVmdCArIGJlZm9yZVdpZHRoSW5QaXhlbHMgKyBjbGlja0FyZWFQYWRkaW5nKSB7XG4gICAgY2FsbGJhY2soKTtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgaGFuZGxlQ2hlY2tJdGVtRXZlbnQoZXZlbnQsICgpID0+IHtcbiAgICBpZiAoaXNIVE1MRWxlbWVudChldmVudC50YXJnZXQpKSB7XG4gICAgICBjb25zdCBkb21Ob2RlID0gZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgZWRpdG9yID0gZ2V0TmVhcmVzdEVkaXRvckZyb21ET01Ob2RlKGRvbU5vZGUpO1xuICAgICAgaWYgKGVkaXRvciAhPSBudWxsICYmIGVkaXRvci5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbU5vZGUpO1xuICAgICAgICAgIGlmICgkaXNMaXN0SXRlbU5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGRvbU5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgIG5vZGUudG9nZ2xlQ2hlY2tlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKGV2ZW50KSB7XG4gIGhhbmRsZUNoZWNrSXRlbUV2ZW50KGV2ZW50LCAoKSA9PiB7XG4gICAgLy8gUHJldmVudHMgY2FyZXQgbW92aW5nIHdoZW4gY2xpY2tpbmcgb24gY2hlY2sgbWFya1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWN0aXZlQ2hlY2tMaXN0SXRlbSgpIHtcbiAgY29uc3QgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGFjdGl2ZUVsZW1lbnQpICYmIGFjdGl2ZUVsZW1lbnQudGFnTmFtZSA9PT0gJ0xJJyAmJiBhY3RpdmVFbGVtZW50LnBhcmVudE5vZGUgIT0gbnVsbCAmJlxuICAvLyBAdHMtaWdub3JlIGludGVybmFsIGZpZWxkXG4gIGFjdGl2ZUVsZW1lbnQucGFyZW50Tm9kZS5fX2xleGljYWxMaXN0VHlwZSA9PT0gJ2NoZWNrJyA/IGFjdGl2ZUVsZW1lbnQgOiBudWxsO1xufVxuZnVuY3Rpb24gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKG5vZGUsIGJhY2t3YXJkKSB7XG4gIGxldCBzaWJsaW5nID0gYmFja3dhcmQgPyBub2RlLmdldFByZXZpb3VzU2libGluZygpIDogbm9kZS5nZXROZXh0U2libGluZygpO1xuICBsZXQgcGFyZW50ID0gbm9kZTtcblxuICAvLyBHb2luZyB1cCBpbiBhIHRyZWUgdG8gZ2V0IG5vbi1udWxsIHNpYmxpbmdcbiAgd2hpbGUgKHNpYmxpbmcgPT0gbnVsbCAmJiAkaXNMaXN0SXRlbU5vZGUocGFyZW50KSkge1xuICAgIC8vIEdldCBsaSAtPiBwYXJlbnQgdWwvb2wgLT4gcGFyZW50IGxpXG4gICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudE9yVGhyb3coKS5nZXRQYXJlbnQoKTtcbiAgICBpZiAocGFyZW50ICE9IG51bGwpIHtcbiAgICAgIHNpYmxpbmcgPSBiYWNrd2FyZCA/IHBhcmVudC5nZXRQcmV2aW91c1NpYmxpbmcoKSA6IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdvaW5nIGRvd24gaW4gYSB0cmVlIHRvIGdldCBmaXJzdCBub24tbmVzdGVkIGxpc3QgaXRlbVxuICB3aGlsZSAoJGlzTGlzdEl0ZW1Ob2RlKHNpYmxpbmcpKSB7XG4gICAgY29uc3QgZmlyc3RDaGlsZCA9IGJhY2t3YXJkID8gc2libGluZy5nZXRMYXN0Q2hpbGQoKSA6IHNpYmxpbmcuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgIHJldHVybiBzaWJsaW5nO1xuICAgIH1cbiAgICBzaWJsaW5nID0gYmFja3dhcmQgPyBmaXJzdENoaWxkLmdldExhc3RDaGlsZCgpIDogZmlyc3RDaGlsZC5nZXRGaXJzdENoaWxkKCk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBoYW5kbGVBcnJvd1VwT3JEb3duKGV2ZW50LCBlZGl0b3IsIGJhY2t3YXJkKSB7XG4gIGNvbnN0IGFjdGl2ZUl0ZW0gPSBnZXRBY3RpdmVDaGVja0xpc3RJdGVtKCk7XG4gIGlmIChhY3RpdmVJdGVtICE9IG51bGwpIHtcbiAgICBlZGl0b3IudXBkYXRlKCgpID0+IHtcbiAgICAgIGNvbnN0IGxpc3RJdGVtID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoYWN0aXZlSXRlbSk7XG4gICAgICBpZiAoISRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgbmV4dExpc3RJdGVtID0gZmluZENoZWNrTGlzdEl0ZW1TaWJsaW5nKGxpc3RJdGVtLCBiYWNrd2FyZCk7XG4gICAgICBpZiAobmV4dExpc3RJdGVtICE9IG51bGwpIHtcbiAgICAgICAgbmV4dExpc3RJdGVtLnNlbGVjdFN0YXJ0KCk7XG4gICAgICAgIGNvbnN0IGRvbSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkobmV4dExpc3RJdGVtLl9fa2V5KTtcbiAgICAgICAgaWYgKGRvbSAhPSBudWxsKSB7XG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGRvbS5mb2N1cygpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdVUERBVEVfTElTVF9TVEFSVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCA9IGNyZWF0ZUNvbW1hbmQoJ0lOU0VSVF9VTk9SREVSRURfTElTVF9DT01NQU5EJyk7XG5jb25zdCBJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdJTlNFUlRfT1JERVJFRF9MSVNUX0NPTU1BTkQnKTtcbmNvbnN0IFJFTU9WRV9MSVNUX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdSRU1PVkVfTElTVF9DT01NQU5EJyk7XG5mdW5jdGlvbiByZWdpc3Rlckxpc3QoZWRpdG9yKSB7XG4gIGNvbnN0IHJlbW92ZUxpc3RlbmVyID0gbWVyZ2VSZWdpc3RlcihlZGl0b3IucmVnaXN0ZXJDb21tYW5kKElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdudW1iZXInKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGxpc3ROb2RlS2V5LFxuICAgICAgbmV3U3RhcnRcbiAgICB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCBsaXN0Tm9kZSA9ICRnZXROb2RlQnlLZXkobGlzdE5vZGVLZXkpO1xuICAgIGlmICghJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsaXN0Tm9kZS5nZXRMaXN0VHlwZSgpID09PSAnbnVtYmVyJykge1xuICAgICAgbGlzdE5vZGUuc2V0U3RhcnQobmV3U3RhcnQpO1xuICAgICAgdXBkYXRlQ2hpbGRyZW5MaXN0SXRlbVZhbHVlKGxpc3ROb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfTE9XKSwgZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVU5PUkRFUkVEX0xJU1RfQ09NTUFORCwgKCkgPT4ge1xuICAgICRpbnNlcnRMaXN0KCdidWxsZXQnKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9MT1cpLCBlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFJFTU9WRV9MSVNUX0NPTU1BTkQsICgpID0+IHtcbiAgICAkcmVtb3ZlTGlzdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiAkaGFuZGxlTGlzdEluc2VydFBhcmFncmFwaCgpLCBDT01NQU5EX1BSSU9SSVRZX0xPVyksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oTGlzdEl0ZW1Ob2RlLCBub2RlID0+IHtcbiAgICBjb25zdCBmaXJzdENoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgIGlmICgkaXNUZXh0Tm9kZShmaXJzdENoaWxkKSkge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGZpcnN0Q2hpbGQuZ2V0U3R5bGUoKTtcbiAgICAgICAgY29uc3QgZm9ybWF0ID0gZmlyc3RDaGlsZC5nZXRGb3JtYXQoKTtcbiAgICAgICAgaWYgKG5vZGUuZ2V0VGV4dFN0eWxlKCkgIT09IHN0eWxlKSB7XG4gICAgICAgICAgbm9kZS5zZXRUZXh0U3R5bGUoc3R5bGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmdldFRleHRGb3JtYXQoKSAhPT0gZm9ybWF0KSB7XG4gICAgICAgICAgbm9kZS5zZXRUZXh0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgaXQncyBlbXB0eSwgY2hlY2sgdGhlIHNlbGVjdGlvblxuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgKHNlbGVjdGlvbi5zdHlsZSAhPT0gbm9kZS5nZXRUZXh0U3R5bGUoKSB8fCBzZWxlY3Rpb24uZm9ybWF0ICE9PSBub2RlLmdldFRleHRGb3JtYXQoKSkgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgbm9kZS5pcyhzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkpIHtcbiAgICAgICAgbm9kZS5zZXRUZXh0U3R5bGUoc2VsZWN0aW9uLnN0eWxlKS5zZXRUZXh0Rm9ybWF0KHNlbGVjdGlvbi5mb3JtYXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGV4dE5vZGUsIG5vZGUgPT4ge1xuICAgIGNvbnN0IGxpc3RJdGVtUGFyZW50Tm9kZSA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCRpc0xpc3RJdGVtTm9kZShsaXN0SXRlbVBhcmVudE5vZGUpICYmIG5vZGUuaXMobGlzdEl0ZW1QYXJlbnROb2RlLmdldEZpcnN0Q2hpbGQoKSkpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gbm9kZS5nZXRTdHlsZSgpO1xuICAgICAgY29uc3QgZm9ybWF0ID0gbm9kZS5nZXRGb3JtYXQoKTtcbiAgICAgIGlmIChzdHlsZSAhPT0gbGlzdEl0ZW1QYXJlbnROb2RlLmdldFRleHRTdHlsZSgpIHx8IGZvcm1hdCAhPT0gbGlzdEl0ZW1QYXJlbnROb2RlLmdldFRleHRGb3JtYXQoKSkge1xuICAgICAgICBsaXN0SXRlbVBhcmVudE5vZGUuc2V0VGV4dFN0eWxlKHN0eWxlKS5zZXRUZXh0Rm9ybWF0KGZvcm1hdCk7XG4gICAgICB9XG4gICAgfVxuICB9KSk7XG4gIHJldHVybiByZW1vdmVMaXN0ZW5lcjtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyTGlzdFN0cmljdEluZGVudFRyYW5zZm9ybShlZGl0b3IpIHtcbiAgY29uc3QgJGZvcm1hdExpc3RJbmRlbnRTdHJpY3QgPSBsaXN0SXRlbU5vZGUgPT4ge1xuICAgIGNvbnN0IGxpc3ROb2RlID0gbGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICAgIGlmICgkaXNMaXN0Tm9kZShsaXN0SXRlbU5vZGUuZ2V0Rmlyc3RDaGlsZCgpKSB8fCAhJGlzTGlzdE5vZGUobGlzdE5vZGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChsaXN0SXRlbU5vZGUsIG5vZGUgPT4gJGlzTGlzdEl0ZW1Ob2RlKG5vZGUpICYmICRpc0xpc3ROb2RlKG5vZGUuZ2V0UGFyZW50KCkpICYmICRpc0xpc3RJdGVtTm9kZShub2RlLmdldFByZXZpb3VzU2libGluZygpKSk7XG4gICAgaWYgKHN0YXJ0aW5nTGlzdEl0ZW1Ob2RlID09PSBudWxsICYmIGxpc3RJdGVtTm9kZS5nZXRJbmRlbnQoKSA+IDApIHtcbiAgICAgIGxpc3RJdGVtTm9kZS5zZXRJbmRlbnQoMCk7XG4gICAgfSBlbHNlIGlmICgkaXNMaXN0SXRlbU5vZGUoc3RhcnRpbmdMaXN0SXRlbU5vZGUpKSB7XG4gICAgICBjb25zdCBwcmV2TGlzdEl0ZW1Ob2RlID0gc3RhcnRpbmdMaXN0SXRlbU5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKHByZXZMaXN0SXRlbU5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGVuZExpc3RJdGVtTm9kZSA9ICRmaW5kQ2hpbGRyZW5FbmRMaXN0SXRlbU5vZGUocHJldkxpc3RJdGVtTm9kZSk7XG4gICAgICAgIGNvbnN0IGVuZExpc3ROb2RlID0gZW5kTGlzdEl0ZW1Ob2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZW5kTGlzdE5vZGUpKSB7XG4gICAgICAgICAgY29uc3QgcHJldkRlcHRoID0gJGdldExpc3REZXB0aChlbmRMaXN0Tm9kZSk7XG4gICAgICAgICAgY29uc3QgZGVwdGggPSAkZ2V0TGlzdERlcHRoKGxpc3ROb2RlKTtcbiAgICAgICAgICBpZiAocHJldkRlcHRoICsgMSA8IGRlcHRoKSB7XG4gICAgICAgICAgICBsaXN0SXRlbU5vZGUuc2V0SW5kZW50KHByZXZEZXB0aCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCAkcHJvY2Vzc0xpc3RXaXRoU3RyaWN0SW5kZW50ID0gbGlzdE5vZGUgPT4ge1xuICAgIGNvbnN0IHF1ZXVlID0gW2xpc3ROb2RlXTtcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICBpZiAoISRpc0xpc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBub2RlLmdldENoaWxkcmVuKCkpIHtcbiAgICAgICAgaWYgKCRpc0xpc3RJdGVtTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICAkZm9ybWF0TGlzdEluZGVudFN0cmljdChjaGlsZCk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDaGlsZCA9IGNoaWxkLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICBpZiAoJGlzTGlzdE5vZGUoZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICByZXR1cm4gZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShMaXN0Tm9kZSwgJHByb2Nlc3NMaXN0V2l0aFN0cmljdEluZGVudCk7XG59XG5mdW5jdGlvbiAkZmluZENoaWxkcmVuRW5kTGlzdEl0ZW1Ob2RlKGxpc3RJdGVtTm9kZSkge1xuICBsZXQgY3VycmVudCA9IGxpc3RJdGVtTm9kZTtcbiAgbGV0IGZpcnN0Q2hpbGQgPSBjdXJyZW50LmdldEZpcnN0Q2hpbGQoKTtcbiAgd2hpbGUgKCRpc0xpc3ROb2RlKGZpcnN0Q2hpbGQpKSB7XG4gICAgY29uc3QgbGFzdENoaWxkID0gZmlyc3RDaGlsZC5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoJGlzTGlzdEl0ZW1Ob2RlKGxhc3RDaGlsZCkpIHtcbiAgICAgIGN1cnJlbnQgPSBsYXN0Q2hpbGQ7XG4gICAgICBmaXJzdENoaWxkID0gY3VycmVudC5nZXRGaXJzdENoaWxkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3VycmVudDtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2Uge0BsaW5rICRpbnNlcnRMaXN0fSBmcm9tIGFuIHVwZGF0ZSBvciBjb21tYW5kIGxpc3RlbmVyLlxuICpcbiAqIEluc2VydHMgYSBuZXcgTGlzdE5vZGUuIElmIHRoZSBzZWxlY3Rpb24ncyBhbmNob3Igbm9kZSBpcyBhbiBlbXB0eSBMaXN0SXRlbU5vZGUgYW5kIGlzIGEgY2hpbGQgb2ZcbiAqIHRoZSByb290L3NoYWRvdyByb290LCBpdCB3aWxsIHJlcGxhY2UgdGhlIExpc3RJdGVtTm9kZSB3aXRoIGEgTGlzdE5vZGUgYW5kIHRoZSBvbGQgTGlzdEl0ZW1Ob2RlLlxuICogT3RoZXJ3aXNlIGl0IHdpbGwgcmVwbGFjZSBpdHMgcGFyZW50IHdpdGggYSBuZXcgTGlzdE5vZGUgYW5kIHJlLWluc2VydCB0aGUgTGlzdEl0ZW1Ob2RlIGFuZCBhbnkgcHJldmlvdXMgY2hpbGRyZW4uXG4gKiBJZiB0aGUgc2VsZWN0aW9uJ3MgYW5jaG9yIG5vZGUgaXMgbm90IGFuIGVtcHR5IExpc3RJdGVtTm9kZSwgaXQgd2lsbCBhZGQgYSBuZXcgTGlzdE5vZGUgb3IgbWVyZ2UgYW4gZXhpc3RpbmcgTGlzdE5vZGUsXG4gKiB1bmxlc3MgdGhlIHRoZSBub2RlIGlzIGEgbGVhZiBub2RlLCBpbiB3aGljaCBjYXNlIGl0IHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgTGlzdE5vZGUgdXAgdGhlIGJyYW5jaCBhbmQgcmVwbGFjZSBpdCB3aXRoXG4gKiBhIG5ldyBMaXN0Tm9kZSwgb3IgY3JlYXRlIGEgbmV3IExpc3ROb2RlIGF0IHRoZSBuZWFyZXN0IHJvb3Qvc2hhZG93IHJvb3QuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICogQHBhcmFtIGxpc3RUeXBlIC0gVGhlIHR5cGUgb2YgbGlzdCwgXCJudW1iZXJcIiB8IFwiYnVsbGV0XCIgfCBcImNoZWNrXCIuXG4gKi9cbmZ1bmN0aW9uIGluc2VydExpc3QoZWRpdG9yLCBsaXN0VHlwZSkge1xuICBlZGl0b3IudXBkYXRlKCgpID0+ICRpbnNlcnRMaXN0KGxpc3RUeXBlKSk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayAkcmVtb3ZlTGlzdH0gZnJvbSBhbiB1cGRhdGUgb3IgY29tbWFuZCBsaXN0ZW5lci5cbiAqXG4gKiBTZWFyY2hlcyBmb3IgdGhlIG5lYXJlc3QgYW5jZXN0cmFsIExpc3ROb2RlIGFuZCByZW1vdmVzIGl0LiBJZiBzZWxlY3Rpb24gaXMgYW4gZW1wdHkgTGlzdEl0ZW1Ob2RlXG4gKiBpdCB3aWxsIHJlbW92ZSB0aGUgd2hvbGUgbGlzdCwgaW5jbHVkaW5nIHRoZSBMaXN0SXRlbU5vZGUuIEZvciBlYWNoIExpc3RJdGVtTm9kZSBpbiB0aGUgTGlzdE5vZGUsXG4gKiByZW1vdmVMaXN0IHdpbGwgYWxzbyBnZW5lcmF0ZSBuZXcgUGFyYWdyYXBoTm9kZXMgaW4gdGhlIHJlbW92ZWQgTGlzdE5vZGUncyBwbGFjZS4gQW55IGNoaWxkIG5vZGVcbiAqIGluc2lkZSBhIExpc3RJdGVtTm9kZSB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZSBuZXcgUGFyYWdyYXBoTm9kZXMuXG4gKiBAcGFyYW0gZWRpdG9yIC0gVGhlIGxleGljYWwgZWRpdG9yLlxuICovXG5mdW5jdGlvbiByZW1vdmVMaXN0KGVkaXRvcikge1xuICBlZGl0b3IudXBkYXRlKCgpID0+ICRyZW1vdmVMaXN0KCkpO1xufVxuXG5leHBvcnQgeyAkY3JlYXRlTGlzdEl0ZW1Ob2RlLCAkY3JlYXRlTGlzdE5vZGUsICRnZXRMaXN0RGVwdGgsICRoYW5kbGVMaXN0SW5zZXJ0UGFyYWdyYXBoLCAkaW5zZXJ0TGlzdCwgJGlzTGlzdEl0ZW1Ob2RlLCAkaXNMaXN0Tm9kZSwgJHJlbW92ZUxpc3QsIElOU0VSVF9DSEVDS19MSVNUX0NPTU1BTkQsIElOU0VSVF9PUkRFUkVEX0xJU1RfQ09NTUFORCwgSU5TRVJUX1VOT1JERVJFRF9MSVNUX0NPTU1BTkQsIExpc3RJdGVtTm9kZSwgTGlzdE5vZGUsIFJFTU9WRV9MSVNUX0NPTU1BTkQsIFVQREFURV9MSVNUX1NUQVJUX0NPTU1BTkQsIGluc2VydExpc3QsIHJlZ2lzdGVyQ2hlY2tMaXN0LCByZWdpc3Rlckxpc3QsIHJlZ2lzdGVyTGlzdFN0cmljdEluZGVudFRyYW5zZm9ybSwgcmVtb3ZlTGlzdCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+list@0.35.0/node_modules/@lexical/list/LexicalList.dev.mjs\n");

/***/ })

};
;