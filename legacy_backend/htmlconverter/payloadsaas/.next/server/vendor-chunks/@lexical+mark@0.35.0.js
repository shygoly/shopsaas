"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+mark@0.35.0";
exports.ids = ["vendor-chunks/@lexical+mark@0.35.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+mark@0.35.0/node_modules/@lexical/mark/LexicalMark.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+mark@0.35.0/node_modules/@lexical/mark/LexicalMark.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createMarkNode: () => (/* binding */ $createMarkNode),\n/* harmony export */   $getMarkIDs: () => (/* binding */ $getMarkIDs),\n/* harmony export */   $isMarkNode: () => (/* binding */ $isMarkNode),\n/* harmony export */   $unwrapMarkNode: () => (/* binding */ $unwrapMarkNode),\n/* harmony export */   $wrapSelectionInMarkNode: () => (/* binding */ $wrapSelectionInMarkNode),\n/* harmony export */   MarkNode: () => (/* binding */ MarkNode)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  // Force a forwards selection since append is used, ignore the argument.\n  // A new selection is used to avoid side-effects of flipping the given\n  // selection\n  const forwardSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n  const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n  forwardSelection.anchor.set(startPoint.key, startPoint.offset, startPoint.type);\n  forwardSelection.focus.set(endPoint.key, endPoint.offset, endPoint.type);\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // Note that extract will split text nodes at the boundaries\n  const nodes = forwardSelection.extract();\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (const node of nodes) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    let targetNode = null;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      // Case 1: The node is a text node and we can include it\n      targetNode = node;\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may ultimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(node)) && node.isInline()) {\n      // Case 3: inline element/decorator nodes can be added in their entirety\n      // to the new mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(lastCreatedMarkNode)) {\n    // eslint-disable-next-line no-unused-expressions\n    isBackward ? lastCreatedMarkNode.selectStart() : lastCreatedMarkNode.selectEnd();\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbWFya0AwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL21hcmsvTGV4aWNhbE1hcmsuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzSjtBQUNqRTs7QUFFckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx1QkFBdUIsZ0RBQVc7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxzRUFBc0I7QUFDMUI7QUFDQSxNQUFNLHNFQUFzQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHNFQUFzQjtBQUNoQztBQUNBLFFBQVE7QUFDUixRQUFRLDJFQUEyQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUywwREFBaUI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBcUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsOERBQXFCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sVUFBVSx1REFBYyxVQUFVLHlEQUFnQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSx1REFBYztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFNBQVMsb0RBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUwRyIsInNvdXJjZXMiOlsiL1VzZXJzL21hYy9TeW5jL3Byb2plY3QvZWNvbW1lcmNlL3Nob3BzYWFzL2h0bWxjb252ZXJ0ZXIvcGF5bG9hZHNhYXMvbm9kZV9tb2R1bGVzLy5wbnBtL0BsZXhpY2FsK21hcmtAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC9tYXJrL0xleGljYWxNYXJrLmRldi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5pbXBvcnQgeyBFbGVtZW50Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uLCAkaXNFbGVtZW50Tm9kZSwgJGlzVGV4dE5vZGUsICRpc0RlY29yYXRvck5vZGUgfSBmcm9tICdsZXhpY2FsJztcbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudCB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBOT19JRFMgPSBbXTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIE1hcmtOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdtYXJrJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTWFya05vZGUobm9kZS5fX2lkcywgbm9kZS5fX2tleSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlTWFya05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldElEcyhzZXJpYWxpemVkTm9kZS5pZHMpO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGlkczogdGhpcy5nZXRJRHMoKVxuICAgIH07XG4gIH1cbiAgY29uc3RydWN0b3IoaWRzID0gTk9fSURTLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19pZHMgPSBpZHM7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtYXJrJyk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUubWFyayk7XG4gICAgaWYgKHRoaXMuX19pZHMubGVuZ3RoID4gMSkge1xuICAgICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBjb25maWcudGhlbWUubWFya092ZXJsYXApO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVET00ocHJldk5vZGUsIGVsZW1lbnQsIGNvbmZpZykge1xuICAgIGNvbnN0IHByZXZJRHMgPSBwcmV2Tm9kZS5fX2lkcztcbiAgICBjb25zdCBuZXh0SURzID0gdGhpcy5fX2lkcztcbiAgICBjb25zdCBwcmV2SURzQ291bnQgPSBwcmV2SURzLmxlbmd0aDtcbiAgICBjb25zdCBuZXh0SURzQ291bnQgPSBuZXh0SURzLmxlbmd0aDtcbiAgICBjb25zdCBvdmVybGFwVGhlbWUgPSBjb25maWcudGhlbWUubWFya092ZXJsYXA7XG4gICAgaWYgKHByZXZJRHNDb3VudCAhPT0gbmV4dElEc0NvdW50KSB7XG4gICAgICBpZiAocHJldklEc0NvdW50ID09PSAxKSB7XG4gICAgICAgIGlmIChuZXh0SURzQ291bnQgPT09IDIpIHtcbiAgICAgICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIG92ZXJsYXBUaGVtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV4dElEc0NvdW50ID09PSAxKSB7XG4gICAgICAgIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBvdmVybGFwVGhlbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaGFzSUQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRJRHMoKS5pbmNsdWRlcyhpZCk7XG4gIH1cbiAgZ2V0SURzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZ2V0TGF0ZXN0KCkuX19pZHMpO1xuICB9XG4gIHNldElEcyhpZHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19pZHMgPSBpZHM7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgYWRkSUQoaWQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHJldHVybiBzZWxmLl9faWRzLmluY2x1ZGVzKGlkKSA/IHNlbGYgOiBzZWxmLnNldElEcyhbLi4uc2VsZi5fX2lkcywgaWRdKTtcbiAgfVxuICBkZWxldGVJRChpZCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgY29uc3QgaWR4ID0gc2VsZi5fX2lkcy5pbmRleE9mKGlkKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGNvbnN0IGlkcyA9IEFycmF5LmZyb20oc2VsZi5fX2lkcyk7XG4gICAgaWRzLnNwbGljZShpZHgsIDEpO1xuICAgIHJldHVybiBzZWxmLnNldElEcyhpZHMpO1xuICB9XG4gIGluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbiA9IHRydWUpIHtcbiAgICBjb25zdCBtYXJrTm9kZSA9ICRjcmVhdGVNYXJrTm9kZSh0aGlzLl9faWRzKTtcbiAgICB0aGlzLmluc2VydEFmdGVyKG1hcmtOb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbWFya05vZGU7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8IGRlc3RpbmF0aW9uID09PSAnaHRtbCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvcjtcbiAgICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cztcbiAgICBjb25zdCBhbmNob3JOb2RlID0gYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgY29uc3QgaXNCYWNrd2FyZCA9IHNlbGVjdGlvbi5pc0JhY2t3YXJkKCk7XG4gICAgY29uc3Qgc2VsZWN0aW9uTGVuZ3RoID0gaXNCYWNrd2FyZCA/IGFuY2hvci5vZmZzZXQgLSBmb2N1cy5vZmZzZXQgOiBmb2N1cy5vZmZzZXQgLSBhbmNob3Iub2Zmc2V0O1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgdGhpcy5nZXRUZXh0Q29udGVudCgpLmxlbmd0aCA9PT0gc2VsZWN0aW9uTGVuZ3RoO1xuICB9XG4gIGV4Y2x1ZGVGcm9tQ29weShkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiAhPT0gJ2Nsb25lJztcbiAgfVxufVxuZnVuY3Rpb24gJGNyZWF0ZU1hcmtOb2RlKGlkcyA9IE5PX0lEUykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBNYXJrTm9kZShpZHMpKTtcbn1cbmZ1bmN0aW9uICRpc01hcmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBNYXJrTm9kZTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5mdW5jdGlvbiAkdW53cmFwTWFya05vZGUobm9kZSkge1xuICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgbGV0IHRhcmdldCA9IG51bGw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgIG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGFyZ2V0Lmluc2VydEFmdGVyKGNoaWxkKTtcbiAgICB9XG4gICAgdGFyZ2V0ID0gY2hpbGQ7XG4gIH1cbiAgbm9kZS5yZW1vdmUoKTtcbn1cbmZ1bmN0aW9uICR3cmFwU2VsZWN0aW9uSW5NYXJrTm9kZShzZWxlY3Rpb24sIGlzQmFja3dhcmQsIGlkLCBjcmVhdGVOb2RlKSB7XG4gIC8vIEZvcmNlIGEgZm9yd2FyZHMgc2VsZWN0aW9uIHNpbmNlIGFwcGVuZCBpcyB1c2VkLCBpZ25vcmUgdGhlIGFyZ3VtZW50LlxuICAvLyBBIG5ldyBzZWxlY3Rpb24gaXMgdXNlZCB0byBhdm9pZCBzaWRlLWVmZmVjdHMgb2YgZmxpcHBpbmcgdGhlIGdpdmVuXG4gIC8vIHNlbGVjdGlvblxuICBjb25zdCBmb3J3YXJkU2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uKCk7XG4gIGNvbnN0IFtzdGFydFBvaW50LCBlbmRQb2ludF0gPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gW3NlbGVjdGlvbi5mb2N1cywgc2VsZWN0aW9uLmFuY2hvcl0gOiBbc2VsZWN0aW9uLmFuY2hvciwgc2VsZWN0aW9uLmZvY3VzXTtcbiAgZm9yd2FyZFNlbGVjdGlvbi5hbmNob3Iuc2V0KHN0YXJ0UG9pbnQua2V5LCBzdGFydFBvaW50Lm9mZnNldCwgc3RhcnRQb2ludC50eXBlKTtcbiAgZm9yd2FyZFNlbGVjdGlvbi5mb2N1cy5zZXQoZW5kUG9pbnQua2V5LCBlbmRQb2ludC5vZmZzZXQsIGVuZFBvaW50LnR5cGUpO1xuICBsZXQgY3VycmVudE5vZGVQYXJlbnQ7XG4gIGxldCBsYXN0Q3JlYXRlZE1hcmtOb2RlO1xuXG4gIC8vIE5vdGUgdGhhdCBleHRyYWN0IHdpbGwgc3BsaXQgdGV4dCBub2RlcyBhdCB0aGUgYm91bmRhcmllc1xuICBjb25zdCBub2RlcyA9IGZvcndhcmRTZWxlY3Rpb24uZXh0cmFjdCgpO1xuICAvLyBXZSBvbmx5IHdhbnQgd3JhcCBhZGphY2VudCB0ZXh0IG5vZGVzLCBsaW5lIGJyZWFrIG5vZGVzXG4gIC8vIGFuZCBpbmxpbmUgZWxlbWVudCBub2Rlcy4gRm9yIGRlY29yYXRvciBub2RlcyBhbmQgYmxvY2tcbiAgLy8gZWxlbWVudCBub2Rlcywgd2Ugc3RlcCBvdXQgb2YgdGhlaXIgYm91bmRhcnkgYW5kIHN0YXJ0XG4gIC8vIGFnYWluIGFmdGVyLCBpZiB0aGVyZSBhcmUgbW9yZSBub2Rlcy5cbiAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGxhc3RDcmVhdGVkTWFya05vZGUpICYmIGxhc3RDcmVhdGVkTWFya05vZGUuaXNQYXJlbnRPZihub2RlKSkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBhIGNoaWxkIG9mIHRoZSBsYXN0IGNyZWF0ZWQgbWFyayBub2RlLCB0aGVyZSBpcyBub3RoaW5nIHRvIGRvIGhlcmVcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgdGFyZ2V0Tm9kZSA9IG51bGw7XG4gICAgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICAvLyBDYXNlIDE6IFRoZSBub2RlIGlzIGEgdGV4dCBub2RlIGFuZCB3ZSBjYW4gaW5jbHVkZSBpdFxuICAgICAgdGFyZ2V0Tm9kZSA9IG5vZGU7XG4gICAgfSBlbHNlIGlmICgkaXNNYXJrTm9kZShub2RlKSkge1xuICAgICAgLy8gQ2FzZSAyOiB0aGUgbm9kZSBpcyBhIG1hcmsgbm9kZSBhbmQgd2UgY2FuIGlnbm9yZSBpdCBhcyBhIHRhcmdldCxcbiAgICAgIC8vIG1vdmluZyBvbiB0byBpdHMgY2hpbGRyZW4uIE5vdGUgdGhhdCB3aGVuIHdlIG1ha2UgYSBtYXJrIGluc2lkZVxuICAgICAgLy8gYW5vdGhlciBtYXJrLCBpdCBtYXkgdWx0aW1hdGVseSBiZSB1bm5lc3RlZCBieSBhIGNhbGwgdG9cbiAgICAgIC8vIGByZWdpc3Rlck5lc3RlZEVsZW1lbnRSZXNvbHZlcjxNYXJrTm9kZT5gIHNvbWV3aGVyZSBlbHNlIGluIHRoZVxuICAgICAgLy8gY29kZWJhc2UuXG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKCgkaXNFbGVtZW50Tm9kZShub2RlKSB8fCAkaXNEZWNvcmF0b3JOb2RlKG5vZGUpKSAmJiBub2RlLmlzSW5saW5lKCkpIHtcbiAgICAgIC8vIENhc2UgMzogaW5saW5lIGVsZW1lbnQvZGVjb3JhdG9yIG5vZGVzIGNhbiBiZSBhZGRlZCBpbiB0aGVpciBlbnRpcmV0eVxuICAgICAgLy8gdG8gdGhlIG5ldyBtYXJrXG4gICAgICB0YXJnZXROb2RlID0gbm9kZTtcbiAgICB9XG4gICAgaWYgKHRhcmdldE5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIE5vdyB0aGF0IHdlIGhhdmUgYSB0YXJnZXQgbm9kZSBmb3Igd3JhcHBpbmcgd2l0aCBhIG1hcmssIHdlIGNhbiBydW5cbiAgICAgIC8vIHRocm91Z2ggc3BlY2lhbCBjYXNlcy5cbiAgICAgIGlmICh0YXJnZXROb2RlICYmIHRhcmdldE5vZGUuaXMoY3VycmVudE5vZGVQYXJlbnQpKSB7XG4gICAgICAgIC8vIFRoZSBjdXJyZW50IG5vZGUgaXMgYSBjaGlsZCBvZiB0aGUgdGFyZ2V0IG5vZGUgdG8gYmUgd3JhcHBlZCwgdGhlcmVcbiAgICAgICAgLy8gaXMgbm90aGluZyB0byBkbyBoZXJlLlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSB0YXJnZXROb2RlLmdldFBhcmVudCgpO1xuICAgICAgaWYgKHBhcmVudE5vZGUgPT0gbnVsbCB8fCAhcGFyZW50Tm9kZS5pcyhjdXJyZW50Tm9kZVBhcmVudCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0aGUgY3VycmVudCBub2RlJ3MgcGFyZW50IG5vZGUsIHdlIGNhblxuICAgICAgICAvLyBjbGVhciB0aGUgbGFzdCBjcmVhdGVkIG1hcmsgbm9kZS5cbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnROb2RlUGFyZW50ID0gcGFyZW50Tm9kZTtcbiAgICAgIGlmIChsYXN0Q3JlYXRlZE1hcmtOb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNyZWF0ZWQgbWFyayBub2RlLCB3ZSBjYW4gbWFrZSBvbmVcbiAgICAgICAgY29uc3QgY3JlYXRlTWFya05vZGUgPSBjcmVhdGVOb2RlIHx8ICRjcmVhdGVNYXJrTm9kZTtcbiAgICAgICAgbGFzdENyZWF0ZWRNYXJrTm9kZSA9IGNyZWF0ZU1hcmtOb2RlKFtpZF0pO1xuICAgICAgICB0YXJnZXROb2RlLmluc2VydEJlZm9yZShsYXN0Q3JlYXRlZE1hcmtOb2RlKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHRoZSB0YXJnZXQgbm9kZSB0byBiZSB3cmFwcGVkIGluIHRoZSBsYXRlc3QgY3JlYXRlZCBtYXJrIG5vZGVcbiAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUuYXBwZW5kKHRhcmdldE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgdGFyZ2V0IG5vZGUgdG8gd3JhcCB3ZSBjYW4gY2xlYXIgb3VyIHN0YXRlIGFuZFxuICAgICAgLy8gY29udGludWUgb24gd2l0aCB0aGUgbmV4dCBub2RlXG4gICAgICBjdXJyZW50Tm9kZVBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgIGxhc3RDcmVhdGVkTWFya05vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG4gIC8vIE1ha2Ugc2VsZWN0aW9uIGNvbGxhcHNlZCBhdCB0aGUgZW5kXG4gIGlmICgkaXNFbGVtZW50Tm9kZShsYXN0Q3JlYXRlZE1hcmtOb2RlKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICBpc0JhY2t3YXJkID8gbGFzdENyZWF0ZWRNYXJrTm9kZS5zZWxlY3RTdGFydCgpIDogbGFzdENyZWF0ZWRNYXJrTm9kZS5zZWxlY3RFbmQoKTtcbiAgfVxufVxuZnVuY3Rpb24gJGdldE1hcmtJRHMobm9kZSwgb2Zmc2V0KSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIGlmICgkaXNNYXJrTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZS5nZXRJRHMoKTtcbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKGN1cnJlbnROb2RlKSAmJiBvZmZzZXQgPT09IGN1cnJlbnROb2RlLmdldFRleHRDb250ZW50U2l6ZSgpKSB7XG4gICAgICBjb25zdCBuZXh0U2libGluZyA9IGN1cnJlbnROb2RlLmdldE5leHRTaWJsaW5nKCk7XG4gICAgICBpZiAoJGlzTWFya05vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgIHJldHVybiBuZXh0U2libGluZy5nZXRJRHMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZU1hcmtOb2RlLCAkZ2V0TWFya0lEcywgJGlzTWFya05vZGUsICR1bndyYXBNYXJrTm9kZSwgJHdyYXBTZWxlY3Rpb25Jbk1hcmtOb2RlLCBNYXJrTm9kZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+mark@0.35.0/node_modules/@lexical/mark/LexicalMark.dev.mjs\n");

/***/ })

};
;