"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+table@0.35.0";
exports.ids = ["vendor-chunks/@lexical+table@0.35.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $createTableSelectionFrom: () => (/* binding */ $createTableSelectionFrom),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumnAtSelection: () => (/* binding */ $deleteTableColumnAtSelection),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRowAtSelection: () => (/* binding */ $deleteTableRowAtSelection),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $findCellNode: () => (/* binding */ $findCellNode),\n/* harmony export */   $findTableNode: () => (/* binding */ $findTableNode),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableAndElementByKey: () => (/* binding */ $getTableAndElementByKey),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumnAtSelection: () => (/* binding */ $insertTableColumnAtSelection),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRowAtSelection: () => (/* binding */ $insertTableRowAtSelection),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isScrollableTablesActive: () => (/* binding */ $isScrollableTablesActive),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $mergeCells: () => (/* binding */ $mergeCells),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableElement: () => (/* binding */ getTableElement),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement),\n/* harmony export */   registerTableCellUnmergeTransform: () => (/* binding */ registerTableCellUnmergeTransform),\n/* harmony export */   registerTablePlugin: () => (/* binding */ registerTablePlugin),\n/* harmony export */   registerTableSelectionObserver: () => (/* binding */ registerTableSelectionObserver),\n/* harmony export */   setScrollableTablesActive: () => (/* binding */ setScrollableTablesActive)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(rsc)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(rsc)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(rsc)/./node_modules/.pnpm/@lexical+clipboard@0.35.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isInlineElementOrDecoratorNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(child)) {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.anchor.key, this.anchor.offset, this.anchor.type), (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() !== null) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n    this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, 'down'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, 'up'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, 'backward'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, isBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret)(nextCaret) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCell, lastCaret.direction));\n  const anchorCellTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCellTable, initialFocus.direction));\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, outerFocusCaret);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(focusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, innerFocusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(initialCaret);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n        return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...removeClasses);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setDOMUnmanaged)(colGroup);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if (!selection || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertNodeToNearestRoot)(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n    return false;\n  }\n  const startNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertFirst)(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, $tableClickCommand, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJSO0FBQ29nQztBQUMxc0M7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVztBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxREFBWSx5REFBeUQscURBQVk7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsd0RBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLDBFQUFpQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QUFDUCwrQ0FBK0Msc0RBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixzREFBYSxNQUFNLDhEQUFxQjtBQUM1RCxxQkFBcUIsMERBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0VBQXdCO0FBQzFCO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLDZEQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBMkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLDBCQUEwQixRQUFRLGtCQUFrQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLDZEQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUIsb0JBQW9CLHVEQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYyw0REFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBYSwyRUFBMkUsNERBQXVCLDBCQUEwQiw2RUFBd0M7QUFDMUw7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQ0FBc0MsMERBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWEsc0JBQXNCLDREQUF1QjtBQUNoSDs7QUFFdXZDIiwic291cmNlcyI6WyIvVXNlcnMvbWFjL1N5bmMvcHJvamVjdC9lY29tbWVyY2Uvc2hvcHNhYXMvaHRtbGNvbnZlcnRlci9wYXlsb2Fkc2Fhcy9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsICRkZXNjZW5kYW50c01hdGNoaW5nLCAkZmluZE1hdGNoaW5nUGFyZW50LCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBpc0hUTUxFbGVtZW50IGFzIGlzSFRNTEVsZW1lbnQkMSwgJGluc2VydEZpcnN0IGFzICRpbnNlcnRGaXJzdCQxLCBtZXJnZVJlZ2lzdGVyLCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCBpc0hUTUxFbGVtZW50LCAkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlLCAkaXNUZXh0Tm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgY3JlYXRlQ29tbWFuZCwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUGFyYWdyYXBoTm9kZSwgJGNyZWF0ZVBvaW50LCAkaXNFbGVtZW50Tm9kZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSwgVEVYVF9UWVBFX1RPX0ZPUk1BVCwgJGdldE5vZGVCeUtleSwgJGdldEVkaXRvciwgJHNldFNlbGVjdGlvbiwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBnZXRET01TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE5vZGUsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9ISUdILCBLRVlfRVNDQVBFX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIENVVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIEtFWV9UQUJfQ09NTUFORCwgRk9DVVNfQ09NTUFORCwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5ELCBpc0RPTU5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNTaWJsaW5nQ2FyZXQsICRnZXRTaWJsaW5nQ2FyZXQsICRzZXRQb2ludEZyb21DYXJldCwgJG5vcm1hbGl6ZUNhcmV0LCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkaXNDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldCwgc2V0RE9NVW5tYW5hZ2VkLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgQ0xJQ0tfQ09NTUFORCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY29weVRvQ2xpcGJvYXJkLCAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24gfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFBJWEVMX1ZBTFVFX1JFR19FWFAgPSAvXihcXGQrKD86XFwuXFxkKyk/KXB4JC87XG5cbi8vIC5QbGF5Z3JvdW5kRWRpdG9yVGhlbWVfX3RhYmxlQ2VsbCB3aWR0aCB2YWx1ZSBmcm9tXG4vLyBwYWNrYWdlcy9sZXhpY2FsLXBsYXlncm91bmQvc3JjL3RoZW1lcy9QbGF5Z3JvdW5kRWRpdG9yVGhlbWUuY3NzXG5jb25zdCBDT0xVTU5fV0lEVEggPSA3NTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMgPSB7XG4gIEJPVEg6IDMsXG4gIENPTFVNTjogMixcbiAgTk9fU1RBVFVTOiAwLFxuICBST1c6IDFcbn07XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVDZWxsTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKG5vZGUuX19oZWFkZXJTdGF0ZSwgbm9kZS5fX2NvbFNwYW4sIG5vZGUuX193aWR0aCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20obm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICAgIHRoaXMuX19yb3dTcGFuID0gbm9kZS5fX3Jvd1NwYW47XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG5vZGUuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSBub2RlLl9fdmVydGljYWxBbGlnbjtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0aDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZUNlbGxOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRIZWFkZXJTdHlsZXMoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUpLnNldENvbFNwYW4oc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxKS5zZXRSb3dTcGFuKHNlcmlhbGl6ZWROb2RlLnJvd1NwYW4gfHwgMSkuc2V0V2lkdGgoc2VyaWFsaXplZE5vZGUud2lkdGggfHwgdW5kZWZpbmVkKS5zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGwpLnNldFZlcnRpY2FsQWxpZ24oc2VyaWFsaXplZE5vZGUudmVydGljYWxBbGlnbiB8fCB1bmRlZmluZWQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICB0aGlzLl9fcm93U3BhbiA9IDE7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fYmFja2dyb3VuZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkVmVydGljYWxBbGlnbih0aGlzLl9fdmVydGljYWxBbGlnbikpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICAgIH1cbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KG91dHB1dC5lbGVtZW50KSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG91dHB1dC5lbGVtZW50O1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXknLCB0aGlzLmdldEtleSgpKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7XG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnQuY29sU3BhbiA9IHRoaXMuX19jb2xTcGFuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgQ09MVU1OX1dJRFRIfXB4YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuZ2V0VmVydGljYWxBbGlnbigpIHx8ICd0b3AnO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgaWYgKHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwgJiYgdGhpcy5oYXNIZWFkZXIoKSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAuLi4oaXNWYWxpZFZlcnRpY2FsQWxpZ24odGhpcy5fX3ZlcnRpY2FsQWxpZ24pICYmIHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fX3ZlcnRpY2FsQWxpZ25cbiAgICAgIH0pLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICBoZWFkZXJTdGF0ZTogdGhpcy5fX2hlYWRlclN0YXRlLFxuICAgICAgcm93U3BhbjogdGhpcy5fX3Jvd1NwYW4sXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gICAgfTtcbiAgfVxuICBnZXRDb2xTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fY29sU3BhbjtcbiAgfVxuICBzZXRDb2xTcGFuKGNvbFNwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRSb3dTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcm93U3BhbjtcbiAgfVxuICBzZXRSb3dTcGFuKHJvd1NwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSGVhZGVyKCkgPyAndGgnIDogJ3RkJztcbiAgfVxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUsIG1hc2sgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQk9USCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGUgJiBtYXNrIHwgc2VsZi5fX2hlYWRlclN0YXRlICYgfm1hc2s7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVhZGVyU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGU7XG4gIH1cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX193aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fd2lkdGg7XG4gIH1cbiAgZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHNldEJhY2tncm91bmRDb2xvcihuZXdCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19iYWNrZ3JvdW5kQ29sb3IgPSBuZXdCYWNrZ3JvdW5kQ29sb3I7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0VmVydGljYWxBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3ZlcnRpY2FsQWxpZ247XG4gIH1cbiAgc2V0VmVydGljYWxBbGlnbihuZXdWZXJ0aWNhbEFsaWduKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdmVydGljYWxBbGlnbiA9IG5ld1ZlcnRpY2FsQWxpZ24gfHwgdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICgoc2VsZi5fX2hlYWRlclN0YXRlICYgaGVhZGVyU3RhdGVUb1RvZ2dsZSkgPT09IGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSAtPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgKz0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG4gIGhhc0hlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlICE9PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlYWRlclN0YXRlICE9PSB0aGlzLl9faGVhZGVyU3RhdGUgfHwgcHJldk5vZGUuX193aWR0aCAhPT0gdGhpcy5fX3dpZHRoIHx8IHByZXZOb2RlLl9fY29sU3BhbiAhPT0gdGhpcy5fX2NvbFNwYW4gfHwgcHJldk5vZGUuX19yb3dTcGFuICE9PSB0aGlzLl9fcm93U3BhbiB8fCBwcmV2Tm9kZS5fX2JhY2tncm91bmRDb2xvciAhPT0gdGhpcy5fX2JhY2tncm91bmRDb2xvciB8fCBwcmV2Tm9kZS5fX3ZlcnRpY2FsQWxpZ24gIT09IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZFZlcnRpY2FsQWxpZ24odmVydGljYWxBbGlnbikge1xuICByZXR1cm4gdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScgfHwgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbSc7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLndpZHRoKSkge1xuICAgIHdpZHRoID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS53aWR0aCk7XG4gIH1cbiAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKG5vZGVOYW1lID09PSAndGgnID8gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVyA6IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGRvbU5vZGVfLmNvbFNwYW4sIHdpZHRoKTtcbiAgdGFibGVDZWxsTm9kZS5fX3Jvd1NwYW4gPSBkb21Ob2RlXy5yb3dTcGFuO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkb21Ob2RlXy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICcnKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBjb25zdCB2ZXJ0aWNhbEFsaWduID0gZG9tTm9kZV8uc3R5bGUudmVydGljYWxBbGlnbjtcbiAgaWYgKGlzVmFsaWRWZXJ0aWNhbEFsaWduKHZlcnRpY2FsQWxpZ24pKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX3ZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gZG9tTm9kZV8uc3R5bGU7XG4gIGNvbnN0IHRleHREZWNvcmF0aW9uID0gKHN0eWxlICYmIHN0eWxlLnRleHREZWNvcmF0aW9uIHx8ICcnKS5zcGxpdCgnICcpO1xuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IHN0eWxlLmZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgY29uc3QgaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiA9IHRleHREZWNvcmF0aW9uLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKTtcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IHBhcmFncmFwaE5vZGUgPSBudWxsO1xuICAgICAgY29uc3QgcmVtb3ZlU2luZ2xlTGluZUJyZWFrTm9kZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUoZmlyc3RDaGlsZCkgJiYgcGFyYWdyYXBoTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkTGV4aWNhbE5vZGVzKSB7XG4gICAgICAgIGlmICgkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlKGNoaWxkKSB8fCAkaXNUZXh0Tm9kZShjaGlsZCkgfHwgJGlzTGluZUJyZWFrTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdib2xkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdpdGFsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3VuZGVybGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICByZW1vdmVTaW5nbGVMaW5lQnJlYWtOb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZVNpbmdsZUxpbmVCcmVha05vZGUoKTtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHdpZHRoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZUNlbGxOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9UQUJMRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQkxFX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZVJvd05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlcm93JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVSb3dOb2RlKG5vZGUuX19oZWlnaHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVSb3dFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZVJvd05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldEhlaWdodChzZXJpYWxpemVkTm9kZS5oZWlnaHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlaWdodCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgLi4uKGhlaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDoge1xuICAgICAgICBoZWlnaHRcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgaWYgKHRoaXMuX19oZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fX2hlaWdodH1weGA7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlUm93KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uID09PSAnaHRtbCc7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlaWdodCAhPT0gdGhpcy5fX2hlaWdodDtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlUm93RWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgbGV0IGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgaWYgKFBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpKSB7XG4gICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkcmVuID0+ICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkaXNUYWJsZUNlbGxOb2RlKSxcbiAgICBub2RlOiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlUm93Tm9kZShoZWlnaHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlUm93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVSb3dOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19GSVJFRk9YID0gQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucyhyb3dDb3VudCwgY29sdW1uQ291bnQsIGluY2x1ZGVIZWFkZXJzID0gdHJ1ZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGZvciAobGV0IGlSb3cgPSAwOyBpUm93IDwgcm93Q291bnQ7IGlSb3crKykge1xuICAgIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICBpZiAodHlwZW9mIGluY2x1ZGVIZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5yb3dzKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5jb2x1bW5zKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlSGVhZGVycykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlDb2x1bW4gPT09IDApIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCgkY3JlYXRlVGV4dE5vZGUoKSk7XG4gICAgICB0YWJsZUNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgIHRhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgfVxuICAgIHRhYmxlTm9kZS5hcHBlbmQodGFibGVSb3dOb2RlKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZU5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpO1xuICByZXR1cm4ge1xuICAgIGFib3ZlOiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSAtIDEsIHRhYmxlKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCB0YWJsZSksXG4gICAgbGVmdDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggLSAxLCB5LCB0YWJsZSksXG4gICAgcmlnaHQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4ICsgMSwgeSwgdGFibGUpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKGluZGV4VG9EZWxldGUgPj0gdGFibGVSb3dzLmxlbmd0aCB8fCBpbmRleFRvRGVsZXRlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUgcm93LicpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbaW5kZXhUb0RlbGV0ZV07XG4gIHRhcmdldFJvd05vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbn0gb3Ige0BsaW5rICRpbnNlcnRUYWJsZVJvd0F0Tm9kZX0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93KHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgcm93Q291bnQsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dzLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIHJvdyB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1t0YXJnZXRJbmRleF07XG4gIGlmICgkaXNUYWJsZVJvd05vZGUodGFyZ2V0Um93Tm9kZSkpIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2VsbHMgPSB0YXJnZXRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0YWJsZUNvbHVtbkNvdW50ID0gdGFibGVSb3dDZWxscy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdUYWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRhYmxlQ29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZUNlbGxGcm9tVGFyZ2V0Um93ID0gdGFibGVSb3dDZWxsc1tjXTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3ZlICYmIGFib3ZlLmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pIHx8IGJlbG93ICYmIGJlbG93Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRBZnRlcihuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3cgYmVmb3JlIGluc2VydGlvbiBpbmRleCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuY29uc3QgZ2V0SGVhZGVyU3RhdGUgPSAoY3VycmVudFN0YXRlLCBwb3NzaWJsZVN0YXRlKSA9PiB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIIHx8IGN1cnJlbnRTdGF0ZSA9PT0gcG9zc2libGVTdGF0ZSkge1xuICAgIHJldHVybiBwb3NzaWJsZVN0YXRlO1xuICB9XG4gIHJldHVybiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdGFibGUgcm93IGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGluc2VydGVkIHRhYmxlIHJvdyBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbihpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFssIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogYW5jaG9yU3RhcnRSb3dcbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlUm93QXROb2RlKGFuY2hvclN0YXJ0Um93ICsgYW5jaG9yQ2VsbC5fX3Jvd1NwYW4gPiBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiA/IGFuY2hvckNlbGwgOiBmb2N1c0NlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAkaW5zZXJ0VGFibGVSb3dBdE5vZGUoZm9jdXNTdGFydFJvdyA8IGFuY2hvclN0YXJ0Um93ID8gZm9jdXNDZWxsIDogYW5jaG9yQ2VsbCwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb247XG5cbi8qKlxuICogSW5zZXJ0cyBhIHRhYmxlIHJvdyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogaW5zZXJ0ZWQgdGFibGUgcm93IG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd0F0Tm9kZShjZWxsTm9kZSwgaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IFssLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChjZWxsTm9kZSk7XG4gIGNvbnN0IFtncmlkTWFwLCBjZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbE5vZGUsIGNlbGxOb2RlKTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIGxldCBpbnNlcnRlZFJvdyA9IG51bGw7XG4gIGlmIChpbnNlcnRBZnRlcikge1xuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93ID0gY2VsbFN0YXJ0Um93ICsgY2VsbE5vZGUuX19yb3dTcGFuIC0gMTtcbiAgICBjb25zdCBpbnNlcnRBZnRlckVuZFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QWZ0ZXJFbmRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRBZnRlckVuZFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckVuZFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGluc2VydEFmdGVyRW5kUm93TWFwW2ldLmNlbGw7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSBjdXJyZW50Q2VsbC5fX2hlYWRlclN0YXRlO1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pO1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGluc2VydEFmdGVyRW5kUm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShpbnNlcnRBZnRlckVuZFJvd05vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydEFmdGVyRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBpbnNlcnRBZnRlckVuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgICBpbnNlcnRlZFJvdyA9IG5ld1JvdztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvdyA9IGNlbGxTdGFydFJvdztcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QmVmb3JlU3RhcnRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyA9PT0gaW5zZXJ0QmVmb3JlU3RhcnRSb3cpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChpbnNlcnRCZWZvcmVTdGFydFJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRCZWZvcmVTdGFydFJvdyBpcyBub3QgYSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdSb3cpO1xuICAgIGluc2VydGVkUm93ID0gbmV3Um93O1xuICB9XG4gIHJldHVybiBpbnNlcnRlZFJvdztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWVyZ2VkIGNlbGxzLiBVc2Uge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufSBvciB7QGxpbmsgJGluc2VydFRhYmxlQ29sdW1uQXROb2RlfSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCBjb2x1bW5Db3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQgPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZVJvd3MubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW3JdO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhcmdldENlbGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhcmdldENlbGwsIHRhYmxlKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgaWYgKGxlZnQgJiYgbGVmdC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSB8fCByaWdodCAmJiByaWdodC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFibGVDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgICBuZXdUYWJsZUNlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLnB1c2goe1xuICAgICAgICAgIG5ld1RhYmxlQ2VsbCxcbiAgICAgICAgICB0YXJnZXRDZWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLmZvckVhY2goKHtcbiAgICBuZXdUYWJsZUNlbGwsXG4gICAgdGFyZ2V0Q2VsbFxuICB9KSA9PiB7XG4gICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICB0YXJnZXRDZWxsLmluc2VydEFmdGVyKG5ld1RhYmxlQ2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlQ2VsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgY29sdW1uIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbLCBmb2N1c0NlbGxNYXAsIGFuY2hvckNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBmb2N1c0NlbGwsIGFuY2hvckNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgcmV0dXJuICRpbnNlcnRUYWJsZUNvbHVtbkF0Tm9kZShhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuID4gZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gPyBhbmNob3JDZWxsIDogZm9jdXNDZWxsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGZvY3VzU3RhcnRDb2x1bW4gPCBhbmNob3JTdGFydENvbHVtbiA/IGZvY3VzQ2VsbCA6IGFuY2hvckNlbGwsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCA9ICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uO1xuXG4vKipcbiAqIEluc2VydHMgYSBjb2x1bW4gYmVmb3JlIG9yIGFmdGVyIHRoZSBnaXZlbiBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGNlbGxOb2RlLCBpbnNlcnRBZnRlciA9IHRydWUsIHNob3VsZFNldFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgY29uc3QgWywsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXAsIGNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBjZWxsTm9kZSwgY2VsbE5vZGUpO1xuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxNYXA7XG4gIGNvbnN0IGluc2VydEFmdGVyQ29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBzdGFydENvbHVtbiArIGNlbGxOb2RlLl9fY29sU3BhbiAtIDEgOiBzdGFydENvbHVtbiAtIDE7XG4gIGNvbnN0IGdyaWRGaXJzdENoaWxkID0gZ3JpZC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKGdyaWRGaXJzdENoaWxkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgZmlyc3RUYWJsZSBjaGlsZCB0byBiZSBhIHJvd2ApO1xuICB9XG4gIGxldCBmaXJzdEluc2VydGVkQ2VsbCA9IG51bGw7XG4gIGZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSB7XG4gICAgY29uc3QgY2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsID09PSBudWxsKSB7XG4gICAgICBmaXJzdEluc2VydGVkQ2VsbCA9IGNlbGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGxldCBsb29wUm93ID0gZ3JpZEZpcnN0Q2hpbGQ7XG4gIHJvd0xvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gbG9vcFJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCByb3cgbmV4dFNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxvb3BSb3cgPSBjdXJyZW50Um93O1xuICAgIH1cbiAgICBjb25zdCByb3dNYXAgPSBncmlkTWFwW2ldO1xuICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwKSB7XG4gICAgICAkaW5zZXJ0Rmlyc3QobG9vcFJvdywgJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNlbGw6IGN1cnJlbnRDZWxsLFxuICAgICAgc3RhcnRDb2x1bW46IGN1cnJlbnRTdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93OiBjdXJyZW50U3RhcnRSb3dcbiAgICB9ID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uXTtcbiAgICBpZiAoY3VycmVudFN0YXJ0Q29sdW1uICsgY3VycmVudENlbGwuX19jb2xTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckNvbHVtbikge1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ID0gY3VycmVudFN0YXJ0Um93O1xuICAgICAgbGV0IHByZXZDZWxsSW5kZXggPSBpbnNlcnRBZnRlckNvbHVtbjtcbiAgICAgIHdoaWxlIChpbnNlcnRBZnRlckNlbGxSb3dTdGFydCAhPT0gaSAmJiBpbnNlcnRBZnRlckNlbGwuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBwcmV2Q2VsbEluZGV4IC09IGN1cnJlbnRDZWxsLl9fY29sU3BhbjtcbiAgICAgICAgaWYgKHByZXZDZWxsSW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IGNlbGxfLFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93X1xuICAgICAgICAgIH0gPSByb3dNYXBbcHJldkNlbGxJbmRleF07XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY2VsbF87XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBzdGFydFJvd187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcFJvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgICAgIGNvbnRpbnVlIHJvd0xvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDZWxsLnNldENvbFNwYW4oY3VycmVudENlbGwuX19jb2xTcGFuICsgMSk7XG4gICAgfVxuICB9XG4gIGlmIChmaXJzdEluc2VydGVkQ2VsbCAhPT0gbnVsbCAmJiBzaG91bGRTZXRTZWxlY3Rpb24pIHtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChmaXJzdEluc2VydGVkQ2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gbmV3Q29sV2lkdGhzW2NvbHVtbkluZGV4XTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKGNvbHVtbkluZGV4LCAwLCBuZXdXaWR0aCk7XG4gICAgZ3JpZC5zZXRDb2xXaWR0aHMobmV3Q29sV2lkdGhzKTtcbiAgfVxuICByZXR1cm4gZmlyc3RJbnNlcnRlZENlbGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbn0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gW3NlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpXSA6IFtzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKV07XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBhbmNob3JTdGFydFJvd1xuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93XG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IGZvY3VzRW5kUm93ID0gZm9jdXNTdGFydFJvdyArIGZvY3VzQ2VsbC5fX3Jvd1NwYW4gLSAxO1xuICBpZiAoZ3JpZE1hcC5sZW5ndGggPT09IGZvY3VzRW5kUm93IC0gYW5jaG9yU3RhcnRSb3cgKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGNvbnN0IG5leHRSb3cgPSBncmlkTWFwW2ZvY3VzRW5kUm93ICsgMV07XG4gIGNvbnN0IG5leHRSb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgoZm9jdXNFbmRSb3cgKyAxKTtcbiAgZm9yIChsZXQgcm93ID0gZm9jdXNFbmRSb3c7IHJvdyA+PSBhbmNob3JTdGFydFJvdzsgcm93LS0pIHtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSBjb2x1bW5Db3VudCAtIDE7IGNvbHVtbiA+PSAwOyBjb2x1bW4tLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93LFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uICE9PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHdvcmsgZm9yIHRoZSBzYW1lIENlbGxcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIHRvcCBvciBib3R0b20gaGF2ZSB0byBiZSB0cmltbWVkXG4gICAgICBpZiAoY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cgfHwgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uU3RhcnQgPSBNYXRoLm1heChjZWxsU3RhcnRSb3csIGFuY2hvclN0YXJ0Um93KTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uRW5kID0gTWF0aC5taW4oY2VsbC5fX3Jvd1NwYW4gKyBjZWxsU3RhcnRSb3cgLSAxLCBmb2N1c0VuZFJvdyk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93Um93c0NvdW50ID0gaW50ZXJzZWN0aW9uU3RhcnQgPD0gaW50ZXJzZWN0aW9uRW5kID8gaW50ZXJzZWN0aW9uRW5kIC0gaW50ZXJzZWN0aW9uU3RhcnQgKyAxIDogMDtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gb3ZlcmZsb3dSb3dzQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gUm93cyBvdmVyZmxvd2luZyBib3R0b20gaGF2ZSB0byBiZSBtb3ZlZCB0byB0aGUgbmV4dCByb3dcbiAgICAgIGlmIChjZWxsU3RhcnRSb3cgPj0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cgJiZcbiAgICAgIC8vIEhhbmRsZSBvdmVyZmxvdyBvbmx5IG9uY2VcbiAgICAgIHJvdyA9PT0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgaWYgKCEobmV4dFJvd05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uOyBjb2x1bW5JbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudENlbGxNYXAgPSBuZXh0Um93W2NvbHVtbkluZGV4XTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgICAgLy8gQ2hlY2tpbmcgdGhlIGNlbGwgaGF2aW5nIHN0YXJ0Um93IGFzIHNhbWUgYXMgbmV4dFJvd1xuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gcm93ICsgMSkge1xuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0QWZ0ZXJDZWxsID09PSBudWxsKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KG5leHRSb3dOb2RlLCBjZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KHJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cbiAgICByb3dOb2RlLnJlbW92ZSgpO1xuICB9XG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCA9ICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uO1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uOiBhbmNob3JTdGFydENvbHVtblxuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uOiBmb2N1c1N0YXJ0Q29sdW1uXG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYW5jaG9yU3RhcnRDb2x1bW4sIGZvY3VzU3RhcnRDb2x1bW4pO1xuICBjb25zdCBlbmRDb2x1bW4gPSBNYXRoLm1heChhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5Db3VudCA9IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID09PSBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5zZWxlY3RQcmV2aW91cygpO1xuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPD0gZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uIDwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvd0xlZnQgPSBzdGFydENvbHVtbiAtIGNlbGxTdGFydENvbHVtbjtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyBsZWZ0XG4gICAgICAgICAgY2VsbC5zZXRDb2xTcGFuKGNlbGwuX19jb2xTcGFuIC1cbiAgICAgICAgICAvLyBQb3NzaWJsZSBvdmVyZmxvdyByaWdodCB0b29cbiAgICAgICAgICBNYXRoLm1pbihzZWxlY3RlZENvbHVtbkNvdW50LCBjZWxsLl9fY29sU3BhbiAtIG92ZXJmbG93TGVmdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSA+IGVuZENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyByaWdodFxuICAgICAgICAgIGNvbnN0IGluU2VsZWN0ZWRBcmVhID0gZW5kQ29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uICsgMTtcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSBpblNlbGVjdGVkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvY3VzUm93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgY29uc3QgbmV4dENvbHVtbiA9IGFuY2hvclN0YXJ0Q29sdW1uID4gZm9jdXNTdGFydENvbHVtbiA/IGZvY3VzUm93TWFwW2FuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW5dIDogZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW5dO1xuICBpZiAobmV4dENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Q29sdW1uO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZm9jdXNTdGFydENvbHVtbiA8IGFuY2hvclN0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiAtIDFdIDogZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93O1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG4gIGNvbnN0IGNvbFdpZHRocyA9IGdyaWQuZ2V0Q29sV2lkdGhzKCk7XG4gIGlmIChjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBuZXdDb2xXaWR0aHMgPSBbLi4uY29sV2lkdGhzXTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKHN0YXJ0Q29sdW1uLCBzZWxlY3RlZENvbHVtbkNvdW50KTtcbiAgICBncmlkLnNldENvbFdpZHRocyhuZXdDb2xXaWR0aHMpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb247XG5mdW5jdGlvbiAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKSB7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IGNlbGwuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmIChmaXJzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgIGNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICBmaXJzdERlc2NlbmRhbnQuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJG1lcmdlQ2VsbHMoY2VsbE5vZGVzKSB7XG4gIGlmIChjZWxsTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0YWJsZSBub2RlXG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KGNlbGxOb2Rlc1swXSk7XG4gIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgbnVsbCwgbnVsbCk7XG5cbiAgLy8gRmluZCB0aGUgYm91bmRhcmllcyBvZiB0aGUgc2VsZWN0aW9uIGluY2x1ZGluZyBtZXJnZWQgY2VsbHNcbiAgbGV0IG1pblJvdyA9IEluZmluaXR5O1xuICBsZXQgbWF4Um93ID0gLUluZmluaXR5O1xuICBsZXQgbWluQ29sID0gSW5maW5pdHk7XG4gIGxldCBtYXhDb2wgPSAtSW5maW5pdHk7XG5cbiAgLy8gRmlyc3QgcGFzczogZmluZCB0aGUgYWN0dWFsIGJvdW5kYXJpZXMgY29uc2lkZXJpbmcgbWVyZ2VkIGNlbGxzXG4gIGNvbnN0IHByb2Nlc3NlZENlbGxzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkTWFwKSB7XG4gICAgZm9yIChjb25zdCBtYXBDZWxsIG9mIHJvdykge1xuICAgICAgaWYgKCFtYXBDZWxsIHx8ICFtYXBDZWxsLmNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsS2V5ID0gbWFwQ2VsbC5jZWxsLmdldEtleSgpO1xuICAgICAgaWYgKHByb2Nlc3NlZENlbGxzLmhhcyhjZWxsS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsTm9kZXMuc29tZShjZWxsID0+IGNlbGwuaXMobWFwQ2VsbC5jZWxsKSkpIHtcbiAgICAgICAgcHJvY2Vzc2VkQ2VsbHMuYWRkKGNlbGxLZXkpO1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBwb3NpdGlvbiBvZiB0aGlzIGNlbGwgaW4gdGhlIGdyaWRcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Um93ID0gbWFwQ2VsbC5zdGFydFJvdztcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Q29sID0gbWFwQ2VsbC5zdGFydENvbHVtbjtcbiAgICAgICAgY29uc3QgY2VsbFJvd1NwYW4gPSBtYXBDZWxsLmNlbGwuX19yb3dTcGFuIHx8IDE7XG4gICAgICAgIGNvbnN0IGNlbGxDb2xTcGFuID0gbWFwQ2VsbC5jZWxsLl9fY29sU3BhbiB8fCAxO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBib3VuZGFyaWVzIGNvbnNpZGVyaW5nIHRoZSBjZWxsJ3MgYWN0dWFsIHBvc2l0aW9uIGFuZCBzcGFuXG4gICAgICAgIG1pblJvdyA9IE1hdGgubWluKG1pblJvdywgY2VsbFN0YXJ0Um93KTtcbiAgICAgICAgbWF4Um93ID0gTWF0aC5tYXgobWF4Um93LCBjZWxsU3RhcnRSb3cgKyBjZWxsUm93U3BhbiAtIDEpO1xuICAgICAgICBtaW5Db2wgPSBNYXRoLm1pbihtaW5Db2wsIGNlbGxTdGFydENvbCk7XG4gICAgICAgIG1heENvbCA9IE1hdGgubWF4KG1heENvbCwgY2VsbFN0YXJ0Q29sICsgY2VsbENvbFNwYW4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBib3VuZGFyaWVzXG4gIGlmIChtaW5Sb3cgPT09IEluZmluaXR5IHx8IG1pbkNvbCA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBzcGFuIG9mIHRoZSBtZXJnZWQgY2VsbFxuICBjb25zdCB0b3RhbFJvd1NwYW4gPSBtYXhSb3cgLSBtaW5Sb3cgKyAxO1xuICBjb25zdCB0b3RhbENvbFNwYW4gPSBtYXhDb2wgLSBtaW5Db2wgKyAxO1xuXG4gIC8vIFVzZSB0aGUgdG9wLWxlZnQgY2VsbCBhcyB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3QgdGFyZ2V0Q2VsbE1hcCA9IGdyaWRNYXBbbWluUm93XVttaW5Db2xdO1xuICBpZiAoIXRhcmdldENlbGxNYXAuY2VsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRhcmdldENlbGwgPSB0YXJnZXRDZWxsTWFwLmNlbGw7XG5cbiAgLy8gU2V0IHRoZSBzcGFucyBmb3IgdGhlIHRhcmdldCBjZWxsXG4gIHRhcmdldENlbGwuc2V0Q29sU3Bhbih0b3RhbENvbFNwYW4pO1xuICB0YXJnZXRDZWxsLnNldFJvd1NwYW4odG90YWxSb3dTcGFuKTtcblxuICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSBvdGhlciBjZWxscyB0byB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3Qgc2VlbkNlbGxzID0gbmV3IFNldChbdGFyZ2V0Q2VsbC5nZXRLZXkoKV0pO1xuXG4gIC8vIFNlY29uZCBwYXNzOiBtZXJnZSBjb250ZW50IGFuZCByZW1vdmUgb3RoZXIgY2VsbHNcbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IG1pbkNvbDsgY29sIDw9IG1heENvbDsgY29sKyspIHtcbiAgICAgIGNvbnN0IG1hcENlbGwgPSBncmlkTWFwW3Jvd11bY29sXTtcbiAgICAgIGlmICghbWFwQ2VsbC5jZWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudENlbGwgPSBtYXBDZWxsLmNlbGw7XG4gICAgICBjb25zdCBrZXkgPSBjdXJyZW50Q2VsbC5nZXRLZXkoKTtcbiAgICAgIGlmICghc2VlbkNlbGxzLmhhcyhrZXkpKSB7XG4gICAgICAgIHNlZW5DZWxscy5hZGQoa2V5KTtcbiAgICAgICAgY29uc3QgaXNFbXB0eSA9ICRjZWxsQ29udGFpbnNFbXB0eVBhcmFncmFwaChjdXJyZW50Q2VsbCk7XG4gICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgIHRhcmdldENlbGwuYXBwZW5kKC4uLmN1cnJlbnRDZWxsLmdldENoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDZWxsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgY2VsbCBoYXMgY29udGVudFxuICBpZiAodGFyZ2V0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgIHRhcmdldENlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIHJldHVybiB0YXJnZXRDZWxsO1xufVxuZnVuY3Rpb24gJGNlbGxDb250YWluc0VtcHR5UGFyYWdyYXBoKGNlbGwpIHtcbiAgaWYgKGNlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGNlbGwuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKTtcbiAgaWYgKCEkaXNQYXJhZ3JhcGhOb2RlKGZpcnN0Q2hpbGQpIHx8ICFmaXJzdENoaWxkLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICR1bm1lcmdlQ2VsbCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgfVxuICByZXR1cm4gJHVubWVyZ2VDZWxsTm9kZShjZWxsTm9kZSk7XG59XG5mdW5jdGlvbiAkdW5tZXJnZUNlbGxOb2RlKGNlbGxOb2RlKSB7XG4gIGNvbnN0IFtjZWxsLCByb3csIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG4gIGlmIChjb2xTcGFuID09PSAxICYmIHJvd1NwYW4gPT09IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW21hcCwgY2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGwsIGNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW4sXG4gICAgc3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIC8vIENyZWF0ZSBhIGhldXJpc3RpYyBmb3Igd2hhdCB0aGUgc3R5bGUgb2YgdGhlIHVubWVyZ2VkIGNlbGxzIHNob3VsZCBiZVxuICAvLyBiYXNlZCBvbiB3aGV0aGVyIGV2ZXJ5IHJvdyBvciBjb2x1bW4gYWxyZWFkeSBoYWQgdGhhdCBzdGF0ZSBiZWZvcmUgdGhlXG4gIC8vIHVubWVyZ2UuXG4gIGNvbnN0IGJhc2VDb2xTdHlsZSA9IGNlbGwuX19oZWFkZXJTdGF0ZSAmIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gIGNvbnN0IGNvbFN0eWxlcyA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogY29sU3BhblxuICB9LCAoX3YsIGkpID0+IHtcbiAgICBsZXQgY29sU3R5bGUgPSBiYXNlQ29sU3R5bGU7XG4gICAgZm9yIChsZXQgcm93SWR4ID0gMDsgY29sU3R5bGUgIT09IDAgJiYgcm93SWR4IDwgbWFwLmxlbmd0aDsgcm93SWR4KyspIHtcbiAgICAgIGNvbFN0eWxlICY9IG1hcFtyb3dJZHhdW2kgKyBzdGFydENvbHVtbl0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY29sU3R5bGU7XG4gIH0pO1xuICBjb25zdCBiYXNlUm93U3R5bGUgPSBjZWxsLl9faGVhZGVyU3RhdGUgJiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICBjb25zdCByb3dTdHlsZXMgPSBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IHJvd1NwYW5cbiAgfSwgKF92LCBpKSA9PiB7XG4gICAgbGV0IHJvd1N0eWxlID0gYmFzZVJvd1N0eWxlO1xuICAgIGZvciAobGV0IGNvbElkeCA9IDA7IHJvd1N0eWxlICE9PSAwICYmIGNvbElkeCA8IG1hcFswXS5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICByb3dTdHlsZSAmPSBtYXBbaSArIHN0YXJ0Um93XVtjb2xJZHhdLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd1N0eWxlO1xuICB9KTtcbiAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgIGNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2ldIHwgcm93U3R5bGVzWzBdKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgIH1cbiAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gIH1cbiAgaWYgKHJvd1NwYW4gPiAxKSB7XG4gICAgbGV0IGN1cnJlbnRSb3dOb2RlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gc3RhcnRSb3cgKyBpO1xuICAgICAgY29uc3QgY3VycmVudFJvd01hcCA9IG1hcFtjdXJyZW50Um93XTtcbiAgICAgIGN1cnJlbnRSb3dOb2RlID0gKGN1cnJlbnRSb3dOb2RlIHx8IHJvdykuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3dOb2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHJvdyBuZXh0IHNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgc3RhcnRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsTWFwID0gY3VycmVudFJvd01hcFtjb2x1bW5dO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gY3VycmVudFJvdykge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgY29sdW1uICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbFNwYW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChjdXJyZW50Um93Tm9kZSwgJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2pdIHwgcm93U3R5bGVzW2ldKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gY29sU3BhbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tqXSB8IHJvd1N0eWxlc1tpXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBjZWxsQSwgY2VsbEIpIHtcbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsQVZhbHVlLCBjZWxsQlZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgY2VsbEEsIGNlbGxCKTtcbiAgaWYgKCEoY2VsbEFWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEFuY2hvciBub3QgZm91bmQgaW4gVGFibGVgKTtcbiAgfVxuICBpZiAoIShjZWxsQlZhbHVlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRm9jdXMgbm90IGZvdW5kIGluIFRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayh0YWJsZU5vZGUsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCB0YWJsZU1hcCA9IFtdO1xuICBsZXQgY2VsbEFWYWx1ZSA9IG51bGw7XG4gIGxldCBjZWxsQlZhbHVlID0gbnVsbDtcbiAgZnVuY3Rpb24gZ2V0TWFwUm93KGkpIHtcbiAgICBsZXQgcm93ID0gdGFibGVNYXBbaV07XG4gICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWJsZU1hcFtpXSA9IHJvdyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xuICB9XG4gIGNvbnN0IGdyaWRDaGlsZHJlbiA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCBncmlkQ2hpbGRyZW4ubGVuZ3RoOyByb3dJZHgrKykge1xuICAgIGNvbnN0IHJvdyA9IGdyaWRDaGlsZHJlbltyb3dJZHhdO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE1hcFJvdyA9IGdldE1hcFJvdyhyb3dJZHgpO1xuICAgIGZvciAobGV0IGNlbGwgPSByb3cuZ2V0Rmlyc3RDaGlsZCgpLCBjb2xJZHggPSAwOyBjZWxsICE9IG51bGw7IGNlbGwgPSBjZWxsLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlUm93Tm9kZSBjaGlsZHJlbiB0byBiZSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICB9IC8vIFNraXAgcGFzdCBhbnkgY29sdW1ucyB0aGF0IHdlcmUgbWVyZ2VkIGZyb20gYSBoaWdoZXIgcm93XG4gICAgICB3aGlsZSAoc3RhcnRNYXBSb3dbY29sSWR4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbElkeCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjb2xJZHgsXG4gICAgICAgIHN0YXJ0Um93OiByb3dJZHhcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIF9fcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgX19jb2xTcGFuOiBjb2xTcGFuXG4gICAgICB9ID0gY2VsbDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U3BhbjsgaisrKSB7XG4gICAgICAgIGlmIChyb3dJZHggKyBqID49IGdyaWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgdGFibGUgaXMgbm9uLXJlY3Rhbmd1bGFyIHdpdGggYSByb3dTcGFuXG4gICAgICAgICAgLy8gYmVsb3cgdGhlIGxhc3QgPHRyPiBpbiB0aGUgdGFibGUuXG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGhhbmRsZSB0aGlzIHdpdGggYSBub2RlIHRyYW5zZm9ybVxuICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRhYmxlcyBhcmUgYWx3YXlzIHJlY3Rhbmd1bGFyIGJ1dCB0aGlzXG4gICAgICAgICAgLy8gd2lsbCBhdm9pZCBjcmFzaGVzIHN1Y2ggYXMgIzY1ODRcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgYXJlIHByb2JhYmx5IHN0aWxsIGxhdGVudCBidWdzXG4gICAgICAgICAgLy8gcmVnYXJkaW5nIGNvbFNwYW4gb3IgZ2VuZXJhbCBjZWxsIGNvdW50IG1pc21hdGNoZXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCArIGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgICAgIG1hcFJvd1tjb2xJZHggKyBpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEEgIT09IG51bGwgJiYgY2VsbEFWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQS5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQVZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEIgIT09IG51bGwgJiYgY2VsbEJWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQi5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKCdfX3R5cGUnIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgdG8gZmluZCBhIHBhcmVudCBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNlbGwgPSBjZWxsXztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjZWxsXyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc291cmNlLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9XG4gIGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgfVxuICBjb25zdCBncmlkID0gcm93LmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlTm9kZShncmlkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIHRvIGhhdmUgYSBwYXJlbnQgVGFibGVOb2RlYCk7XG4gIH1cbiAgcmV0dXJuIFtjZWxsLCByb3csIGdyaWRdO1xufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZUNlbGxSZWN0U3BhbnMobWFwLCBib3VuZGFyeSkge1xuICBjb25zdCB7XG4gICAgbWluQ29sdW1uLFxuICAgIG1heENvbHVtbixcbiAgICBtaW5Sb3csXG4gICAgbWF4Um93XG4gIH0gPSBib3VuZGFyeTtcbiAgbGV0IHRvcFNwYW4gPSAxO1xuICBsZXQgbGVmdFNwYW4gPSAxO1xuICBsZXQgcmlnaHRTcGFuID0gMTtcbiAgbGV0IGJvdHRvbVNwYW4gPSAxO1xuICBjb25zdCB0b3BSb3cgPSBtYXBbbWluUm93XTtcbiAgY29uc3QgYm90dG9tUm93ID0gbWFwW21heFJvd107XG4gIGZvciAobGV0IGNvbCA9IG1pbkNvbHVtbjsgY29sIDw9IG1heENvbHVtbjsgY29sKyspIHtcbiAgICB0b3BTcGFuID0gTWF0aC5tYXgodG9wU3BhbiwgdG9wUm93W2NvbF0uY2VsbC5fX3Jvd1NwYW4pO1xuICAgIGJvdHRvbVNwYW4gPSBNYXRoLm1heChib3R0b21TcGFuLCBib3R0b21Sb3dbY29sXS5jZWxsLl9fcm93U3Bhbik7XG4gIH1cbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGxlZnRTcGFuID0gTWF0aC5tYXgobGVmdFNwYW4sIG1hcFtyb3ddW21pbkNvbHVtbl0uY2VsbC5fX2NvbFNwYW4pO1xuICAgIHJpZ2h0U3BhbiA9IE1hdGgubWF4KHJpZ2h0U3BhbiwgbWFwW3Jvd11bbWF4Q29sdW1uXS5jZWxsLl9fY29sU3Bhbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3R0b21TcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIHJpZ2h0U3BhbixcbiAgICB0b3BTcGFuXG4gIH07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RCb3VuZGFyeShtYXAsIGNlbGxBTWFwLCBjZWxsQk1hcCkge1xuICAvLyBJbml0aWFsIGJvdW5kYXJpZXMgYmFzZWQgb24gdGhlIGFuY2hvciBhbmQgZm9jdXMgY2VsbHNcbiAgbGV0IG1pbkNvbHVtbiA9IE1hdGgubWluKGNlbGxBTWFwLnN0YXJ0Q29sdW1uLCBjZWxsQk1hcC5zdGFydENvbHVtbik7XG4gIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICBsZXQgbWF4Q29sdW1uID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQU1hcC5jZWxsLl9fY29sU3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Q29sdW1uICsgY2VsbEJNYXAuY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgbGV0IG1heFJvdyA9IE1hdGgubWF4KGNlbGxBTWFwLnN0YXJ0Um93ICsgY2VsbEFNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxLCBjZWxsQk1hcC5zdGFydFJvdyArIGNlbGxCTWFwLmNlbGwuX19yb3dTcGFuIC0gMSk7XG5cbiAgLy8gS2VlcCBleHBhbmRpbmcgdW50aWwgd2UgaGF2ZSBhIGNvbXBsZXRlIHJlY3RhbmdsZVxuICBsZXQgaGFzQ2hhbmdlcztcbiAgZG8ge1xuICAgIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBjZWxscyBpbiB0aGUgdGFibGVcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAubGVuZ3RoOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWFwWzBdLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IG1hcFtyb3ddW2NvbF07XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxFbmRDb2wgPSBjZWxsLnN0YXJ0Q29sdW1uICsgY2VsbC5jZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIGNvbnN0IGNlbGxFbmRSb3cgPSBjZWxsLnN0YXJ0Um93ICsgY2VsbC5jZWxsLl9fcm93U3BhbiAtIDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjZWxsIGludGVyc2VjdHMgd2l0aCBvdXIgY3VycmVudCBzZWxlY3Rpb24gcmVjdGFuZ2xlXG4gICAgICAgIGNvbnN0IGludGVyc2VjdHNIb3Jpem9udGFsbHkgPSBjZWxsLnN0YXJ0Q29sdW1uIDw9IG1heENvbHVtbiAmJiBjZWxsRW5kQ29sID49IG1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0c1ZlcnRpY2FsbHkgPSBjZWxsLnN0YXJ0Um93IDw9IG1heFJvdyAmJiBjZWxsRW5kUm93ID49IG1pblJvdztcblxuICAgICAgICAvLyBJZiB0aGUgY2VsbCBpbnRlcnNlY3RzIGVpdGhlciBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgICAgICBpZiAoaW50ZXJzZWN0c0hvcml6b250YWxseSAmJiBpbnRlcnNlY3RzVmVydGljYWxseSkge1xuICAgICAgICAgIC8vIEV4cGFuZCBib3VuZGFyaWVzIHRvIGluY2x1ZGUgdGhpcyBjZWxsIGNvbXBsZXRlbHlcbiAgICAgICAgICBjb25zdCBuZXdNaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGwuc3RhcnRDb2x1bW4pO1xuICAgICAgICAgIGNvbnN0IG5ld01heENvbHVtbiA9IE1hdGgubWF4KG1heENvbHVtbiwgY2VsbEVuZENvbCk7XG4gICAgICAgICAgY29uc3QgbmV3TWluUm93ID0gTWF0aC5taW4obWluUm93LCBjZWxsLnN0YXJ0Um93KTtcbiAgICAgICAgICBjb25zdCBuZXdNYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxFbmRSb3cpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYm91bmRhcmllcyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKG5ld01pbkNvbHVtbiAhPT0gbWluQ29sdW1uIHx8IG5ld01heENvbHVtbiAhPT0gbWF4Q29sdW1uIHx8IG5ld01pblJvdyAhPT0gbWluUm93IHx8IG5ld01heFJvdyAhPT0gbWF4Um93KSB7XG4gICAgICAgICAgICBtaW5Db2x1bW4gPSBuZXdNaW5Db2x1bW47XG4gICAgICAgICAgICBtYXhDb2x1bW4gPSBuZXdNYXhDb2x1bW47XG4gICAgICAgICAgICBtaW5Sb3cgPSBuZXdNaW5Sb3c7XG4gICAgICAgICAgICBtYXhSb3cgPSBuZXdNYXhSb3c7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGhhc0NoYW5nZXMpO1xuICByZXR1cm4ge1xuICAgIG1heENvbHVtbixcbiAgICBtYXhSb3csXG4gICAgbWluQ29sdW1uLFxuICAgIG1pblJvd1xuICB9O1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgW2NlbGxOb2RlLCwgZ3JpZE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCByb3dzID0gZ3JpZE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3Qgcm93Q291bnQgPSByb3dzLmxlbmd0aDtcbiAgY29uc3QgY29sdW1uQ291bnQgPSByb3dzWzBdLmdldENoaWxkcmVuKCkubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSBhIG1hdHJpeCBvZiB0aGUgc2FtZSBzaXplIGFzIHRoZSB0YWJsZSB0byB0cmFjayB0aGUgcG9zaXRpb24gb2YgZWFjaCBjZWxsXG4gIGNvbnN0IGNlbGxNYXRyaXggPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBjZWxsTWF0cml4W2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgfVxuICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcbiAgICBjb25zdCByb3cgPSByb3dzW3Jvd0luZGV4XTtcbiAgICBjb25zdCBjZWxscyA9IHJvdy5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY2VsbEluZGV4ID0gMDsgY2VsbEluZGV4IDwgY2VsbHMubGVuZ3RoOyBjZWxsSW5kZXgrKykge1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBhdmFpbGFibGUgcG9zaXRpb24gaW4gdGhlIG1hdHJpeCwgc2tpcCB0aGUgcG9zaXRpb24gb2YgbWVyZ2VkIGNlbGxzXG4gICAgICB3aGlsZSAoY2VsbE1hdHJpeFtyb3dJbmRleF1bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgIGNvbHVtbkluZGV4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsID0gY2VsbHNbY2VsbEluZGV4XTtcbiAgICAgIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbiB8fCAxO1xuICAgICAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuIHx8IDE7XG5cbiAgICAgIC8vIFB1dCB0aGUgY2VsbCBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBtYXRyaXhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgICAgY2VsbE1hdHJpeFtyb3dJbmRleCArIGldW2NvbHVtbkluZGV4ICsgal0gPSBjZWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0byB0aGUgb3JpZ2luYWwgaW5kZXgsIHJvdyBzcGFuIGFuZCBjb2x1bW4gc3BhbiBvZiB0aGUgY2VsbC5cbiAgICAgIGlmIChjZWxsTm9kZSA9PT0gY2VsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbFNwYW4sXG4gICAgICAgICAgY29sdW1uSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgcm93U3BhblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29sdW1uSW5kZXggKz0gY29sU3BhbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uICRnZXRDZWxsTm9kZXModGFibGVTZWxlY3Rpb24pIHtcbiAgY29uc3QgW1thbmNob3JOb2RlLCBhbmNob3JDZWxsLCBhbmNob3JSb3csIGFuY2hvclRhYmxlXSwgW2ZvY3VzTm9kZSwgZm9jdXNDZWxsLCBmb2N1c1JvdywgZm9jdXNUYWJsZV1dID0gWydhbmNob3InLCAnZm9jdXMnXS5tYXAoayA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRhYmxlU2VsZWN0aW9uW2tdLmdldE5vZGUoKTtcbiAgICBjb25zdCBjZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiAke2t9IHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlLCBnb3Qga2V5ICR7bm9kZS5nZXRLZXkoKX0gb2YgdHlwZSAke25vZGUuZ2V0VHlwZSgpfWApO1xuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gY2VsbE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSBjZWxsIHBhcmVudCB0byBiZSBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5vZGUgPSByb3dOb2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSByb3cgcGFyZW50IHRvIGJlIGEgVGFibGVOb2RlYCk7XG4gICAgfVxuICAgIHJldHVybiBbbm9kZSwgY2VsbE5vZGUsIHJvd05vZGUsIHRhYmxlTm9kZV07XG4gIH0pO1xuICAvLyBUT0RPOiBuZXN0ZWQgdGFibGVzIG1heSB2aW9sYXRlIHRoaXNcbiAgaWYgKCFhbmNob3JUYWJsZS5pcyhmb2N1c1RhYmxlKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gYW5jaG9yIGFuZCBmb2N1cyB0byBiZSBpbiB0aGUgc2FtZSB0YWJsZWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yQ2VsbCxcbiAgICBhbmNob3JOb2RlLFxuICAgIGFuY2hvclJvdyxcbiAgICBhbmNob3JUYWJsZSxcbiAgICBmb2N1c0NlbGwsXG4gICAgZm9jdXNOb2RlLFxuICAgIGZvY3VzUm93LFxuICAgIGZvY3VzVGFibGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFibGVLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayAkY3JlYXRlVGFibGVTZWxlY3Rpb259IHVuZm9ydHVuYXRlbHkgbWFrZXMgaXQgdmVyeSBlYXN5IHRvIGNyZWF0ZVxuICAgKiBub25zZW5zZSBzZWxlY3Rpb25zLCBzbyB3ZSBoYXZlIGEgbWV0aG9kIHRvIHNlZSBpZiB0aGUgc2VsZWN0aW9uIHByb2JhYmx5XG4gICAqIG1ha2VzIHNlbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUYWJsZVNlbGVjdGlvbiBpcyAocHJvYmFibHkpIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlS2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3Iua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRoaXMuZm9jdXMua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5mb2N1cy50eXBlID09PSAnZWxlbWVudCc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRDYWNoZWROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTm9kZXM7XG4gIH1cbiAgc2V0Q2FjaGVkTm9kZXMobm9kZXMpIHtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICB9XG4gIGlzKHNlbGVjdGlvbikge1xuICAgIHJldHVybiAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHRoaXMudGFibGVLZXkgPT09IHNlbGVjdGlvbi50YWJsZUtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cbiAgc2V0KHRhYmxlS2V5LCBhbmNob3JDZWxsS2V5LCBmb2N1c0NlbGxLZXkpIHtcbiAgICAvLyBub3RlOiBjbG9zdXJlIGNvbXBpbGVyJ3MgYWNvcm4gZG9lcyBub3Qgc3VwcG9ydCB8fD1cbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5kaXJ0eSB8fCB0YWJsZUtleSAhPT0gdGhpcy50YWJsZUtleSB8fCBhbmNob3JDZWxsS2V5ICE9PSB0aGlzLmFuY2hvci5rZXkgfHwgZm9jdXNDZWxsS2V5ICE9PSB0aGlzLmZvY3VzLmtleTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbih0aGlzLnRhYmxlS2V5LCAkY3JlYXRlUG9pbnQodGhpcy5hbmNob3Iua2V5LCB0aGlzLmFuY2hvci5vZmZzZXQsIHRoaXMuYW5jaG9yLnR5cGUpLCAkY3JlYXRlUG9pbnQodGhpcy5mb2N1cy5rZXksIHRoaXMuZm9jdXMub2Zmc2V0LCB0aGlzLmZvY3VzLnR5cGUpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXh0cmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2RlcygpO1xuICB9XG4gIGluc2VydFJhd1RleHQodGV4dCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0VGV4dCgpIHtcbiAgICAvLyBEbyBub3RoaW5nP1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgaXMgcHJlc2VudCBvbiB0aGUgU2VsZWN0aW9uLlxuICAgKiBUaGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbnkgcGFyYWdyYXBoIGluIHRhYmxlIGNlbGxzIGhhcyB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgZm9ybWF0IGlzIGN1cnJlbnRseSB0b2dnbGVkIG9uIG9uIHRoZSBTZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgbGV0IGZvcm1hdCA9IDA7XG4gICAgY29uc3QgY2VsbE5vZGVzID0gdGhpcy5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjZWxsTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzUGFyYWdyYXBoTm9kZShwYXJhZ3JhcGgpKSB7XG4gICAgICAgIGZvcm1hdCB8PSBwYXJhZ3JhcGguZ2V0VGV4dEZvcm1hdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiAoZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGZvY3VzTm9kZS5zZWxlY3QoMCwgZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpKSk7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIC8vIFRPRE8gRGVwcmVjYXRlIHRoaXMgbWV0aG9kLiBJdCdzIGNvbmZ1c2luZyB3aGVuIHVzZWQgd2l0aCBjb2xzcGFufHJvd3NwYW5cbiAgZ2V0U2hhcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlUmVjdCA9ICRnZXRUYWJsZUNlbGxOb2RlUmVjdChhbmNob3JDZWxsKTtcbiAgICBpZiAoIShhbmNob3JDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGdldENlbGxSZWN0OiBleHBlY3RlZCB0byBmaW5kIEFuY2hvck5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoZm9jdXNDZWxsKTtcbiAgICBpZiAoIShmb2N1c0NlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgZm9jdXNDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5taW4oYW5jaG9yQ2VsbE5vZGVSZWN0LnJvd0luZGV4LCBmb2N1c0NlbGxOb2RlUmVjdC5yb3dJbmRleCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1heChhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBhbmNob3JDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4ICsgZm9jdXNDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tWDogTWF0aC5taW4oc3RhcnRYLCBzdG9wWCksXG4gICAgICBmcm9tWTogTWF0aC5taW4oc3RhcnRZLCBzdG9wWSksXG4gICAgICB0b1g6IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgdG9ZOiBNYXRoLm1heChzdGFydFksIHN0b3BZKVxuICAgIH07XG4gIH1cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JUYWJsZTogdGFibGVOb2RlLFxuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbEdyaWQgPSBmb2N1c0NlbGwuZ2V0UGFyZW50cygpWzFdO1xuICAgIGlmIChmb2N1c0NlbGxHcmlkICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgIGlmICghdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNDZWxsKSkge1xuICAgICAgICAvLyBmb2N1cyBpcyBvbiBoaWdoZXIgR3JpZCBsZXZlbCB0aGFuIGFuY2hvclxuICAgICAgICBjb25zdCBncmlkUGFyZW50ID0gdGFibGVOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoIShncmlkUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBncmlkUGFyZW50IHRvIGhhdmUgYSBwYXJlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCh0aGlzLnRhYmxlS2V5LCBncmlkUGFyZW50LmdldEtleSgpLCBmb2N1c0NlbGwuZ2V0S2V5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jaG9yIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gZm9jdXNcbiAgICAgICAgY29uc3QgZm9jdXNDZWxsUGFyZW50ID0gZm9jdXNDZWxsR3JpZC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZm9jdXNDZWxsUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBmb2N1c0NlbGxQYXJlbnQgdG8gaGF2ZSBhIHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudGFibGVLZXksIGZvY3VzQ2VsbC5nZXRLZXkoKSwgZm9jdXNDZWxsUGFyZW50LmdldEtleSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBNYXBwaW5nIHRoZSB3aG9sZSBHcmlkIGV2ZXJ5IHRpbWUgbm90IGVmZmljaWVudC4gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBlbnRpcmUgc3RhdGUgb25seVxuICAgIC8vIG9uY2UgKG9uIGxvYWQpIGFuZCBpdGVyYXRlIG9uIGl0IGFzIHVwZGF0ZXMgb2NjdXIuIEhvd2V2ZXIsIHRvIGRvIHRoaXMgd2UgbmVlZCB0byBoYXZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gc3RvcmUgYSBzdGF0ZS4gS2lsbGluZyBUYWJsZVNlbGVjdGlvbiBhbmQgbW92aW5nIHRoZSBsb2dpYyB0byB0aGUgcGx1Z2luIHdvdWxkIG1ha2VcbiAgICAvLyB0aGlzIHBvc3NpYmxlLlxuICAgIGNvbnN0IFttYXAsIGNlbGxBTWFwLCBjZWxsQk1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBtaW5Db2x1bW4sXG4gICAgICBtYXhDb2x1bW4sXG4gICAgICBtaW5Sb3csXG4gICAgICBtYXhSb3dcbiAgICB9ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkobWFwLCBjZWxsQU1hcCwgY2VsbEJNYXApO1xuXG4gICAgLy8gV2UgdXNlIGEgTWFwIGhlcmUgYmVjYXVzZSBtZXJnZWQgY2VsbHMgaW4gdGhlIGdyaWQgd291bGQgb3RoZXJ3aXNlXG4gICAgLy8gc2hvdyB1cCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgbm9kZXMgYXJyYXlcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcChbW3RhYmxlTm9kZS5nZXRLZXkoKSwgdGFibGVOb2RlXV0pO1xuICAgIGxldCBsYXN0Um93ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gbWluUm93OyBpIDw9IG1heFJvdzsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbWluQ29sdW1uOyBqIDw9IG1heENvbHVtbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjZWxsXG4gICAgICAgIH0gPSBtYXBbaV1bal07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSBwYXJlbnQgdG8gYmUgYSBUYWJsZVJvd05vZGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgICAgIG5vZGVNYXAuc2V0KGN1cnJlbnRSb3cuZ2V0S2V5KCksIGN1cnJlbnRSb3cpO1xuICAgICAgICAgIGxhc3RSb3cgPSBjdXJyZW50Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZU1hcC5oYXMoY2VsbC5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAkdmlzaXRSZWN1cnNpdmVseShjZWxsLCBjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZU1hcC5zZXQoY2hpbGROb2RlLmdldEtleSgpLCBjaGlsZE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShub2RlTWFwLnZhbHVlcygpKTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKS5maWx0ZXIobm9kZSA9PiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBjb25zdCByb3cgPSBub2RlLl9fcGFyZW50O1xuICAgICAgY29uc3QgbmV4dFJvdyA9IChub2Rlc1tpICsgMV0gfHwge30pLl9fcGFyZW50O1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS5nZXRUZXh0Q29udGVudCgpICsgKG5leHRSb3cgIT09IHJvdyA/ICdcXG4nIDogJ1xcdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1RhYmxlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBUYWJsZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpIHtcbiAgLy8gVE9ETyB0aGlzIGlzIGEgc3Vib3B0aW1hbCBkZXNpZ24sIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlXG4gIC8vIGEgdGFibGUgc2VsZWN0aW9uIHRoYXQgaXNuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgdGFibGUuIFRoaXNcbiAgLy8gY29uc3RydWN0b3Igc2hvdWxkIGhhdmUgcmVxdWlyZWQgYXJndW1lbnRzIGFuZCBpbiB0cnVlIHdlXG4gIC8vIHNob3VsZCBjaGVjayB0aGF0IHRoZXkgcG9pbnQgdG8gYSB0YWJsZSBhbmQgYXJlIGVsZW1lbnQgcG9pbnRzIHRvXG4gIC8vIGNlbGwgbm9kZXMgb2YgdGhhdCB0YWJsZS5cbiAgY29uc3QgYW5jaG9yID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgY29uc3QgZm9jdXMgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKCdyb290JywgYW5jaG9yLCBmb2N1cyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKSB7XG4gIGNvbnN0IHRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgYW5jaG9yQ2VsbEtleSA9IGFuY2hvckNlbGwuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzQ2VsbEtleSA9IGZvY3VzQ2VsbC5nZXRLZXkoKTtcbiAge1xuICAgIGlmICghdGFibGVOb2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tOiB0YWJsZU5vZGUgJHt0YWJsZU5vZGVLZXl9IGlzIG5vdCBhdHRhY2hlZGApO1xuICAgIH1cbiAgICBpZiAoIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogYW5jaG9yQ2VsbCAke2FuY2hvckNlbGxLZXl9IGlzIG5vdCBpbiB0YWJsZSAke3RhYmxlTm9kZUtleX1gKTtcbiAgICB9XG4gICAgaWYgKCF0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogZm9jdXNDZWxsICR7Zm9jdXNDZWxsS2V5fSBpcyBub3QgaW4gdGFibGUgJHt0YWJsZU5vZGVLZXl9YCk7XG4gICAgfSAvLyBUT0RPOiBDaGVjayBmb3IgcmVjdGFuZ3VsYXIgZ3JpZFxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSA/IHByZXZTZWxlY3Rpb24uY2xvbmUoKSA6ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICBuZXh0U2VsZWN0aW9uLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIGFuY2hvckNlbGwuZ2V0S2V5KCksIGZvY3VzQ2VsbC5nZXRLZXkoKSk7XG4gIHJldHVybiBuZXh0U2VsZWN0aW9uO1xufVxuXG4vKipcbiAqIERlcHRoIGZpcnN0IHZpc2l0b3JcbiAqIEBwYXJhbSBub2RlIFRoZSBzdGFydGluZyBub2RlXG4gKiBAcGFyYW0gJHZpc2l0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIG5vZGUuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGVuIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSB3aWxsIG5vdCBiZSBleHBsb3JlZFxuICovXG5mdW5jdGlvbiAkdmlzaXRSZWN1cnNpdmVseShub2RlLCAkdmlzaXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbW25vZGVdXTtcbiAgZm9yIChsZXQgY3VycmVudEFycmF5ID0gc3RhY2suYXQoLTEpOyBjdXJyZW50QXJyYXkgIT09IHVuZGVmaW5lZCAmJiBzdGFjay5sZW5ndGggPiAwOyBjdXJyZW50QXJyYXkgPSBzdGFjay5hdCgtMSkpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGN1cnJlbnRBcnJheS5wb3AoKTtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmICgkdmlzaXQoY3VycmVudE5vZGUpICE9PSBmYWxzZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnB1c2goY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRnZXRUYWJsZUFuZEVsZW1lbnRCeUtleSh0YWJsZU5vZGVLZXksIGVkaXRvciA9ICRnZXRFZGl0b3IoKSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRhYmxlTm9kZUtleSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXI6IEV4cGVjdGVkIHRhYmxlTm9kZUtleSAke3RhYmxlTm9kZUtleX0gdG8gYmUgYSBUYWJsZU5vZGVgKTtcbiAgfVxuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZUtleSkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZU9ic2VydmVyOiBFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00gZm9yIGtleSAke3RhYmxlTm9kZUtleX1gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhYmxlRWxlbWVudCxcbiAgICB0YWJsZU5vZGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IsIHRhYmxlTm9kZUtleSkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yWCA9IC0xO1xuICAgIHRoaXMuYW5jaG9yWSA9IC0xO1xuICAgIHRoaXMuZm9jdXNYID0gLTE7XG4gICAgdGhpcy5mb2N1c1kgPSAtMTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMudGFibGVOb2RlS2V5ID0gdGFibGVOb2RlS2V5O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMudGFibGUgPSB7XG4gICAgICBjb2x1bW5zOiAwLFxuICAgICAgZG9tUm93czogW10sXG4gICAgICByb3dzOiAwXG4gICAgfTtcbiAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMubGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9O1xuICAgIHRoaXMubmV4dEZvY3VzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrVGFibGUoKTtcbiAgfVxuICBnZXRUYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoJ3JlbW92ZUxpc3RlbmVycycpO1xuICAgIEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnNUb1JlbW92ZSkuZm9yRWFjaChyZW1vdmVMaXN0ZW5lciA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlLmNsZWFyKCk7XG4gIH1cbiAgJGxvb2t1cCgpIHtcbiAgICByZXR1cm4gJGdldFRhYmxlQW5kRWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgdHJhY2tUYWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnVEFCTEUnIHx8IG5vZGVOYW1lID09PSAnVEJPRFknIHx8IG5vZGVOYW1lID09PSAnVEhFQUQnIHx8IG5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgICBncmlkTmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0YWJsZU5vZGUsXG4gICAgICAgICAgdGFibGVFbGVtZW50XG4gICAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgICAgdGhpcy50YWJsZSA9IGdldFRhYmxlKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50KTtcbiAgICAgIH0sIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFibGVOb2RlLFxuICAgICAgICB0YWJsZUVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3JcbiAgICB9KTtcbiAgfVxuICAkY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVOb2RlLFxuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIGdyaWQsIG51bGwpO1xuICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlRWxlbWVudFxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgdGFibGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGUtc2VsZWN0aW9uJyk7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICB9XG4gICRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCB0aGlzLmVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gdHJ1ZTtcbiAgfVxuICAkdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoIShzZWxlY3Rpb24udGFibGVLZXkgPT09IHRoaXMudGFibGVOb2RlS2V5KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb246IHNlbGVjdGlvbi50YWJsZUtleSAhPT0gdGhpcy50YWJsZU5vZGVLZXkgKCcke3NlbGVjdGlvbi50YWJsZUtleX0nICE9PSAnJHt0aGlzLnRhYmxlTm9kZUtleX0nKWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgdGhpcy51cGRhdGVET01TZWxlY3Rpb24oKTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCB0aGlzLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kY2xlYXJIaWdobGlnaHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVmb3ggaGFzIGEgc3RyYW5nZSBiZWhhdmlvciB3aGVyZSBwcmVzc2luZyB0aGUgZG93biBhcnJvdyBrZXkgZnJvbVxuICAgKiBhYm92ZSB0aGUgdGFibGUgd2lsbCBtb3ZlIHRoZSBjYXJldCBhZnRlciB0aGUgdGFibGUgYW5kIHRoZW4gbGV4aWNhbFxuICAgKiB3aWxsIHNlbGVjdCB0aGUgbGFzdCBjZWxsIGluc3RlYWQgb2YgdGhlIGZpcnN0LlxuICAgKiBXZSBkbyBzdGlsbCB3YW50IHRvIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgY2FyZXQgbW92ZW1lbnQgYnV0IHdlIHdpbGxcbiAgICogdXNlIHRoaXMgcHJvcGVydHkgdG8gXCJ0YWdcIiB0aGUgdXBkYXRlIHNvIHRoYXQgd2UgY2FuIHJlY2hlY2sgdGhlXG4gICAqIHNlbGVjdGlvbiBhZnRlciB0aGUgZXZlbnQgaXMgcHJvY2Vzc2VkLlxuICAgKi9cbiAgc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0QW5kQ2xlYXJTaG91bGRDaGVja1NlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogV2hlbiBoYW5kbGluZyBtb3VzZW1vdmUgZXZlbnRzIHdlIHRyYWNrIHdoYXQgdGhlIGZvY3VzIGNlbGwgc2hvdWxkIGJlLCBidXRcbiAgICogdGhlIERPTSBzZWxlY3Rpb24gbWF5IGVuZCB1cCBzb21ld2hlcmUgZWxzZSBlbnRpcmVseS4gV2UgZG9uJ3QgaGF2ZSBhbiBlbGVnYW50XG4gICAqIHdheSB0byBoYW5kbGUgdGhpcyBhZnRlciB0aGUgRE9NIHNlbGVjdGlvbiBoYXMgYmVlbiByZXNvbHZlZCBpbiBhXG4gICAqIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCBjYWxsYmFjay5cbiAgICovXG4gIHNldE5leHRGb2N1cyhuZXh0Rm9jdXMpIHtcbiAgICB0aGlzLm5leHRGb2N1cyA9IG5leHRGb2N1cztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0QW5kQ2xlYXJOZXh0Rm9jdXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dEZvY3VzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG5leHRGb2N1cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Rm9jdXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dEZvY3VzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVET01TZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5jaG9yQ2VsbCAhPT0gbnVsbCAmJiB0aGlzLmZvY3VzQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuZWRpdG9yLl93aW5kb3cpO1xuICAgICAgLy8gV2UgYXJlIG5vdCB1c2luZyBhIG5hdGl2ZSBzZWxlY3Rpb24gZm9yIHRhYmxlcywgYW5kIGlmIHdlXG4gICAgICAvLyBzZXQgb25lIHRoZW4gdGhlIHJlY29uY2lsZXIgd2lsbCB1bmRvIGl0LlxuICAgICAgLy8gVE9ETyAtIGl0IHdvdWxkIG1ha2Ugc2Vuc2UgdG8gaGF2ZSBvbmUgc28gdGhhdCBuYXRpdmVcbiAgICAgIC8vICAgICAgICBjb3B5L3Bhc3RlIHdvcmtlZC4gUmlnaHQgbm93IHdlIGhhdmUgdG8gZW11bGF0ZSB3aXRoXG4gICAgICAvLyAgICAgICAga2V5Ym9hcmQgZXZlbnRzIGJ1dCBpdCB3b24ndCBmaXJlIGlmIHRyaWdnZXJlZCBmcm9tIHRoZSBtZW51XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgaWdub3JlU3RhcnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlTm9kZVxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICBjb25zdCBjZWxsWCA9IGNlbGwueDtcbiAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG4gICAgaWYgKCF0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgJiYgKHRoaXMuYW5jaG9yWCAhPT0gY2VsbFggfHwgdGhpcy5hbmNob3JZICE9PSBjZWxsWSB8fCBpZ25vcmVTdGFydCkpIHtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLiRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB9IGVsc2UgaWYgKGNlbGxYID09PSB0aGlzLmZvY3VzWCAmJiBjZWxsWSA9PT0gdGhpcy5mb2N1c1kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5mb2N1c1ggPSBjZWxsWDtcbiAgICB0aGlzLmZvY3VzWSA9IGNlbGxZO1xuICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgIGNvbnN0IGZvY3VzVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICAgIGlmICh0aGlzLnRhYmxlU2VsZWN0aW9uICE9IG51bGwgJiYgdGhpcy5hbmNob3JDZWxsTm9kZUtleSAhPSBudWxsICYmIGZvY3VzVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBmb2N1c1RhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgdGhpcy4kZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpLCBmb2N1c1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgICAkc2V0U2VsZWN0aW9uKHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRnZXRBbmNob3JUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPyAkZ2V0Tm9kZUJ5S2V5KHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkpIDogbnVsbDtcbiAgfVxuICAkZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBhbmNob3JUYWJsZUNlbGwgPSB0aGlzLiRnZXRBbmNob3JUYWJsZUNlbGwoKTtcbiAgICBpZiAoIShhbmNob3JUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgYW5jaG9yVGFibGVDZWxsIGlzIG51bGxgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2hvclRhYmxlQ2VsbDtcbiAgfVxuICAkZ2V0Rm9jdXNUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA/ICRnZXROb2RlQnlLZXkodGhpcy5mb2N1c0NlbGxOb2RlS2V5KSA6IG51bGw7XG4gIH1cbiAgJGdldEZvY3VzVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBmb2N1c1RhYmxlQ2VsbCA9IHRoaXMuJGdldEZvY3VzVGFibGVDZWxsKCk7XG4gICAgaWYgKCEoZm9jdXNUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgZm9jdXNUYWJsZUNlbGwgaXMgbnVsbGApO1xuICAgIH1cbiAgICByZXR1cm4gZm9jdXNUYWJsZUNlbGw7XG4gIH1cbiAgJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IGNlbGw7XG4gICAgdGhpcy5hbmNob3JYID0gY2VsbC54O1xuICAgIHRoaXMuYW5jaG9yWSA9IGNlbGwueTtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZU5vZGVcbiAgICB9ID0gdGhpcy4kbG9va3VwKCk7XG4gICAgY29uc3QgYW5jaG9yVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICBpZiAoYW5jaG9yVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZUtleSA9IGFuY2hvclRhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbiAhPSBudWxsID8gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIDogJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gYW5jaG9yTm9kZUtleTtcbiAgICB9XG4gIH1cbiAgJGZvcm1hdENlbGxzKHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlIHNlbGVjdGlvbmApO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBhbmNob3IgPSBmb3JtYXRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGNlbGxOb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoIShjZWxsTm9kZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTm8gdGFibGUgY2VsbHMgcHJlc2VudGApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZXNbMF0uZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGFsaWduRm9ybWF0V2l0aCA9ICRpc1BhcmFncmFwaE5vZGUocGFyYWdyYXBoKSA/IHBhcmFncmFwaC5nZXRGb3JtYXRGbGFncyh0eXBlLCBudWxsKSA6IG51bGw7XG4gICAgY2VsbE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgYW5jaG9yLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvY3VzLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgY2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlLCBhbGlnbkZvcm1hdFdpdGgpO1xuICAgIH0pO1xuICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB0aGlzLmVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG4gICRjbGVhclRleHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb25gKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBlbnRpcmUgdGFibGUgaXMgc2VsZWN0ZWQgYnkgdmVyaWZ5aW5nIGZpcnN0IGFuZCBsYXN0IGNlbGxzXG4gICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGxhc3RSb3cgPSB0YWJsZU5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgY29uc3QgaXNFbnRpcmVUYWJsZVNlbGVjdGVkID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwICYmIGZpcnN0Um93ICE9PSBudWxsICYmIGxhc3RSb3cgIT09IG51bGwgJiYgJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSAmJiAkaXNUYWJsZVJvd05vZGUobGFzdFJvdykgJiYgc2VsZWN0ZWROb2Rlc1swXSA9PT0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpICYmIHNlbGVjdGVkTm9kZXNbc2VsZWN0ZWROb2Rlcy5sZW5ndGggLSAxXSA9PT0gbGFzdFJvdy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoaXNFbnRpcmVUYWJsZVNlbGVjdGVkKSB7XG4gICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIC8vIERlbGV0ZSBlbnRpcmUgdGFibGVcbiAgICAgIHRhYmxlTm9kZS5yZW1vdmUoKTtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFibGUgd2FzIHRoZSBvbmx5IG5vZGVcbiAgICAgIGlmICgkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIGNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgY2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIG51bGwpO1xuICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5jb25zdCBpc1BvaW50ZXJEb3duT25FdmVudCA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIChldmVudC5idXR0b25zICYgMSkgPT09IDE7XG59O1xuZnVuY3Rpb24gaXNIVE1MVGFibGVFbGVtZW50KGVsKSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsKSAmJiBlbC5ub2RlTmFtZSA9PT0gJ1RBQkxFJztcbn1cbmZ1bmN0aW9uIGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSkge1xuICBpZiAoIWRvbSkge1xuICAgIHJldHVybiBkb207XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IGlzSFRNTFRhYmxlRWxlbWVudChkb20pID8gZG9tIDogdGFibGVOb2RlLmdldERPTVNsb3QoZG9tKS5lbGVtZW50O1xuICBpZiAoIShlbGVtZW50Lm5vZGVOYW1lID09PSAnVEFCTEUnKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0VGFibGVFbGVtZW50OiBFeHBlY3RpbmcgdGFibGUgaW4gYXMgRE9NIG5vZGUgZm9yIFRhYmxlTm9kZSwgbm90ICR7ZG9tLm5vZGVOYW1lfWApO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yV2luZG93KGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl93aW5kb3c7XG59XG5mdW5jdGlvbiAkZmluZFBhcmVudFRhYmxlQ2VsbE5vZGVJblRhYmxlKHRhYmxlTm9kZSwgbm9kZSkge1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGUsIGxhc3RUYWJsZUNlbGxOb2RlID0gbnVsbDsgY3VycmVudE5vZGUgIT09IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCkpIHtcbiAgICBpZiAodGFibGVOb2RlLmlzKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGxhc3RUYWJsZUNlbGxOb2RlO1xuICAgIH0gZWxzZSBpZiAoJGlzVGFibGVDZWxsTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGxhc3RUYWJsZUNlbGxOb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgQVJST1dfS0VZX0NPTU1BTkRTX1dJVEhfRElSRUNUSU9OID0gW1tLRVlfQVJST1dfRE9XTl9DT01NQU5ELCAnZG93biddLCBbS0VZX0FSUk9XX1VQX0NPTU1BTkQsICd1cCddLCBbS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgJ2JhY2t3YXJkJ10sIFtLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgJ2ZvcndhcmQnXV07XG5jb25zdCBERUxFVEVfVEVYVF9DT01NQU5EUyA9IFtERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdO1xuY29uc3QgREVMRVRFX0tFWV9DT01NQU5EUyA9IFtLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORF07XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCBlbGVtZW50LCBlZGl0b3IsIGhhc1RhYkhhbmRsZXIpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgY29uc3QgZWRpdG9yV2luZG93ID0gZ2V0RWRpdG9yV2luZG93KGVkaXRvcik7XG4gIGlmICghKHJvb3RFbGVtZW50ICE9PSBudWxsICYmIGVkaXRvcldpbmRvdyAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGFwcGx5VGFibGVIYW5kbGVyczogZWRpdG9yIGhhcyBubyByb290IGVsZW1lbnQgc2V0YCk7XG4gIH1cbiAgY29uc3QgdGFibGVPYnNlcnZlciA9IG5ldyBUYWJsZU9ic2VydmVyKGVkaXRvciwgdGFibGVOb2RlLmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWxlbWVudCk7XG4gIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiBkZXRhY2hUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpKTtcbiAgY29uc3QgY3JlYXRlUG9pbnRlckhhbmRsZXJzID0gKCkgPT4ge1xuICAgIGlmICh0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKCkgPT4ge1xuICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyTW92ZSA9IG1vdmVFdmVudCA9PiB7XG4gICAgICBpZiAoIWlzUG9pbnRlckRvd25PbkV2ZW50KG1vdmVFdmVudCkgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRE9NTm9kZShtb3ZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZm9jdXNDZWxsID0gbnVsbDtcbiAgICAgIC8vIEluIGZpcmVmb3ggdGhlIG1vdmVFdmVudC50YXJnZXQgbWF5IGJlIGNhcHR1cmVkIHNvIHdlIG11c3QgYWx3YXlzXG4gICAgICAvLyBjb25zdWx0IHRoZSBjb29yZGluYXRlcyAjNzI0NVxuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSAhKElTX0ZJUkVGT1ggfHwgdGFibGVFbGVtZW50LmNvbnRhaW5zKG1vdmVFdmVudC50YXJnZXQpKTtcbiAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICBmb2N1c0NlbGwgPSBnZXRET01DZWxsSW5UYWJsZUZyb21UYXJnZXQodGFibGVFbGVtZW50LCBtb3ZlRXZlbnQudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQobW92ZUV2ZW50LmNsaWVudFgsIG1vdmVFdmVudC5jbGllbnRZKSkge1xuICAgICAgICAgIGZvY3VzQ2VsbCA9IGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZUVsZW1lbnQsIGVsKTtcbiAgICAgICAgICBpZiAoZm9jdXNDZWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c0NlbGwgJiYgKHRhYmxlT2JzZXJ2ZXIuZm9jdXNDZWxsID09PSBudWxsIHx8IGZvY3VzQ2VsbC5lbGVtICE9PSB0YWJsZU9ic2VydmVyLmZvY3VzQ2VsbC5lbGVtKSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldE5leHRGb2N1cyh7XG4gICAgICAgICAgZm9jdXNDZWxsLFxuICAgICAgICAgIG92ZXJyaWRlXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSB0cnVlO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUsIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgfTtcbiAgY29uc3Qgb25Qb2ludGVyRG93biA9IGV2ZW50ID0+IHtcbiAgICB0YWJsZU9ic2VydmVyLnBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhaXNET01Ob2RlKGV2ZW50LnRhcmdldCkgfHwgIWVkaXRvcldpbmRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdHJ1c3QgRmlyZWZveCB0byBkbyB0aGUgcmlnaHQgdGhpbmcgd2l0aCB0aGUgc2VsZWN0aW9uIGFuZFxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgcHJvcGVyIHN0YXRlIG1hY2hpbmUgdG8gZG8gdGhpcyBcImNvcnJlY3RseVwiIGJ1dFxuICAgICAgICAvLyBpZiB3ZSBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgdGFibGUgc2VsZWN0aW9uIG5vdyBpdCB3aWxsIHdvcmtcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQuc2hpZnRLZXkgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShwcmV2U2VsZWN0aW9uLCB0YWJsZU5vZGUpICYmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yTm9kZSA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbCA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBwcmV2U2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgICAgIGlmIChwcmV2QW5jaG9yQ2VsbCkge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbigkZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlT3JUaHJvdyh0YWJsZU9ic2VydmVyLCBwcmV2QW5jaG9yQ2VsbCkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhcmdldENlbGwpO1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdGFibGVOb2RlLmlzQmVmb3JlKHByZXZBbmNob3JOb2RlKSA/IHRhYmxlTm9kZS5zZWxlY3RTdGFydCgpIDogdGFibGVOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5LCBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbmx5IHNldCBhbmNob3IgY2VsbCBmb3Igc2VsZWN0aW9uIGlmIHRoaXMgaXMgbm90IGEgc2ltcGxlIHRvdWNoIHRhcFxuICAgICAgICAgIC8vIFRvdWNoIHRhcHMgc2hvdWxkIG5vdCBpbml0aWF0ZSB0YWJsZSBzZWxlY3Rpb24gbW9kZVxuICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YXJnZXRDZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQb2ludGVySGFuZGxlcnMoKTtcbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB7XG4gICAgdGFibGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93bik7XG4gIH0pO1xuICBjb25zdCBvblRyaXBsZUNsaWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5kZXRhaWwgPj0gMyAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVHJpcGxlQ2xpY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIHRhYmxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblRyaXBsZUNsaWNrKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG4gIGNvbnN0IHBvaW50ZXJEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIWlzRE9NTm9kZSh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSAmJiByb290RWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2spO1xuICB9KTtcbiAgZm9yIChjb25zdCBbY29tbWFuZCwgZGlyZWN0aW9uXSBvZiBBUlJPV19LRVlfQ09NTUFORFNfV0lUSF9ESVJFQ1RJT04pIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgICAgaWYgKGZvY3VzQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIGNvbnN0IGRlbGV0ZVRleHRIYW5kbGVyID0gY29tbWFuZCA9PiAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFyVGV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c05vZGUpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiAhaXNGb2N1c0luc2lkZSB8fCBpc0ZvY3VzSW5zaWRlICYmICFpc0FuY2hvckluc2lkZTtcbiAgICAgIGlmIChzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRjbGVhclRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pKTtcbiAgICAgIGNvbnN0IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlID0gbmVhcmVzdEVsZW1lbnROb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQobmVhcmVzdEVsZW1lbnROb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICRpc1RhYmxlQ2VsbE5vZGUobi5nZXRQYXJlbnQoKSkpO1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZSh0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSkgfHwgISRpc0VsZW1lbnROb2RlKG5lYXJlc3RFbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQgPT09IERFTEVURV9MSU5FX0NPTU1BTkQgJiYgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IERlbGV0ZSBMaW5lIGluIFRhYmxlIENlbGxzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX1RFWFRfQ09NTUFORFMpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGRlbGV0ZVRleHRIYW5kbGVyKGNvbW1hbmQpLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgY29uc3QgJGRlbGV0ZUNlbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIHRhYmxlIGJ1dCBzaG91bGQgcmVtb3ZlIHRoZSB3aG9sZSB0YWJsZVxuICAgIC8vIHdlIGV4cGFuZCB0aGUgc2VsZWN0aW9uIHNvIHRoYXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBhcmUgb3V0c2lkZVxuICAgIC8vIHRoZSB0YWJsZSBhbmQgdGhlIGVkaXRvcidzIGNvbW1hbmQgbGlzdGVuZXIgd2lsbCBoYW5kbGUgdGhlIGRlbGV0ZVxuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICBpZiAoaXNBbmNob3JJbnNpZGUgIT09IGlzRm9jdXNJbnNpZGUpIHtcbiAgICAgIGNvbnN0IHRhYmxlUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICAgIGNvbnN0IG91dGVyUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICAgIC8vIFByZXNlcnZlIHRoZSBvdXRlciBwb2ludFxuICAgICAgY29uc3Qge1xuICAgICAgICBrZXksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHNlbGVjdGlvbltvdXRlclBvaW50XTtcbiAgICAgIC8vIEV4cGFuZCB0aGUgc2VsZWN0aW9uIGFyb3VuZCB0aGUgdGFibGVcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRhYmxlTm9kZVtzZWxlY3Rpb25bdGFibGVQb2ludF0uaXNCZWZvcmUoc2VsZWN0aW9uW291dGVyUG9pbnRdKSA/ICdzZWxlY3RQcmV2aW91cycgOiAnc2VsZWN0TmV4dCddKCk7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvdXRlciBwb2ludCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICBuZXdTZWxlY3Rpb25bb3V0ZXJQb2ludF0uc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbiAgICAgIC8vIExldCB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBoYW5kbGUgdGhlIHJlc3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGFibGVPYnNlcnZlci4kY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX0tFWV9DT01NQU5EUykge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgJGRlbGV0ZUNlbGxIYW5kbGVyLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHlpbmcgdG8gdGhlIGNsaXBib2FyZCBpcyBhc3luYyBzbyB3ZSBtdXN0IGNhcHR1cmUgdGhlIGRhdGFcbiAgICAgIC8vIGJlZm9yZSB3ZSBkZWxldGUgaXRcbiAgICAgIHZvaWQgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCwgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xuICAgICAgY29uc3QgaW50ZXJjZXB0ZWQgPSAkZGVsZXRlQ2VsbEhhbmRsZXIoZXZlbnQpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJjZXB0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRmb3JtYXRDZWxscyhwYXlsb2FkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXRUeXBlID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yTm9kZSkgfHwgISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsaWduIHRoZSB0YWJsZSBpZiB0aGUgZW50aXJlIHRhYmxlIGlzIHNlbGVjdGVkXG4gICAgaWYgKCRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHRhYmxlTm9kZS5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlTWFwLCBhbmNob3JDZWxsLCBmb2N1c0NlbGxdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgY29uc3QgbWF4Um93ID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydFJvdyArIGFuY2hvckNlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxLCBmb2N1c0NlbGwuc3RhcnRSb3cgKyBmb2N1c0NlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChhbmNob3JDZWxsLnN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEsIGZvY3VzQ2VsbC5zdGFydENvbHVtbiArIGZvY3VzQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGNvbnN0IG1pblJvdyA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWluQ29sdW1uID0gTWF0aC5taW4oYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhYmxlTWFwW2ldW2pdLmNlbGw7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhjZWxsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGNlbGwpO1xuICAgICAgICBjZWxsLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgY29uc3QgY2VsbENoaWxkcmVuID0gY2VsbC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNlbGxDaGlsZHJlbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2VsbENoaWxkcmVuW2tdO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRjbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIFskY3JlYXRlVGV4dE5vZGUocGF5bG9hZCldKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgaWYgKGhhc1RhYkhhbmRsZXIpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwgfHwgIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZSh0YWJsZUNlbGxOb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICRzZWxlY3RBZGphY2VudENlbGwodGFibGVDZWxsTm9kZSwgZXZlbnQuc2hpZnRLZXkgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAoc2VsZWN0aW9uUGF5bG9hZCwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBub2RlcyxcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBzZWxlY3Rpb25QYXlsb2FkO1xuICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgPSBpc1JhbmdlU2VsZWN0aW9uICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSkgIT09IG51bGwgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsIHx8IGlzVGFibGVTZWxlY3Rpb247XG4gICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMSB8fCAhJGlzVGFibGVOb2RlKG5vZGVzWzBdKSB8fCAhaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgfHwgYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgW2FuY2hvckNlbGxOb2RlLCBhbmNob3JSb3dOb2RlLCBncmlkTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVSb3dOb2RlKGFuY2hvclJvd05vZGUpIHx8ICEkaXNUYWJsZU5vZGUoZ3JpZE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBsYXRlR3JpZCA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IFtpbml0aWFsR3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIGFuY2hvckNlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICBjb25zdCBbdGVtcGxhdGVHcmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRlbXBsYXRlR3JpZCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3QgaW5pdGlhbFJvd0NvdW50ID0gaW5pdGlhbEdyaWRNYXAubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRpYWxDb2xDb3VudCA9IGluaXRpYWxSb3dDb3VudCA+IDAgPyBpbml0aWFsR3JpZE1hcFswXS5sZW5ndGggOiAwO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJhbmdlIHNlbGVjdGlvbiwgd2UnbGwgZml0IHRoZSB0ZW1wbGF0ZSBncmlkIGludG8gdGhlXG4gICAgLy8gdGFibGUsIGdyb3dpbmcgdGhlIHRhYmxlIGlmIG5lY2Vzc2FyeS5cbiAgICBsZXQgc3RhcnRSb3cgPSBhbmNob3JDZWxsTWFwLnN0YXJ0Um93O1xuICAgIGxldCBzdGFydENvbCA9IGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW47XG4gICAgbGV0IGFmZmVjdGVkUm93Q291bnQgPSB0ZW1wbGF0ZUdyaWRNYXAubGVuZ3RoO1xuICAgIGxldCBhZmZlY3RlZENvbENvdW50ID0gYWZmZWN0ZWRSb3dDb3VudCA+IDAgPyB0ZW1wbGF0ZUdyaWRNYXBbMF0ubGVuZ3RoIDogMDtcbiAgICBpZiAoaXNUYWJsZVNlbGVjdGlvbikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRhYmxlIHNlbGVjdGlvbiwgd2UnbGwgb25seSBtb2RpZnkgdGhlIGNlbGxzIHdpdGhpblxuICAgICAgLy8gdGhlIHNlbGVjdGlvbiBib3VuZGFyeS5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbkJvdW5kYXJ5ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkoaW5pdGlhbEdyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcCk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Sb3dDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heFJvdyAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdyArIDE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heENvbHVtbiAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pbkNvbHVtbiArIDE7XG4gICAgICBzdGFydFJvdyA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdztcbiAgICAgIHN0YXJ0Q29sID0gc2VsZWN0aW9uQm91bmRhcnkubWluQ29sdW1uO1xuICAgICAgYWZmZWN0ZWRSb3dDb3VudCA9IE1hdGgubWluKGFmZmVjdGVkUm93Q291bnQsIHNlbGVjdGlvblJvd0NvdW50KTtcbiAgICAgIGFmZmVjdGVkQ29sQ291bnQgPSBNYXRoLm1pbihhZmZlY3RlZENvbENvdW50LCBzZWxlY3Rpb25Db2xDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBVbm1lcmdlIGFsbCBtZXJnZWQgY2VsbHMgd2l0aGluIHRoZSBhZmZlY3RlZCBhcmVhXG4gICAgbGV0IGRpZFBlcmZvcm1NZXJnZU9wZXJhdGlvbnMgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0Um93Rm9yVW5tZXJnZSA9IE1hdGgubWluKGluaXRpYWxSb3dDb3VudCwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgY29uc3QgbGFzdENvbEZvclVubWVyZ2UgPSBNYXRoLm1pbihpbml0aWFsQ29sQ291bnQsIHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudCkgLSAxO1xuICAgIGNvbnN0IHVubWVyZ2VkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDw9IGxhc3RSb3dGb3JVbm1lcmdlOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8PSBsYXN0Q29sRm9yVW5tZXJnZTsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbE1hcCA9IGluaXRpYWxHcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHVubWVyZ2VkS2V5cy5oYXMoY2VsbE1hcC5jZWxsLmdldEtleSgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjZWxsIHdhcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsTWFwLmNlbGwuX19yb3dTcGFuID09PSAxICYmIGNlbGxNYXAuY2VsbC5fX2NvbFNwYW4gPT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBub3QgYSBtZXJnZWQgY2VsbFxuICAgICAgICB9XG4gICAgICAgICR1bm1lcmdlQ2VsbE5vZGUoY2VsbE1hcC5jZWxsKTtcbiAgICAgICAgdW5tZXJnZWRLZXlzLmFkZChjZWxsTWFwLmNlbGwuZ2V0S2V5KCkpO1xuICAgICAgICBkaWRQZXJmb3JtTWVyZ2VPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMjogRXhwYW5kIGN1cnJlbnQgdGFibGUgKGlmIG5lZWRlZClcbiAgICBjb25zdCByb3dzVG9JbnNlcnQgPSBhZmZlY3RlZFJvd0NvdW50IC0gaW5pdGlhbFJvd0NvdW50ICsgc3RhcnRSb3c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9JbnNlcnQ7IGkrKykge1xuICAgICAgY29uc3QgY2VsbE1hcCA9IGludGVyaW1HcmlkTWFwW2luaXRpYWxSb3dDb3VudCAtIDFdWzBdO1xuICAgICAgJGluc2VydFRhYmxlUm93QXROb2RlKGNlbGxNYXAuY2VsbCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbHNUb0luc2VydCA9IGFmZmVjdGVkQ29sQ291bnQgLSBpbml0aWFsQ29sQ291bnQgKyBzdGFydENvbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHNUb0luc2VydDsgaSsrKSB7XG4gICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbMF1baW5pdGlhbENvbENvdW50IC0gMV07XG4gICAgICAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGUoY2VsbE1hcC5jZWxsLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMzogTWVyZ2UgY2VsbHMgYW5kIHNldCBjZWxsIGNvbnRlbnQsIHRvIG1hdGNoIHRlbXBsYXRlIGdyaWRcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8IHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVSb3cgPSByb3cgLSBzdGFydFJvdztcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDb2wgPSBjb2wgLSBzdGFydENvbDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDZWxsTWFwID0gdGVtcGxhdGVHcmlkTWFwW3RlbXBsYXRlUm93XVt0ZW1wbGF0ZUNvbF07XG4gICAgICAgIGlmICh0ZW1wbGF0ZUNlbGxNYXAuc3RhcnRSb3cgIT09IHRlbXBsYXRlUm93IHx8IHRlbXBsYXRlQ2VsbE1hcC5zdGFydENvbHVtbiAhPT0gdGVtcGxhdGVDb2wpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQ2VsbCA9IHRlbXBsYXRlQ2VsbE1hcC5jZWxsO1xuICAgICAgICBpZiAodGVtcGxhdGVDZWxsLl9fcm93U3BhbiAhPT0gMSB8fCB0ZW1wbGF0ZUNlbGwuX19jb2xTcGFuICE9PSAxKSB7XG4gICAgICAgICAgY29uc3QgY2VsbHNUb01lcmdlID0gW107XG4gICAgICAgICAgY29uc3QgbGFzdFJvd0Zvck1lcmdlID0gTWF0aC5taW4ocm93ICsgdGVtcGxhdGVDZWxsLl9fcm93U3Bhbiwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgICAgICAgY29uc3QgbGFzdENvbEZvck1lcmdlID0gTWF0aC5taW4oY29sICsgdGVtcGxhdGVDZWxsLl9fY29sU3Bhbiwgc3RhcnRDb2wgKyBhZmZlY3RlZENvbENvdW50KSAtIDE7XG4gICAgICAgICAgZm9yIChsZXQgciA9IHJvdzsgciA8PSBsYXN0Um93Rm9yTWVyZ2U7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbDsgYyA8PSBsYXN0Q29sRm9yTWVyZ2U7IGMrKykge1xuICAgICAgICAgICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbcl1bY107XG4gICAgICAgICAgICAgIGNlbGxzVG9NZXJnZS5wdXNoKGNlbGxNYXAuY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICRtZXJnZUNlbGxzKGNlbGxzVG9NZXJnZSk7XG4gICAgICAgICAgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IGludGVyaW1HcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGlsZHJlbiA9IGNlbGwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGVtcGxhdGVDZWxsLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICBjZWxsLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW5hbENoaWxkcmVuLmZvckVhY2gobiA9PiBuLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVGFibGVTZWxlY3Rpb24gJiYgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucykge1xuICAgICAgLy8gcmVzZXQgdGhlIHRhYmxlIHNlbGVjdGlvbiBpbiBjYXNlIHRoZSBhbmNob3Igb3IgZm9jdXMgY2VsbCB3YXNcbiAgICAgIC8vIHJlbW92ZWQgdmlhIG1lcmdlIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IFtmaW5hbEdyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZE5vZGUuZ2V0V3JpdGFibGUoKSwgbnVsbCwgbnVsbCk7XG4gICAgICBjb25zdCBuZXdBbmNob3JDZWxsTWFwID0gZmluYWxHcmlkTWFwW2FuY2hvckNlbGxNYXAuc3RhcnRSb3ddW2FuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW5dO1xuICAgICAgbmV3QW5jaG9yQ2VsbE1hcC5jZWxsLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgY29uc3QgbmV4dEZvY3VzID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhck5leHRGb2N1cygpO1xuICAgIGlmIChuZXh0Rm9jdXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9jdXNDZWxsXG4gICAgICB9ID0gbmV4dEZvY3VzO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICBpZiAoZm9jdXNDZWxsLnggPT09IHRhYmxlT2JzZXJ2ZXIuZm9jdXNYICYmIGZvY3VzQ2VsbC55ID09PSB0YWJsZU9ic2VydmVyLmZvY3VzWSkge1xuICAgICAgICAgIC8vIFRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSB0aGUgY29ycmVjdCB0YWJsZSBzZWxlY3Rpb25cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzQ2VsbCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm9jdXNDZWxsICE9PSB0YWJsZU9ic2VydmVyLmFuY2hvckNlbGwgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBoYXMgY3Jvc3NlZCBjZWxsc1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZENoZWNrU2VsZWN0aW9uID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhclNob3VsZENoZWNrU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhleSBwcmVzc2VkIHRoZSBkb3duIGFycm93IHdpdGggdGhlIHNlbGVjdGlvbiBvdXRzaWRlIG9mIHRoZVxuICAgIC8vIHRhYmxlLCBhbmQgdGhlbiB0aGUgc2VsZWN0aW9uIGVuZHMgdXAgaW4gdGhlIHRhYmxlIGJ1dCBub3QgaW4gdGhlXG4gICAgLy8gZmlyc3QgY2VsbCwgdGhlbiBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZpcnN0IGNlbGwuXG4gICAgaWYgKHNob3VsZENoZWNrU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9ICRmaW5kQ2VsbE5vZGUoYW5jaG9yKTtcbiAgICAgIGlmIChhbmNob3JDZWxsICE9PSBudWxsICYmICRpc1RhYmxlUm93Tm9kZShmaXJzdFJvdykpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmaXJzdENlbGwpICYmIHRhYmxlTm9kZS5pcygkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsIG5vZGUgPT4gbm9kZS5pcyh0YWJsZU5vZGUpIHx8IG5vZGUuaXMoZmlyc3RDZWxsKSkpKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBtb3ZlZCB0byB0aGUgdGFibGUsIGJ1dCBub3QgaW4gdGhlIGZpcnN0IGNlbGxcbiAgICAgICAgICBmaXJzdENlbGwuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICAvLyBVc2luZyBleHBsaWNpdCBjb21wYXJpc29uIHdpdGggdGFibGUgbm9kZSB0byBlbnN1cmUgaXQncyBub3QgYSBuZXN0ZWQgdGFibGVcbiAgICAgIC8vIGFzIGluIHRoYXQgY2FzZSB3ZSdsbCBsZWF2ZSBzZWxlY3Rpb24gcmVzb2x2aW5nIHRvIHRoYXQgdGFibGVcbiAgICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9ICEhKGFuY2hvckNlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsTm9kZSkpKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSAhIShmb2N1c0NlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c0NlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNQYXJ0aWFsbHlXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICE9PSBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGlmIChpc1BhcnRpYWxseVdpdGhpblRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNGb2N1c0luc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgZm9jdXNDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoaXNCYWNrd2FyZCA/IGZpcnN0Q2VsbC5nZXRLZXkoKSA6IGxhc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldENoaWxkcmVuU2l6ZSgpIDogbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNob3JJbnNpZGUpIHtcbiAgICAgICAgICBjb25zdCBbdGFibGVNYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIGlzQmFja3dhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHRhYmxlIHNvIHRoYXQgd2hlbiB0aGUgY3Vyc29yIG1vdmVzIG91dHNpZGUgb2ZcbiAgICAgICAgICAgKiB0aGUgdGFibGUgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiwgdGhlIGVudGlyZSB0YWJsZSB3aWxsIGJlIHNlbGVjdGVkIGZyb20gaXRzIGVuZC5cbiAgICAgICAgICAgKiBPdGhlcndpc2UsIGlmIGZvcndhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBmb2N1cyBpcyBkcmFnZ2VkXG4gICAgICAgICAgICogb3V0c2lkZSB0aCBlbmQgb2YgdGhlIHRhYmxlLCBpdCB3aWxsIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoaXNCYWNrd2FyZCA/IGxhc3RDZWxsLmdldEtleSgpIDogZmlyc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc1dpdGhpblRhYmxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gc2VsZWN0aW9uIHNwYW5zIGFjcm9zcyBtdWx0aXBsZSBjZWxscyBidXQgc3RpbGxcbiAgICAgICAgLy8gaGFzIHJhbmdlIHNlbGVjdGlvbiwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gdGFibGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICghYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGFuY2hvckNlbGxOb2RlKSk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGhlIHBvaW50ZXIgdHlwZSBpcyB0b3VjaCBhbmQgdGhlIGN1cnJlbnQgYW5kXG4gICAgICAgIC8vIHByZXZpb3VzIHNlbGVjdGlvbiBhcmUgY29sbGFwc2VkLCBhbmQgdGhlIHByZXZpb3VzIGFuY2hvciBhbmQgY3VycmVudFxuICAgICAgICAvLyBmb2N1cyBjZWxsIG5vZGVzIGFyZSBkaWZmZXJlbnQsIHRoZW4gd2UgY29udmVydCBpdCBpbnRvIHRhYmxlIHNlbGVjdGlvblxuICAgICAgICAvLyBIb3dldmVyLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHRhYmxlIG9ic2VydmVyIGlzIGFjdGl2ZWx5IHNlbGVjdGluZyAodXNlciBkcmFnZ2luZylcbiAgICAgICAgLy8gdG8gcHJldmVudCB1bndhbnRlZCBzZWxlY3Rpb25zIHdoZW4gc2ltcGx5IHRhcHBpbmcgYmV0d2VlbiBjZWxscyBvbiBtb2JpbGVcbiAgICAgICAgaWYgKHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICAgICAgaWYgKHByZXZBbmNob3JDZWxsTm9kZSAmJiAhcHJldkFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHByZXZBbmNob3JDZWxsTm9kZSkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uICYmICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVOb2RlLmdldEtleSgpKSB7XG4gICAgICAvLyBpZiBzZWxlY3Rpb24gZ29lcyBvdXRzaWRlIG9mIHRoZSB0YWJsZSB3ZSBuZWVkIHRvIGNoYW5nZSBpdCB0byBSYW5nZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3JXaW5kb3cpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAmJiBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpO1xuICAgICAgICBjb25zdCBpc0ZvY3VzT3V0c2lkZSA9IGZvY3VzTm9kZSAmJiAhdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSBhbmNob3JOb2RlICYmIHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoaXNGb2N1c091dHNpZGUgJiYgaXNBbmNob3JJbnNpZGUgJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldEtleSgpLCBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uICYmICF0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJGlzVGFibGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhYmxlT2JzZXJ2ZXIuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKCF0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICBpZiAoZWRnZVBvc2l0aW9uKSB7XG4gICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICByZXR1cm4gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGRldGFjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gdGFibGVPYnNlcnZlcikge1xuICAgIGRlbGV0ZSB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV07XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgaWYgKCEoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHRhYmxlRWxlbWVudCBhbHJlYWR5IGhhcyBhbiBhdHRhY2hlZCBUYWJsZU9ic2VydmVyYCk7XG4gIH1cbiAgdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldID0gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldIHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRET01DZWxsRnJvbVRhcmdldChub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdURCcgfHwgbm9kZU5hbWUgPT09ICdUSCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBjZWxsID0gY3VycmVudE5vZGUuX2NlbGw7XG4gICAgICBpZiAoY2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZSwgbm9kZSkge1xuICBpZiAoIXRhYmxlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGNlbGwgPSBudWxsO1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7IGN1cnJlbnROb2RlICE9IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGFibGUpIHtcbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbCB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlKHRhYmxlTm9kZSwgZG9tKSB7XG4gIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gIGNvbnN0IGRvbVJvd3MgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjb2x1bW5zOiAwLFxuICAgIGRvbVJvd3MsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndHInKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGRvbVJvd3MubGVuZ3RoID0gMDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGN1cnJlbnROb2RlLl9jZWxsID0gY2VsbDtcbiAgICAgIGxldCByb3cgPSBkb21Sb3dzW3ldO1xuICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdyA9IGRvbVJvd3NbeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvd1t4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHkrKztcbiAgICAgIHggPSAwO1xuICAgICAgY3VycmVudE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRhYmxlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZSwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoVGFibGVDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBkb21Sb3dzXG4gIH0gPSBncmlkO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRvbVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmICghcm93KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZVNlbGVjdGlvbi50YWJsZSwgY2VsbCA9PiB7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgdGFibGVPYnNlcnZlci4kZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgJGZvckVhY2hUYWJsZUNlbGwodGFibGVPYnNlcnZlci50YWJsZSwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJHNlbGVjdEFkamFjZW50Q2VsbCh0YWJsZUNlbGxOb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2libGluZ01ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldE5leHRTaWJsaW5nJyA6ICdnZXRQcmV2aW91c1NpYmxpbmcnO1xuICBjb25zdCBjaGlsZE1ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldEZpcnN0Q2hpbGQnIDogJ2dldExhc3RDaGlsZCc7XG4gIGNvbnN0IHNpYmxpbmcgPSB0YWJsZUNlbGxOb2RlW3NpYmxpbmdNZXRob2RdKCk7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgIHJldHVybiBzaWJsaW5nLnNlbGVjdEVuZCgpO1xuICB9XG4gIGNvbnN0IHBhcmVudFJvdyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQodGFibGVDZWxsTm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgaWYgKCEocGFyZW50Um93ICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBDZWxsIG5vdCBpbiB0YWJsZSByb3dgKTtcbiAgfVxuICBmb3IgKGxldCBuZXh0Um93ID0gcGFyZW50Um93W3NpYmxpbmdNZXRob2RdKCk7ICRpc1RhYmxlUm93Tm9kZShuZXh0Um93KTsgbmV4dFJvdyA9IG5leHRSb3dbc2libGluZ01ldGhvZF0oKSkge1xuICAgIGNvbnN0IGNoaWxkID0gbmV4dFJvd1tjaGlsZE1ldGhvZF0oKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gY2hpbGQuc2VsZWN0RW5kKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFRhYmxlID0gJGZpbmRNYXRjaGluZ1BhcmVudChwYXJlbnRSb3csICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKHBhcmVudFRhYmxlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBSb3cgbm90IGluIHRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ25leHQnID8gcGFyZW50VGFibGUuc2VsZWN0TmV4dCgpIDogcGFyZW50VGFibGUuc2VsZWN0UHJldmlvdXMoKTtcbn1cbmNvbnN0IHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVPYnNlcnZlci50YWJsZSksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0Q29ybmVyKHJlY3QsIGNlbGxWYWx1ZSkge1xuICBsZXQgY29sTmFtZTtcbiAgbGV0IHJvd05hbWU7XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRDb2x1bW4gPT09IHJlY3QubWluQ29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtaW5Db2x1bW4nO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydENvbHVtbiArIGNlbGxWYWx1ZS5jZWxsLl9fY29sU3BhbiAtIDEgPT09IHJlY3QubWF4Q29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtYXhDb2x1bW4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRSb3cgPT09IHJlY3QubWluUm93KSB7XG4gICAgcm93TmFtZSA9ICdtaW5Sb3cnO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydFJvdyArIGNlbGxWYWx1ZS5jZWxsLl9fcm93U3BhbiAtIDEgPT09IHJlY3QubWF4Um93KSB7XG4gICAgcm93TmFtZSA9ICdtYXhSb3cnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbY29sTmFtZSwgcm93TmFtZV07XG59XG5mdW5jdGlvbiBnZXRDb3JuZXJPclRocm93KHJlY3QsIGNlbGxWYWx1ZSkge1xuICBjb25zdCBjb3JuZXIgPSBnZXRDb3JuZXIocmVjdCwgY2VsbFZhbHVlKTtcbiAgaWYgKCEoY29ybmVyICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q29ybmVyT3JUaHJvdzogY2VsbCAke2NlbGxWYWx1ZS5jZWxsLmdldEtleSgpfSBpcyBub3QgYXQgYSBjb3JuZXIgb2YgcmVjdGApO1xuICB9XG4gIHJldHVybiBjb3JuZXI7XG59XG5mdW5jdGlvbiBvcHBvc2l0ZUNvcm5lcihbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgcmV0dXJuIFtjb2xOYW1lID09PSAnbWluQ29sdW1uJyA/ICdtYXhDb2x1bW4nIDogJ21pbkNvbHVtbicsIHJvd05hbWUgPT09ICdtaW5Sb3cnID8gJ21heFJvdycgOiAnbWluUm93J107XG59XG5mdW5jdGlvbiBjZWxsQXRDb3JuZXJPclRocm93KHRhYmxlTWFwLCByZWN0LCBbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgY29uc3Qgcm93TnVtID0gcmVjdFtyb3dOYW1lXTtcbiAgY29uc3Qgcm93TWFwID0gdGFibGVNYXBbcm93TnVtXTtcbiAgaWYgKCEocm93TWFwICE9PSB1bmRlZmluZWQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBjZWxsQXRDb3JuZXJPclRocm93OiAke3Jvd05hbWV9ID0gJHtTdHJpbmcocm93TnVtKX0gbWlzc2luZyBpbiB0YWJsZU1hcGApO1xuICB9XG4gIGNvbnN0IGNvbE51bSA9IHJlY3RbY29sTmFtZV07XG4gIGNvbnN0IGNlbGwgPSByb3dNYXBbY29sTnVtXTtcbiAgaWYgKCEoY2VsbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgY2VsbEF0Q29ybmVyT3JUaHJvdzogJHtjb2xOYW1lfSA9ICR7U3RyaW5nKGNvbE51bSl9IG1pc3NpbmcgaW4gdGFibGVNYXBgKTtcbiAgfVxuICByZXR1cm4gY2VsbDtcbn1cbmZ1bmN0aW9uICRleHRyYWN0UmVjdENvcm5lcnModGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgbmV3Rm9jdXNDZWxsVmFsdWUpIHtcbiAgLy8gV2UgYXJlIHN1cmUgdGhhdCB0aGUgZm9jdXMgbm93IGVpdGhlciBjb250cmFjdHMgb3IgZXhwYW5kcyB0aGUgcmVjdFxuICAvLyBidXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBtaWdodCBiZSBtb3ZlZCB0byBlbnN1cmUgYSByZWN0YW5nbGVcbiAgLy8gZ2l2ZW4gYSBwb3RlbnRpYWxseSByYWdnZWQgbWVyZ2Ugc2hhcGVcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyKHJlY3QsIGFuY2hvckNlbGxWYWx1ZSk7XG4gIGlmIChhbmNob3JDb3JuZXIpIHtcbiAgICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIGFuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcikpXTtcbiAgfVxuICBjb25zdCBuZXdGb2N1c0Nvcm5lciA9IGdldENvcm5lcihyZWN0LCBuZXdGb2N1c0NlbGxWYWx1ZSk7XG4gIGlmIChuZXdGb2N1c0Nvcm5lcikge1xuICAgIHJldHVybiBbY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgb3Bwb3NpdGVDb3JuZXIobmV3Rm9jdXNDb3JuZXIpKSwgY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgbmV3Rm9jdXNDb3JuZXIpXTtcbiAgfVxuICAvLyBUT0RPIHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGFyYml0cmFyeSwgdXNlIHRoZSBjbG9zZXN0IGNvcm5lciBpbnN0ZWFkXG4gIGNvbnN0IG5ld0FuY2hvckNvcm5lciA9IFsnbWluQ29sdW1uJywgJ21pblJvdyddO1xuICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG5ld0FuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKG5ld0FuY2hvckNvcm5lcikpXTtcbn1cbmZ1bmN0aW9uICRhZGp1c3RGb2N1c0luRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3Qgc3BhbnMgPSAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RTcGFucyh0YWJsZU1hcCwgcmVjdCk7XG4gIGNvbnN0IHtcbiAgICB0b3BTcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIGJvdHRvbVNwYW4sXG4gICAgcmlnaHRTcGFuXG4gIH0gPSBzcGFucztcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyT3JUaHJvdyhyZWN0LCBhbmNob3JDZWxsVmFsdWUpO1xuICBjb25zdCBbZm9jdXNDb2x1bW4sIGZvY3VzUm93XSA9IG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcik7XG4gIGxldCBmQ29sID0gcmVjdFtmb2N1c0NvbHVtbl07XG4gIGxldCBmUm93ID0gcmVjdFtmb2N1c1Jvd107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgIGZDb2wgKz0gZm9jdXNDb2x1bW4gPT09ICdtYXhDb2x1bW4nID8gMSA6IGxlZnRTcGFuO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgIGZDb2wgLT0gZm9jdXNDb2x1bW4gPT09ICdtaW5Db2x1bW4nID8gMSA6IHJpZ2h0U3BhbjtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIGZSb3cgKz0gZm9jdXNSb3cgPT09ICdtYXhSb3cnID8gMSA6IHRvcFNwYW47XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgZlJvdyAtPSBmb2N1c1JvdyA9PT0gJ21pblJvdycgPyAxIDogYm90dG9tU3BhbjtcbiAgfVxuICBjb25zdCB0YXJnZXRSb3dNYXAgPSB0YWJsZU1hcFtmUm93XTtcbiAgaWYgKHRhcmdldFJvd01hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5ld0ZvY3VzQ2VsbFZhbHVlID0gdGFyZ2V0Um93TWFwW2ZDb2xdO1xuICBpZiAobmV3Rm9jdXNDZWxsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBXZSBjYW4gYmUgY2VydGFpbiB0aGF0IGFuY2hvckNlbGxWYWx1ZSBhbmQgbmV3Rm9jdXNDZWxsVmFsdWUgYXJlXG4gIC8vIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGRlc2lyZWQgc2VsZWN0aW9uLCBidXQgd2UgYXJlIG5vdCBjZXJ0YWluIGlmXG4gIC8vIHRoZXkgbmVlZCB0byBiZSBleHBhbmRlZCBvciBub3QgdG8gbWFpbnRhaW4gYSByZWN0YW5ndWxhciBzaGFwZVxuICBjb25zdCBbZmluYWxBbmNob3JDZWxsLCBmaW5hbEZvY3VzQ2VsbF0gPSAkZXh0cmFjdFJlY3RDb3JuZXJzKHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yRE9NID0gJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZmluYWxBbmNob3JDZWxsLmNlbGwpO1xuICBjb25zdCBmb2N1c0RPTSA9ICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZpbmFsRm9jdXNDZWxsLmNlbGwpO1xuICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTSk7XG4gIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTSwgdHJ1ZSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgLy8gVE9ETyB0aGlzIHNob3VsZCBwcm9iYWJseSByZXR1cm4gZmFsc2UgaWYgdGhlcmUncyBhbiB1bnJlbGF0ZWRcbiAgICAvLyAgICAgIHNoYWRvdyByb290IGJldHdlZW4gdGhlIG5vZGUgYW5kIHRoZSB0YWJsZSAoZS5nLiBhbm90aGVyIHRhYmxlLFxuICAgIC8vICAgICAgY29sbGFwc2libGUsIGV0Yy4pXG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIHJldHVybiBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICh0YWJsZU5vZGUgJiYgYW5jaG9yTm9kZSAmJiBmb2N1c05vZGUpIHtcbiAgICAgIGNvbnN0IFttYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgICByZXR1cm4gYW5jaG9yTm9kZS5nZXRLZXkoKSA9PT0gbWFwWzBdWzBdLmNlbGwuZ2V0S2V5KCkgJiYgZm9jdXNOb2RlLmdldEtleSgpID09PSBtYXBbbWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsLmdldEtleSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCwgZnJvbVN0YXJ0KSB7XG4gIGlmIChmcm9tU3RhcnQpIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJGZpbmRDZWxsTm9kZShub2RlKSB7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuICRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpID8gY2VsbE5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGZpbmRUYWJsZU5vZGUobm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZU5vZGUodGFibGVOb2RlKSA/IHRhYmxlTm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShub2RlKSB7XG4gIGZvciAobGV0IHByZXZOb2RlID0gbm9kZSwgY3VycmVudE5vZGUgPSBub2RlOyBjdXJyZW50Tm9kZSAhPT0gbnVsbDsgcHJldk5vZGUgPSBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Tm9kZSAhPT0gcHJldk5vZGUgJiYgY3VycmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBwcmV2Tm9kZSkge1xuICAgICAgICAvLyBOb3QgdGhlIGZpcnN0IGNoaWxkIG9yIHRoZSBpbml0aWFsIG5vZGVcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyZW50Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkaGFuZGxlSG9yaXpvbnRhbEFycm93S2V5UmFuZ2VTZWxlY3Rpb24oZWRpdG9yLCBldmVudCwgc2VsZWN0aW9uLCBhbHRlciwgaXNCYWNrd2FyZCwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGNvbnN0IGluaXRpYWxGb2N1cyA9ICRjYXJldEZyb21Qb2ludChzZWxlY3Rpb24uZm9jdXMsIGlzQmFja3dhcmQgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgaWYgKCRpc0V4dGVuZGFibGVUZXh0UG9pbnRDYXJldChpbml0aWFsRm9jdXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsYXN0Q2FyZXQgPSBpbml0aWFsRm9jdXM7XG4gIC8vIFRhYmxlQ2VsbE5vZGUgaXMgdGhlIG9ubHkgc2hhZG93IHJvb3Qgd2UgYXJlIGludGVyZXN0ZWQgaW4gcGllcmNpbmcgc29cbiAgLy8gd2UgZmluZCB0aGUgbGFzdCBpbnRlcm5hbCBjYXJldCBhbmQgdGhlbiBjaGVjayBpdHMgcGFyZW50XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbEZvY3VzKS5pdGVyTm9kZUNhcmV0cygnc2hhZG93Um9vdCcpKSB7XG4gICAgaWYgKCEoJGlzU2libGluZ0NhcmV0KG5leHRDYXJldCkgJiYgJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RDYXJldCA9IG5leHRDYXJldDtcbiAgfVxuICBjb25zdCBsYXN0Q2FyZXRQYXJlbnQgPSBsYXN0Q2FyZXQuZ2V0UGFyZW50QXRDYXJldCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobGFzdENhcmV0UGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsID0gbGFzdENhcmV0UGFyZW50O1xuICBjb25zdCBmb2N1c0NhcmV0ID0gJGZpbmROZXh0VGFibGVDZWxsKCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbCwgbGFzdENhcmV0LmRpcmVjdGlvbikpO1xuICBjb25zdCBhbmNob3JDZWxsVGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKGFuY2hvckNlbGxUYWJsZSAmJiBhbmNob3JDZWxsVGFibGUuaXModGFibGVOb2RlKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbC5nZXRLZXkoKSk7XG4gIGNvbnN0IGFuY2hvckRPTUNlbGwgPSBnZXRET01DZWxsRnJvbVRhcmdldChhbmNob3JDZWxsRE9NKTtcbiAgaWYgKCFhbmNob3JDZWxsRE9NIHx8ICFhbmNob3JET01DZWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgPSAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZShlZGl0b3IsIGFuY2hvckNlbGxUYWJsZSk7XG4gIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBhbmNob3JDZWxsVGFibGVFbGVtZW50O1xuICBpZiAoIWZvY3VzQ2FyZXQpIHtcbiAgICBpZiAoYWx0ZXIgPT09ICdleHRlbmQnKSB7XG4gICAgICAvLyBleHRlbmQgdGhlIHNlbGVjdGlvbiBmcm9tIGEgcmFuZ2UgaW5zaWRlIHRoZSBjZWxsIHRvIGEgdGFibGUgc2VsZWN0aW9uIG9mIHRoZSBjZWxsXG4gICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGl0IHRoZSB0YWJsZVxuICAgICAgY29uc3Qgb3V0ZXJGb2N1c0NhcmV0ID0gJGdldFRhYmxlRXhpdENhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbFRhYmxlLCBpbml0aWFsRm9jdXMuZGlyZWN0aW9uKSk7XG4gICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgb3V0ZXJGb2N1c0NhcmV0KTtcbiAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uZm9jdXMsIG91dGVyRm9jdXNDYXJldCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFsdGVyID09PSAnZXh0ZW5kJykge1xuICAgIGNvbnN0IGZvY3VzRE9NQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNDYXJldC5vcmlnaW4uZ2V0S2V5KCkpKTtcbiAgICBpZiAoIWZvY3VzRE9NQ2VsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTUNlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsdGVyID09PSAnbW92ZSdcbiAgICBjb25zdCBpbm5lckZvY3VzQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQoZm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsIGlubmVyRm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgaW5uZXJGb2N1c0NhcmV0KTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUV4aXRDYXJldChpbml0aWFsQ2FyZXQpIHtcbiAgY29uc3QgYWRqYWNlbnQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGluaXRpYWxDYXJldCk7XG4gIHJldHVybiAkaXNDaGlsZENhcmV0KGFkamFjZW50KSA/ICRub3JtYWxpemVDYXJldChhZGphY2VudCkgOiBpbml0aWFsQ2FyZXQ7XG59XG5mdW5jdGlvbiAkZmluZE5leHRUYWJsZUNlbGwoaW5pdGlhbENhcmV0KSB7XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbENhcmV0KS5pdGVyTm9kZUNhcmV0cygncm9vdCcpKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luXG4gICAgfSA9IG5leHRDYXJldDtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShvcmlnaW4pKSB7XG4gICAgICAvLyBub3Qgc3VyZSB3aHkgdHMgaXNuJ3QgbmFycm93aW5nIGhlcmUgKGV2ZW4gaWYgdGhlIGd1YXJkIGlzIG9uIG5leHRDYXJldC5vcmlnaW4pXG4gICAgICAvLyBidXQgcmV0dXJuaW5nIGEgbmV3IGNhcmV0IGlzIGZpbmVcbiAgICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuICRnZXRDaGlsZENhcmV0KG9yaWdpbiwgaW5pdGlhbENhcmV0LmRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghJGlzVGFibGVSb3dOb2RlKG9yaWdpbikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykgJiYgaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZU5vZGUoc2libGluZ05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoc2libGluZ05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpLCBzaWJsaW5nTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpLCAnZWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpYmxpbmdOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSkge1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBpc1RhYmxlVW5zZWxlY3QgPSAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyAmJiAhc2VsZWN0aW9uLmlzQmFja3dhcmQoKSB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyAmJiBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpKTtcbiAgICAgICAgaWYgKGlzVGFibGVVbnNlbGVjdCkge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzUGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNQYXJlbnROb2RlLCAkaXNUYWJsZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9jdXNQYXJlbnROb2RlICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSBzaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3Rm9jdXNOb2RlID0gc2libGluZztcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGwgPSBzaWJsaW5nLmdldExhc3RDaGlsZCgpO1xuICAgICAgICAgICAgICBuZXdGb2N1c05vZGUgPSBsYXN0Q2VsbCA/IGxhc3RDZWxsIDogc2libGluZztcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/IG5ld0ZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQobmV3Rm9jdXNOb2RlLmdldEtleSgpLCBuZXdPZmZzZXQsICRpc1RleHROb2RlKG5ld0ZvY3VzTm9kZSkgPyAndGV4dCcgOiAnZWxlbWVudCcpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IHNlbGVjdGlvbi5nZXROb2RlcygpW3NlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCAtIDFdIDogc2VsZWN0aW9uLmdldE5vZGVzKClbMF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gdGFibGVOb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0RGVzY2VuZGFudCB8fCAhbGFzdERlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGZpcnN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsQ29vcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGZpcnN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbENvb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShsYXN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coZmlyc3RDZWxsQ29vcmRzLngsIGZpcnN0Q2VsbENvb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3cobGFzdENlbGxDb29yZHMueCwgbGFzdENlbGxDb29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oZmlyc3RDZWxsRE9NKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGxhc3RDZWxsRE9NLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c05vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNQYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c1BhcmVudE5vZGUsICRpc1RhYmxlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm9jdXNQYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBkaXJlY3Rpb24gPT09ICdkb3duJyA/IGZvY3VzUGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpIDogZm9jdXNQYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZU5vZGUoc2libGluZykgJiYgdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkgPT09IHNpYmxpbmcuZ2V0S2V5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3REZXNjZW5kYW50IHx8ICFsYXN0RGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoZmlyc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldCgoZGlyZWN0aW9uID09PSAndXAnID8gZmlyc3RDZWxsTm9kZSA6IGxhc3RDZWxsTm9kZSkuZ2V0S2V5KCksIGRpcmVjdGlvbiA9PT0gJ3VwJyA/IDAgOiBsYXN0Q2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJyAmJiAkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIC8vIEVuYWJsZSBGaXJlZm94IHdvcmthcm91bmRcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgY29uc3QgYWx0ZXIgPSBldmVudC5zaGlmdEtleSA/ICdleHRlbmQnIDogJ21vdmUnO1xuICAgICAgcmV0dXJuICRoYW5kbGVIb3Jpem9udGFsQXJyb3dLZXlSYW5nZVNlbGVjdGlvbihlZGl0b3IsIGV2ZW50LCBzZWxlY3Rpb24sIGFsdGVyLCBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcik7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZSA9ICRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKTtcbiAgICAgIGlmIChhbmNob3JDZWxsVGFibGUgIT09IHRhYmxlTm9kZSAmJiBhbmNob3JDZWxsVGFibGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhbmNob3JDZWxsVGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KGFuY2hvckNlbGxUYWJsZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsVGFibGUuZ2V0S2V5KCkpKTtcbiAgICAgICAgaWYgKGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBnZXRUYWJsZShhbmNob3JDZWxsVGFibGUsIGFuY2hvckNlbGxUYWJsZUVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgZGlyZWN0aW9uLCBhbmNob3JDZWxsVGFibGUsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JDZWxsRG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsTm9kZS5fX2tleSk7XG4gICAgICBjb25zdCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5rZXkpO1xuICAgICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgZWRnZVNlbGVjdGlvblJlY3Q7XG4gICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IGFuY2hvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gICAgICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgZWRnZVNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZCA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGFuY2hvckNlbGxOb2RlLmdldEZpcnN0Q2hpbGQoKSA6IGFuY2hvckNlbGxOb2RlLmdldExhc3RDaGlsZCgpO1xuICAgICAgaWYgKGVkZ2VDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWRnZUNoaWxkLl9fa2V5KTtcbiAgICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGlzRXhpdGluZyA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGVkZ2VSZWN0LnRvcCA+IGVkZ2VTZWxlY3Rpb25SZWN0LnRvcCAtIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA6IGVkZ2VTZWxlY3Rpb25SZWN0LmJvdHRvbSArIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA+IGVkZ2VSZWN0LmJvdHRvbTtcbiAgICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxlY3RUYWJsZU5vZGVJbkRpcmVjdGlvbih0YWJsZU9ic2VydmVyLCB0YWJsZU5vZGUsIGNvcmRzLngsIGNvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgW3RhYmxlTm9kZUZyb21TZWxlY3Rpb25dID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGhhbmRsZUFycm93S2V5OiBUYWJsZVNlbGVjdGlvbi5nZXROb2RlcygpWzBdIGV4cGVjdGVkIHRvIGJlIFRhYmxlTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uLmdldEtleSgpKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVOb2RlKHRhYmxlTm9kZUZyb21TZWxlY3Rpb24pIHx8IHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBncmlkID0gZ2V0VGFibGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgdGFibGVFbGVtZW50KTtcbiAgICBjb25zdCBjb3Jkc0FuY2hvciA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgZ3JpZCk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkc0FuY2hvci54LCBjb3Jkc0FuY2hvci55LCBncmlkKTtcbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckNlbGwpO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBjb25zdCBbdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICByZXR1cm4gJGFkanVzdEZvY3VzSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikge1xuICAvLyBUaGVyZSBpcyBubyBpbmJ1aWx0IHdheSB0byBjaGVjayBpZiB0aGUgY29tcG9uZW50IHBpY2tlciBpcyBpbiB2aWV3XG4gIC8vIGJ1dCB3ZSBjYW4gY2hlY2sgaWYgdGhlIHJvb3QgRE9NIGVsZW1lbnQgaGFzIHRoZSBhcmlhLWNvbnRyb2xzIGF0dHJpYnV0ZSBcInR5cGVhaGVhZC1tZW51XCIuXG4gIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKCFyb290KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByb290Lmhhc0F0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpICYmIHJvb3QuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykgPT09ICd0eXBlYWhlYWQtbWVudSc7XG59XG5mdW5jdGlvbiAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWRnZVBvc2l0aW9uID09PSAnZmlyc3QnKSB7XG4gICAgdGFibGVOb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGhOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gIH1cbiAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoLi4uKGNoaWxkcmVuIHx8IFtdKSk7XG4gIHBhcmFncmFwaE5vZGUuc2VsZWN0RW5kKCk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGVQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghdGFibGVOb2RlUGFyZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBuZXN0ZWQgdGFibGVzXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlUGFyZW50LmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpKTtcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgc2NlbmFyaW8gd2hlcmUgdGhlXG4gIC8vIG5hdGl2ZSBzZWxlY3Rpb24gYW5jaG9yIGlzOlxuICAvLyAtIGF0IG9yIGluc2lkZSB0aGUgdGFibGUncyBwYXJlbnQgRE9NXG4gIC8vIC0gYW5kIE5PVCBhdCBvciBpbnNpZGUgdGhlIHRhYmxlIERPTVxuICAvLyBJdCBtYXkgYmUgYWRqYWNlbnQgdG8gdGhlIHRhYmxlIERPTSAoZS5nLiBpbiBhIHdyYXBwZXIpXG4gIGlmICghZG9tQW5jaG9yTm9kZSB8fCAhdGFibGVOb2RlUGFyZW50RE9NIHx8ICF0YWJsZUVsZW1lbnQgfHwgIXRhYmxlTm9kZVBhcmVudERPTS5jb250YWlucyhkb21BbmNob3JOb2RlKSB8fCB0YWJsZUVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCFhbmNob3JDZWxsTm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcGFyZW50VGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGxOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHBhcmVudFRhYmxlKSB8fCAhcGFyZW50VGFibGUuaXModGFibGVOb2RlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gIGNvbnN0IGZpcnN0Q2VsbCA9IHRhYmxlTWFwWzBdWzBdO1xuICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdW3RhYmxlTWFwWzBdLmxlbmd0aCAtIDFdO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxWYWx1ZTtcbiAgY29uc3QgaXNBdEZpcnN0Q2VsbCA9IHN0YXJ0Um93ID09PSBmaXJzdENlbGwuc3RhcnRSb3cgJiYgc3RhcnRDb2x1bW4gPT09IGZpcnN0Q2VsbC5zdGFydENvbHVtbjtcbiAgY29uc3QgaXNBdExhc3RDZWxsID0gc3RhcnRSb3cgPT09IGxhc3RDZWxsLnN0YXJ0Um93ICYmIHN0YXJ0Q29sdW1uID09PSBsYXN0Q2VsbC5zdGFydENvbHVtbjtcbiAgaWYgKGlzQXRGaXJzdENlbGwpIHtcbiAgICByZXR1cm4gJ2ZpcnN0JztcbiAgfSBlbHNlIGlmIChpc0F0TGFzdENlbGwpIHtcbiAgICByZXR1cm4gJ2xhc3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHRhYmxlTm9kZVxuICB9ID0gdGFibGVPYnNlcnZlci4kbG9va3VwKCk7XG4gIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGFibGVOb2RlLCBzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpKTtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRGl2RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50JDEoZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0RJVic7XG59XG5mdW5jdGlvbiB1cGRhdGVDb2xncm91cChkb20sIGNvbmZpZywgY29sQ291bnQsIGNvbFdpZHRocykge1xuICBjb25zdCBjb2xHcm91cCA9IGRvbS5xdWVyeVNlbGVjdG9yKCdjb2xncm91cCcpO1xuICBpZiAoIWNvbEdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XG4gICAgY29uc3Qgd2lkdGggPSBjb2xXaWR0aHMgJiYgY29sV2lkdGhzW2ldO1xuICAgIGlmICh3aWR0aCkge1xuICAgICAgY29sLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgIH1cbiAgICBjb2xzLnB1c2goY29sKTtcbiAgfVxuICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG59XG5mdW5jdGlvbiBzZXRSb3dTdHJpcGluZyhkb20sIGNvbmZpZywgcm93U3RyaXBpbmcpIHtcbiAgaWYgKHJvd1N0cmlwaW5nKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIGNvbmZpZy50aGVtZS50YWJsZVJvd1N0cmlwaW5nKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVSb3dTdHJpcGluZyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Db2x1bW5zKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plbkNvbHVtbkNvdW50KSB7XG4gIGlmIChmcm96ZW5Db2x1bW5Db3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Sb3dzKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plblJvd0NvdW50KSB7XG4gIGlmIChmcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycpO1xuICB9XG59XG5mdW5jdGlvbiBhbGlnblRhYmxlRWxlbWVudChkb20sIGNvbmZpZywgZm9ybWF0VHlwZSkge1xuICBpZiAoIWNvbmZpZy50aGVtZS50YWJsZUFsaWdubWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZW1vdmVDbGFzc2VzID0gW107XG4gIGNvbnN0IGFkZENsYXNzZXMgPSBbXTtcbiAgZm9yIChjb25zdCBmb3JtYXQgb2YgWydjZW50ZXInLCAncmlnaHQnXSkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBjb25maWcudGhlbWUudGFibGVBbGlnbm1lbnRbZm9ybWF0XTtcbiAgICBpZiAoIWNsYXNzZXMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAoZm9ybWF0ID09PSBmb3JtYXRUeXBlID8gYWRkQ2xhc3NlcyA6IHJlbW92ZUNsYXNzZXMpLnB1c2goY2xhc3Nlcyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4ucmVtb3ZlQ2xhc3Nlcyk7XG4gIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5hZGRDbGFzc2VzKTtcbn1cbmNvbnN0IHNjcm9sbGFibGVFZGl0b3JzID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yID0gJGdldEVkaXRvcigpKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlRWRpdG9ycy5oYXMoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIHNldFNjcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yLCBhY3RpdmUpIHtcbiAgaWYgKGFjdGl2ZSkge1xuICAgIGlmICghZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTY3JvbGxhYmxlV3JhcHBlcikge1xuICAgICAgY29uc29sZS53YXJuKCdUYWJsZU5vZGU6IGhhc0hvcml6b250YWxTY3JvbGwgaXMgYWN0aXZlIGJ1dCB0aGVtZS50YWJsZVNjcm9sbGFibGVXcmFwcGVyIGlzIG5vdCBkZWZpbmVkLicpO1xuICAgIH1cbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cbiAgZ2V0Q29sV2lkdGhzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fY29sV2lkdGhzO1xuICB9XG4gIHNldENvbFdpZHRocyhjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIC8vIE5PVEU6IE5vZGUgcHJvcGVydGllcyBzaG91bGQgYmUgaW1tdXRhYmxlLiBGcmVlemUgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uLlxuICAgIHNlbGYuX19jb2xXaWR0aHMgPSBjb2xXaWR0aHMgIT09IHVuZGVmaW5lZCAmJiB0cnVlID8gT2JqZWN0LmZyZWV6ZShjb2xXaWR0aHMpIDogY29sV2lkdGhzO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2NvbFdpZHRocyA9IHByZXZOb2RlLl9fY29sV2lkdGhzO1xuICAgIHRoaXMuX19yb3dTdHJpcGluZyA9IHByZXZOb2RlLl9fcm93U3RyaXBpbmc7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSBwcmV2Tm9kZS5fX2Zyb3plblJvd0NvdW50O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlOiBfbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRSb3dTdHJpcGluZyhzZXJpYWxpemVkTm9kZS5yb3dTdHJpcGluZyB8fCBmYWxzZSkuc2V0RnJvemVuQ29sdW1ucyhzZXJpYWxpemVkTm9kZS5mcm96ZW5Db2x1bW5Db3VudCB8fCAwKS5zZXRGcm96ZW5Sb3dzKHNlcmlhbGl6ZWROb2RlLmZyb3plblJvd0NvdW50IHx8IDApLnNldENvbFdpZHRocyhzZXJpYWxpemVkTm9kZS5jb2xXaWR0aHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3Jvd1N0cmlwaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gMDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSAwO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNvbFdpZHRoczogdGhpcy5nZXRDb2xXaWR0aHMoKSxcbiAgICAgIGZyb3plbkNvbHVtbkNvdW50OiB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgPyB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgOiB1bmRlZmluZWQsXG4gICAgICBmcm96ZW5Sb3dDb3VudDogdGhpcy5fX2Zyb3plblJvd0NvdW50ID8gdGhpcy5fX2Zyb3plblJvd0NvdW50IDogdW5kZWZpbmVkLFxuICAgICAgcm93U3RyaXBpbmc6IHRoaXMuX19yb3dTdHJpcGluZyA/IHRoaXMuX19yb3dTdHJpcGluZyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnO1xuICB9XG4gIGdldERPTVNsb3QoZWxlbWVudCkge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykgOiBlbGVtZW50O1xuICAgIGlmICghaXNIVE1MVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVOb2RlLmdldERPTVNsb3Q6IGNyZWF0ZURPTSgpIGRpZCBub3QgcmV0dXJuIGEgdGFibGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldERPTVNsb3QoZWxlbWVudCkud2l0aEVsZW1lbnQodGFibGVFbGVtZW50KS53aXRoQWZ0ZXIodGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJykpO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgaWYgKHRoaXMuX19zdHlsZSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICB0YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY29sR3JvdXApO1xuICAgIHNldERPTVVubWFuYWdlZChjb2xHcm91cCk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZSk7XG4gICAgdGhpcy51cGRhdGVUYWJsZUVsZW1lbnQobnVsbCwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIGlmICgkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCBjbGFzc2VzID0gY29uZmlnLnRoZW1lLnRhYmxlU2Nyb2xsYWJsZVdyYXBwZXI7XG4gICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHdyYXBwZXJFbGVtZW50LCBjbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSAnb3ZlcmZsb3cteDogYXV0bzsnO1xuICAgICAgfVxuICAgICAgd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGFibGVFbGVtZW50KTtcbiAgICAgIHRoaXMudXBkYXRlVGFibGVXcmFwcGVyKG51bGwsIHdyYXBwZXJFbGVtZW50LCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gd3JhcHBlckVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlVGFibGVXcmFwcGVyKHByZXZOb2RlLCB0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudCA6IDApKSB7XG4gICAgICBzZXRGcm96ZW5Db2x1bW5zKHRhYmxlV3JhcHBlciwgdGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fZnJvemVuUm93Q291bnQgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fZnJvemVuUm93Q291bnQgOiAwKSkge1xuICAgICAgc2V0RnJvemVuUm93cyh0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fZnJvemVuUm93Q291bnQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUYWJsZUVsZW1lbnQocHJldk5vZGUsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19zdHlsZSAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19zdHlsZSA6ICcnKSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcm93U3RyaXBpbmcgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fcm93U3RyaXBpbmcgOiBmYWxzZSkpIHtcbiAgICAgIHNldFJvd1N0cmlwaW5nKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fcm93U3RyaXBpbmcpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xncm91cCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRDb2x1bW5Db3VudCgpLCB0aGlzLmdldENvbFdpZHRocygpKTtcbiAgICBhbGlnblRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRGb3JtYXRUeXBlKCkpO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy5nZXRET01TbG90KGRvbSk7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gc2xvdC5lbGVtZW50O1xuICAgIGlmIChkb20gPT09IHRhYmxlRWxlbWVudCA9PT0gJGlzU2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTERpdkVsZW1lbnQoZG9tKSkge1xuICAgICAgdGhpcy51cGRhdGVUYWJsZVdyYXBwZXIocHJldk5vZGUsIGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRhYmxlRWxlbWVudChwcmV2Tm9kZSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qgc3VwZXJFeHBvcnQgPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyRXhwb3J0O1xuICAgIHJldHVybiB7XG4gICAgICBhZnRlcjogdGFibGVFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHN1cGVyRXhwb3J0LmFmdGVyKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gc3VwZXJFeHBvcnQuYWZ0ZXIodGFibGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSFRNTFRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpICYmIGlzSFRNTEVsZW1lbnQkMSh0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0hUTUxUYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFsaWduVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcsIHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcblxuICAgICAgICAvLyBTY2FuIHRoZSB0YWJsZSBtYXAgdG8gYnVpbGQgYSBtYXAgb2YgdGFibGUgY2VsbCBrZXkgdG8gdGhlIGNvbHVtbnMgaXQgbmVlZHNcbiAgICAgICAgY29uc3QgW3RhYmxlTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRoaXMsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBjZWxsVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcFJvdyBvZiB0YWJsZU1hcCkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWFwVmFsdWUgb2YgbWFwUm93KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtYXBWYWx1ZS5jZWxsLmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCFjZWxsVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGNlbGxWYWx1ZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgICAgIGNvbFNwYW46IG1hcFZhbHVlLmNlbGwuZ2V0Q29sU3BhbigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBtYXBWYWx1ZS5zdGFydENvbHVtblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FuIHRoZSBET00gdG8gZmluZCB0aGUgdGFibGUgY2VsbCBrZXlzIHRoYXQgd2VyZSB1c2VkIGFuZCBtYXJrIHRob3NlIGNvbHVtbnNcbiAgICAgICAgY29uc3Qga25vd25Db2x1bW5zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGxET00gb2YgdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IHRyID4gW2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXldJykpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsRE9NLmdldEF0dHJpYnV0ZSgnZGF0YS10ZW1wb3JhcnktdGFibGUtY2VsbC1sZXhpY2FsLWtleScpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTcGFuID0gY2VsbFZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGNlbGxET00ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRlbXBvcmFyeS10YWJsZS1jZWxsLWxleGljYWwta2V5Jyk7XG4gICAgICAgICAgICBpZiAoY2VsbFNwYW4pIHtcbiAgICAgICAgICAgICAgY2VsbFZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsU3Bhbi5jb2xTcGFuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrbm93bkNvbHVtbnMuYWRkKGkgKyBjZWxsU3Bhbi5zdGFydENvbHVtbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2xncm91cCBhbmQgY29sdW1ucyBpbiB0aGUgZXhwb3J0XG4gICAgICAgIGNvbnN0IGNvbEdyb3VwID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IGNvbGdyb3VwJyk7XG4gICAgICAgIGlmIChjb2xHcm91cCkge1xuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgPGNvbCAvPiBmb3Igcm93cyB0aGF0IGFyZSBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgY29uc3QgY29scyA9IEFycmF5LmZyb20odGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbGdyb3VwID4gY29sJykpLmZpbHRlcigoZG9tLCBpKSA9PiBrbm93bkNvbHVtbnMuaGFzKGkpKTtcbiAgICAgICAgICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcmFwIGRpcmVjdCBkZXNjZW5kYW50IHJvd3MgaW4gYSB0Ym9keSBmb3IgZXhwb3J0XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gdHInKTtcbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICB0Qm9keS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZUVsZW1lbnQuYXBwZW5kKHRCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVFbGVtZW50O1xuICAgICAgfSxcbiAgICAgIGVsZW1lbnQ6ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgJiYgaXNIVE1MRWxlbWVudCQxKGVsZW1lbnQpID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpIDogZWxlbWVudFxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93cyxcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgICBjb25zdCBjZWxsID0gcm93W3hdO1xuICAgICAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVsZW1cbiAgICAgICAgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IGNlbGxOb2RlID0gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGhpcywgZWxlbSk7XG4gICAgICAgIGlmIChjZWxsTm9kZSAhPT0gbnVsbCAmJiB0YWJsZUNlbGxOb2RlLmlzKGNlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIG5vdCBmb3VuZCBpbiB0YWJsZS4nKTtcbiAgfVxuICBnZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZG9tUm93c1xuICAgIH0gPSB0YWJsZTtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0geCA8IHJvdy5sZW5ndGggPyB4IDogcm93Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY2VsbCA9IHJvd1tpbmRleF07XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGF0IGNvcmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuICBnZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBhdCBjb3JkcyBub3QgVGFibGVDZWxsTm9kZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0Um93U3RyaXBpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRMYXRlc3QoKS5fX3Jvd1N0cmlwaW5nKTtcbiAgfVxuICBzZXRSb3dTdHJpcGluZyhuZXdSb3dTdHJpcGluZykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3Jvd1N0cmlwaW5nID0gbmV3Um93U3RyaXBpbmc7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc2V0RnJvemVuQ29sdW1ucyhjb2x1bW5Db3VudCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zyb3plbkNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0RnJvemVuQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2Zyb3plbkNvbHVtbkNvdW50O1xuICB9XG4gIHNldEZyb3plblJvd3Mocm93Q291bnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mcm96ZW5Sb3dDb3VudCA9IHJvd0NvdW50O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldEZyb3plblJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19mcm96ZW5Sb3dDb3VudDtcbiAgfVxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRDb2x1bW5Db3VudCgpIHtcbiAgICBjb25zdCBmaXJzdFJvdyA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghZmlyc3RSb3cpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuICAgIGZpcnN0Um93LmdldENoaWxkcmVuKCkuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIGNvbHVtbkNvdW50ICs9IGNlbGwuZ2V0Q29sU3BhbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5Db3VudDtcbiAgfVxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUoZWRpdG9yLCB0YWJsZU5vZGUpIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZTogVGFibGUgRWxlbWVudCBOb3QgRm91bmRgKTtcbiAgfVxuICByZXR1cm4gZ2V0VGFibGUodGFibGVOb2RlLCB0YWJsZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpKSB7XG4gICAgdGFibGVOb2RlLnNldFJvd1N0cmlwaW5nKHRydWUpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1jb2x1bW4nKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Db2x1bW5zKDEpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1yb3cnKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Sb3dzKDEpO1xuICB9XG4gIGNvbnN0IGNvbEdyb3VwID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBjb2xncm91cCcpO1xuICBpZiAoY29sR3JvdXApIHtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29sIG9mIGNvbEdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbCcpKSB7XG4gICAgICBsZXQgd2lkdGggPSBjb2wuc3R5bGUud2lkdGggfHwgJyc7XG4gICAgICBpZiAoIVBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdCh3aWR0aCkpIHtcbiAgICAgICAgLy8gQWxzbyBzdXBwb3J0IGRlcHJlY2F0ZWQgd2lkdGggYXR0cmlidXRlIGZvciBnb29nbGUgZG9jc1xuICAgICAgICB3aWR0aCA9IGNvbC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJyc7XG4gICAgICAgIGlmICghL15cXGQrJC8udGVzdCh3aWR0aCkpIHtcbiAgICAgICAgICBjb2x1bW5zID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb2x1bW5zLnB1c2gocGFyc2VGbG9hdCh3aWR0aCkpO1xuICAgIH1cbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgdGFibGVOb2RlLnNldENvbFdpZHRocyhjb2x1bW5zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRyZW4gPT4gJGRlc2NlbmRhbnRzTWF0Y2hpbmcoY2hpbGRyZW4sICRpc1RhYmxlUm93Tm9kZSksXG4gICAgbm9kZTogdGFibGVOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyKHtcbiAgcm93cyxcbiAgY29sdW1ucyxcbiAgaW5jbHVkZUhlYWRlcnNcbn0pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgbmVzdGVkIHRhYmxlcyBieSBjaGVja2luZyBpZiB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhIHRhYmxlXG4gIGlmICgkZmluZFRhYmxlTm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKE51bWJlcihyb3dzKSwgTnVtYmVyKGNvbHVtbnMpLCBpbmNsdWRlSGVhZGVycyk7XG4gICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCh0YWJsZU5vZGUpO1xuICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSB0YWJsZU5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdERlc2NlbmRhbnQpKSB7XG4gICAgZmlyc3REZXNjZW5kYW50LnNlbGVjdCgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJHRhYmxlQ2VsbFRyYW5zZm9ybShub2RlKSB7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKG5vZGUuZ2V0UGFyZW50KCkpKSB7XG4gICAgLy8gVGFibGVDZWxsTm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVSb3dOb2RlLlxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5pc0VtcHR5KCkpIHtcbiAgICAvLyBUYWJsZUNlbGxOb2RlIHNob3VsZCBuZXZlciBiZSBlbXB0eVxuICAgIG5vZGUuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVSb3dUcmFuc2Zvcm0obm9kZSkge1xuICBpZiAoISRpc1RhYmxlTm9kZShub2RlLmdldFBhcmVudCgpKSkge1xuICAgIC8vIFRhYmxlUm93Tm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVOb2RlLlxuICAgIC8vIFRPRE86IEZ1dHVyZSBzdXBwb3J0IG9mIHRib2R5L3RoZWFkL3Rmb290IG1heSBjaGFuZ2UgdGhpc1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzKG5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVUcmFuc2Zvcm0obm9kZSkge1xuICAvLyBUYWJsZVJvd05vZGUgaXMgdGhlIG9ubHkgdmFsaWQgY2hpbGQgZm9yIFRhYmxlTm9kZVxuICAvLyBUT0RPOiBGdXR1cmUgc3VwcG9ydCBvZiB0Ym9keS90aGVhZC90Zm9vdC9jYXB0aW9uIG1heSBjaGFuZ2UgdGhpc1xuICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMobm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sobm9kZSwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IG1heFJvd0xlbmd0aCA9IGdyaWRNYXAucmVkdWNlKChjdXJMZW5ndGgsIHJvdykgPT4ge1xuICAgIHJldHVybiBNYXRoLm1heChjdXJMZW5ndGgsIHJvdy5sZW5ndGgpO1xuICB9LCAwKTtcbiAgY29uc3Qgcm93Tm9kZXMgPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZE1hcC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJvd05vZGUgPSByb3dOb2Rlc1tpXTtcbiAgICBpZiAoIXJvd05vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZVBsdWdpbjogRXhwZWN0aW5nIGFsbCBjaGlsZHJlbiBvZiBUYWJsZU5vZGUgdG8gYmUgVGFibGVSb3dOb2RlLCBmb3VuZCAke3Jvd05vZGUuY29uc3RydWN0b3IubmFtZX0gKHR5cGUgJHtyb3dOb2RlLmdldFR5cGUoKX0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHJvd0xlbmd0aCA9IGdyaWRNYXBbaV0ucmVkdWNlKChhY2MsIGNlbGwpID0+IGNlbGwgPyAxICsgYWNjIDogYWNjLCAwKTtcbiAgICBpZiAocm93TGVuZ3RoID09PSBtYXhSb3dMZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gcm93TGVuZ3RoOyBqIDwgbWF4Um93TGVuZ3RoOyArK2opIHtcbiAgICAgIC8vIFRPRE86IGluaGVyaXQgaGVhZGVyIHN0YXRlIGZyb20gYW5vdGhlciBoZWFkZXIgb3IgYm9keVxuICAgICAgY29uc3QgbmV3Q2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKCk7XG4gICAgICBuZXdDZWxsLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgIHJvd05vZGUuYXBwZW5kKG5ld0NlbGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHRhYmxlQ2xpY2tDb21tYW5kKGV2ZW50KSB7XG4gIGlmIChldmVudC5kZXRhaWwgPCAzIHx8ICFpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdGFydE5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShldmVudC50YXJnZXQpO1xuICBpZiAoc3RhcnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoYmxvY2tOb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gYmxvY2tOb2RlLmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUocm9vdE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGJsb2NrTm9kZS5zZWxlY3QoMCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdHJhbnNmb3JtIHRvIGVuc3VyZSB0aGF0IGFsbCBUYWJsZUNlbGxOb2RlIGhhdmUgYSBjb2xTcGFuIGFuZCByb3dTcGFuIG9mIDEuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHJlZ2lzdGVyZWQgd2hlbiB5b3UgZG8gbm90IHdhbnQgdG8gc3VwcG9ydCBtZXJnZWQgY2VsbHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybShlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVDZWxsTm9kZSwgbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUuZ2V0Q29sU3BhbigpID4gMSB8fCBub2RlLmdldFJvd1NwYW4oKSA+IDEpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSByb3dTcGFuIHdlIGhhdmUgdG8gbWFwIHRoZSBlbnRpcmUgVGFibGUgdG8gdW5kZXJzdGFuZCB3aGVyZSB0aGUgbmV3IENlbGxzXG4gICAgICAvLyBmaXQgYmVzdDsgbGV0J3MgYW5hbHl6ZSBhbGwgQ2VsbHMgYXQgb25jZSB0byBzYXZlIHVzIGZyb20gZnVydGhlciB0cmFuc2Zvcm0gaXRlcmF0aW9uc1xuICAgICAgY29uc3QgWywsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldChub2RlKTtcbiAgICAgIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIG5vZGUsIG5vZGUpO1xuICAgICAgLy8gVE9ETyB0aGlzIGZ1bmN0aW9uIGV4cGVjdHMgVGFibGVzIHRvIGJlIG5vcm1hbGl6ZWQuIExvb2sgaW50byB0aGlzIG9uY2UgaXQgZXhpc3RzXG4gICAgICBjb25zdCByb3dzQ291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbHVtbnNDb3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICAgICAgbGV0IHJvdyA9IGdyaWROb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgZmlyc3QgY2hpbGQgdG8gYmUgYSBSb3dOb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgIHJvdyA9IHJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGZpcnN0IGNoaWxkIHRvIGJlIGEgUm93Tm9kZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdFJvd0NlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnNDb3VudDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbE1hcCA9IGdyaWRNYXBbaV1bal07XG4gICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxNYXAuY2VsbDtcbiAgICAgICAgICBpZiAoY2VsbE1hcC5zdGFydFJvdyA9PT0gaSAmJiBjZWxsTWFwLnN0YXJ0Q29sdW1uID09PSBqKSB7XG4gICAgICAgICAgICBsYXN0Um93Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICB1bm1lcmdlZC5wdXNoKGNlbGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5nZXRDb2xTcGFuKCkgPiAxIHx8IGNlbGwuZ2V0Um93U3BhbigpID4gMSkge1xuICAgICAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNlbGwgdG8gYmUgYSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY2VsbC5fX2hlYWRlclN0YXRlKTtcbiAgICAgICAgICAgIGlmIChsYXN0Um93Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0Um93Q2VsbC5pbnNlcnRBZnRlcihuZXdDZWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRpbnNlcnRGaXJzdCQxKHJvdywgbmV3Q2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdW5tZXJnZWQpIHtcbiAgICAgICAgY2VsbC5zZXRDb2xTcGFuKDEpO1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcihlZGl0b3IsIGhhc1RhYkhhbmRsZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlU2VsZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZVRhYmxlTm9kZSA9ICh0YWJsZU5vZGUsIG5vZGVLZXksIGRvbSkgPT4ge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gICAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcik7XG4gICAgdGFibGVTZWxlY3Rpb25zLnNldChub2RlS2V5LCBbdGFibGVTZWxlY3Rpb24sIHRhYmxlRWxlbWVudF0pO1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lciA9IGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoVGFibGVOb2RlLCBub2RlTXV0YXRpb25zID0+IHtcbiAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG11dGF0aW9uXSBvZiBub2RlTXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gdGFibGVTZWxlY3Rpb25zLmdldChub2RlS2V5KTtcbiAgICAgICAgaWYgKG11dGF0aW9uID09PSAnY3JlYXRlZCcgfHwgbXV0YXRpb24gPT09ICd1cGRhdGVkJykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhYmxlTm9kZSxcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudFxuICAgICAgICAgIH0gPSAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXkobm9kZUtleSk7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlLCBub2RlS2V5LCB0YWJsZUVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFibGVFbGVtZW50ICE9PSB0YWJsZVNlbGVjdGlvblsxXSkge1xuICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjcmVhdGVkIGEgbmV3IERPTSBub2RlLCBkZXN0cm95IHRoZSBleGlzdGluZyBUYWJsZU9ic2VydmVyXG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvblswXS5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9ucy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgICAgICBpbml0aWFsaXplVGFibGVOb2RlKHRhYmxlTm9kZSwgbm9kZUtleSwgdGFibGVFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24gPT09ICdkZXN0cm95ZWQnKSB7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uWzBdLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb25zLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfSwge1xuICAgIHNraXBJbml0aWFsaXphdGlvbjogZmFsc2VcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdW5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoKTtcbiAgICAvLyBIb29rIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBzbyBjbGVhbmluZyB1cCB0YWJsZXMgbGlzdGVuZXJzIGFzIHdlbGwsXG4gICAgLy8gYXMgaXQnbGwgYmUgcmVpbml0aWFsaXplZCBkdXJpbmcgcmVjdXJyaW5nIGNhbGxcbiAgICBmb3IgKGNvbnN0IFssIFt0YWJsZVNlbGVjdGlvbl1dIG9mIHRhYmxlU2VsZWN0aW9ucykge1xuICAgICAgdGFibGVTZWxlY3Rpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBJTlNFUlRfVEFCTEVfQ09NTUFORCBsaXN0ZW5lciBhbmQgdGhlIHRhYmxlIGludGVncml0eSB0cmFuc2Zvcm1zLiBUaGVcbiAqIHRhYmxlIHNlbGVjdGlvbiBvYnNlcnZlciBzaG91bGQgYmUgcmVnaXN0ZXJlZCBzZXBhcmF0ZWx5IGFmdGVyIHRoaXMgd2l0aFxuICoge0BsaW5rIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcn0uXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVQbHVnaW4oZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yLmhhc05vZGVzKFtUYWJsZU5vZGVdKSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVQbHVnaW46IFRhYmxlTm9kZSBpcyBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3JgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVEFCTEVfQ09NTUFORCwgJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgKHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvciB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0luc2lkZVRhYmxlQ2VsbCA9ICRmaW5kVGFibGVOb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSAhPT0gbnVsbDtcbiAgICByZXR1cm4gaXNJbnNpZGVUYWJsZUNlbGwgJiYgbm9kZXMuc29tZSgkaXNUYWJsZU5vZGUpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgJHRhYmxlQ2xpY2tDb21tYW5kLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVOb2RlLCAkdGFibGVUcmFuc2Zvcm0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRhYmxlUm93Tm9kZSwgJHRhYmxlUm93VHJhbnNmb3JtKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUYWJsZUNlbGxOb2RlLCAkdGFibGVDZWxsVHJhbnNmb3JtKSk7XG59XG5cbmV4cG9ydCB7ICRjb21wdXRlVGFibGVNYXAsICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrLCAkY3JlYXRlVGFibGVDZWxsTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zLCAkY3JlYXRlVGFibGVSb3dOb2RlLCAkY3JlYXRlVGFibGVTZWxlY3Rpb24sICRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb20sICRkZWxldGVUYWJsZUNvbHVtbiwgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24sICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMLCAkZGVsZXRlVGFibGVSb3dBdFNlbGVjdGlvbiwgJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUwsICRmaW5kQ2VsbE5vZGUsICRmaW5kVGFibGVOb2RlLCAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZSwgJGdldE5vZGVUcmlwbGV0LCAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXksICRnZXRUYWJsZUNlbGxOb2RlRnJvbUxleGljYWxOb2RlLCAkZ2V0VGFibGVDZWxsTm9kZVJlY3QsICRnZXRUYWJsZUNvbHVtbkluZGV4RnJvbVRhYmxlQ2VsbE5vZGUsICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93LCAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlLCAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93LCAkaW5zZXJ0VGFibGVDb2x1bW4sICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uLCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGluc2VydFRhYmxlUm93LCAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbiwgJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwsICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUsICRpc1RhYmxlQ2VsbE5vZGUsICRpc1RhYmxlTm9kZSwgJGlzVGFibGVSb3dOb2RlLCAkaXNUYWJsZVNlbGVjdGlvbiwgJG1lcmdlQ2VsbHMsICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgsICR1bm1lcmdlQ2VsbCwgSU5TRVJUX1RBQkxFX0NPTU1BTkQsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcywgVGFibGVDZWxsTm9kZSwgVGFibGVOb2RlLCBUYWJsZU9ic2VydmVyLCBUYWJsZVJvd05vZGUsIGFwcGx5VGFibGVIYW5kbGVycywgZ2V0RE9NQ2VsbEZyb21UYXJnZXQsIGdldFRhYmxlRWxlbWVudCwgZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQsIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybSwgcmVnaXN0ZXJUYWJsZVBsdWdpbiwgcmVnaXN0ZXJUYWJsZVNlbGVjdGlvbk9ic2VydmVyLCBzZXRTY3JvbGxhYmxlVGFibGVzQWN0aXZlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $computeTableMap: () => (/* binding */ $computeTableMap),\n/* harmony export */   $computeTableMapSkipCellCheck: () => (/* binding */ $computeTableMapSkipCellCheck),\n/* harmony export */   $createTableCellNode: () => (/* binding */ $createTableCellNode),\n/* harmony export */   $createTableNode: () => (/* binding */ $createTableNode),\n/* harmony export */   $createTableNodeWithDimensions: () => (/* binding */ $createTableNodeWithDimensions),\n/* harmony export */   $createTableRowNode: () => (/* binding */ $createTableRowNode),\n/* harmony export */   $createTableSelection: () => (/* binding */ $createTableSelection),\n/* harmony export */   $createTableSelectionFrom: () => (/* binding */ $createTableSelectionFrom),\n/* harmony export */   $deleteTableColumn: () => (/* binding */ $deleteTableColumn),\n/* harmony export */   $deleteTableColumnAtSelection: () => (/* binding */ $deleteTableColumnAtSelection),\n/* harmony export */   $deleteTableColumn__EXPERIMENTAL: () => (/* binding */ $deleteTableColumn__EXPERIMENTAL),\n/* harmony export */   $deleteTableRowAtSelection: () => (/* binding */ $deleteTableRowAtSelection),\n/* harmony export */   $deleteTableRow__EXPERIMENTAL: () => (/* binding */ $deleteTableRow__EXPERIMENTAL),\n/* harmony export */   $findCellNode: () => (/* binding */ $findCellNode),\n/* harmony export */   $findTableNode: () => (/* binding */ $findTableNode),\n/* harmony export */   $getElementForTableNode: () => (/* binding */ $getElementForTableNode),\n/* harmony export */   $getNodeTriplet: () => (/* binding */ $getNodeTriplet),\n/* harmony export */   $getTableAndElementByKey: () => (/* binding */ $getTableAndElementByKey),\n/* harmony export */   $getTableCellNodeFromLexicalNode: () => (/* binding */ $getTableCellNodeFromLexicalNode),\n/* harmony export */   $getTableCellNodeRect: () => (/* binding */ $getTableCellNodeRect),\n/* harmony export */   $getTableColumnIndexFromTableCellNode: () => (/* binding */ $getTableColumnIndexFromTableCellNode),\n/* harmony export */   $getTableNodeFromLexicalNodeOrThrow: () => (/* binding */ $getTableNodeFromLexicalNodeOrThrow),\n/* harmony export */   $getTableRowIndexFromTableCellNode: () => (/* binding */ $getTableRowIndexFromTableCellNode),\n/* harmony export */   $getTableRowNodeFromTableCellNodeOrThrow: () => (/* binding */ $getTableRowNodeFromTableCellNodeOrThrow),\n/* harmony export */   $insertTableColumn: () => (/* binding */ $insertTableColumn),\n/* harmony export */   $insertTableColumnAtSelection: () => (/* binding */ $insertTableColumnAtSelection),\n/* harmony export */   $insertTableColumn__EXPERIMENTAL: () => (/* binding */ $insertTableColumn__EXPERIMENTAL),\n/* harmony export */   $insertTableRow: () => (/* binding */ $insertTableRow),\n/* harmony export */   $insertTableRowAtSelection: () => (/* binding */ $insertTableRowAtSelection),\n/* harmony export */   $insertTableRow__EXPERIMENTAL: () => (/* binding */ $insertTableRow__EXPERIMENTAL),\n/* harmony export */   $isScrollableTablesActive: () => (/* binding */ $isScrollableTablesActive),\n/* harmony export */   $isTableCellNode: () => (/* binding */ $isTableCellNode),\n/* harmony export */   $isTableNode: () => (/* binding */ $isTableNode),\n/* harmony export */   $isTableRowNode: () => (/* binding */ $isTableRowNode),\n/* harmony export */   $isTableSelection: () => (/* binding */ $isTableSelection),\n/* harmony export */   $mergeCells: () => (/* binding */ $mergeCells),\n/* harmony export */   $removeTableRowAtIndex: () => (/* binding */ $removeTableRowAtIndex),\n/* harmony export */   $unmergeCell: () => (/* binding */ $unmergeCell),\n/* harmony export */   INSERT_TABLE_COMMAND: () => (/* binding */ INSERT_TABLE_COMMAND),\n/* harmony export */   TableCellHeaderStates: () => (/* binding */ TableCellHeaderStates),\n/* harmony export */   TableCellNode: () => (/* binding */ TableCellNode),\n/* harmony export */   TableNode: () => (/* binding */ TableNode),\n/* harmony export */   TableObserver: () => (/* binding */ TableObserver),\n/* harmony export */   TableRowNode: () => (/* binding */ TableRowNode),\n/* harmony export */   applyTableHandlers: () => (/* binding */ applyTableHandlers),\n/* harmony export */   getDOMCellFromTarget: () => (/* binding */ getDOMCellFromTarget),\n/* harmony export */   getTableElement: () => (/* binding */ getTableElement),\n/* harmony export */   getTableObserverFromTableElement: () => (/* binding */ getTableObserverFromTableElement),\n/* harmony export */   registerTableCellUnmergeTransform: () => (/* binding */ registerTableCellUnmergeTransform),\n/* harmony export */   registerTablePlugin: () => (/* binding */ registerTablePlugin),\n/* harmony export */   registerTableSelectionObserver: () => (/* binding */ registerTableSelectionObserver),\n/* harmony export */   setScrollableTablesActive: () => (/* binding */ setScrollableTablesActive)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/* harmony import */ var _lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @lexical/clipboard */ \"(ssr)/./node_modules/.pnpm/@lexical+clipboard@0.35.0/node_modules/@lexical/clipboard/LexicalClipboard.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst PIXEL_VALUE_REG_EXP = /^(\\d+(?:\\.\\d+)?)px$/;\n\n// .PlaygroundEditorTheme__tableCell width value from\n// packages/lexical-playground/src/themes/PlaygroundEditorTheme.css\nconst COLUMN_WIDTH = 75;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TableCellHeaderStates = {\n  BOTH: 3,\n  COLUMN: 2,\n  NO_STATUS: 0,\n  ROW: 1\n};\n/** @noInheritDoc */\nclass TableCellNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'tablecell';\n  }\n  static clone(node) {\n    return new TableCellNode(node.__headerState, node.__colSpan, node.__width, node.__key);\n  }\n  afterCloneFrom(node) {\n    super.afterCloneFrom(node);\n    this.__rowSpan = node.__rowSpan;\n    this.__backgroundColor = node.__backgroundColor;\n    this.__verticalAlign = node.__verticalAlign;\n  }\n  static importDOM() {\n    return {\n      td: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      }),\n      th: node => ({\n        conversion: $convertTableCellNodeElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableCellNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeaderStyles(serializedNode.headerState).setColSpan(serializedNode.colSpan || 1).setRowSpan(serializedNode.rowSpan || 1).setWidth(serializedNode.width || undefined).setBackgroundColor(serializedNode.backgroundColor || null).setVerticalAlign(serializedNode.verticalAlign || undefined);\n  }\n  constructor(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n    this.__headerState = headerState;\n    this.__width = width;\n    this.__backgroundColor = null;\n    this.__verticalAlign = undefined;\n  }\n  createDOM(config) {\n    const element = document.createElement(this.getTag());\n    if (this.__width) {\n      element.style.width = `${this.__width}px`;\n    }\n    if (this.__colSpan > 1) {\n      element.colSpan = this.__colSpan;\n    }\n    if (this.__rowSpan > 1) {\n      element.rowSpan = this.__rowSpan;\n    }\n    if (this.__backgroundColor !== null) {\n      element.style.backgroundColor = this.__backgroundColor;\n    }\n    if (isValidVerticalAlign(this.__verticalAlign)) {\n      element.style.verticalAlign = this.__verticalAlign;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableCell, this.hasHeader() && config.theme.tableCellHeader);\n    return element;\n  }\n  exportDOM(editor) {\n    const output = super.exportDOM(editor);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(output.element)) {\n      const element = output.element;\n      element.setAttribute('data-temporary-table-cell-lexical-key', this.getKey());\n      element.style.border = '1px solid black';\n      if (this.__colSpan > 1) {\n        element.colSpan = this.__colSpan;\n      }\n      if (this.__rowSpan > 1) {\n        element.rowSpan = this.__rowSpan;\n      }\n      element.style.width = `${this.getWidth() || COLUMN_WIDTH}px`;\n      element.style.verticalAlign = this.getVerticalAlign() || 'top';\n      element.style.textAlign = 'start';\n      if (this.__backgroundColor === null && this.hasHeader()) {\n        element.style.backgroundColor = '#f2f3f5';\n      }\n    }\n    return output;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ...(isValidVerticalAlign(this.__verticalAlign) && {\n        verticalAlign: this.__verticalAlign\n      }),\n      backgroundColor: this.getBackgroundColor(),\n      colSpan: this.__colSpan,\n      headerState: this.__headerState,\n      rowSpan: this.__rowSpan,\n      width: this.getWidth()\n    };\n  }\n  getColSpan() {\n    return this.getLatest().__colSpan;\n  }\n  setColSpan(colSpan) {\n    const self = this.getWritable();\n    self.__colSpan = colSpan;\n    return self;\n  }\n  getRowSpan() {\n    return this.getLatest().__rowSpan;\n  }\n  setRowSpan(rowSpan) {\n    const self = this.getWritable();\n    self.__rowSpan = rowSpan;\n    return self;\n  }\n  getTag() {\n    return this.hasHeader() ? 'th' : 'td';\n  }\n  setHeaderStyles(headerState, mask = TableCellHeaderStates.BOTH) {\n    const self = this.getWritable();\n    self.__headerState = headerState & mask | self.__headerState & ~mask;\n    return self;\n  }\n  getHeaderStyles() {\n    return this.getLatest().__headerState;\n  }\n  setWidth(width) {\n    const self = this.getWritable();\n    self.__width = width;\n    return self;\n  }\n  getWidth() {\n    return this.getLatest().__width;\n  }\n  getBackgroundColor() {\n    return this.getLatest().__backgroundColor;\n  }\n  setBackgroundColor(newBackgroundColor) {\n    const self = this.getWritable();\n    self.__backgroundColor = newBackgroundColor;\n    return self;\n  }\n  getVerticalAlign() {\n    return this.getLatest().__verticalAlign;\n  }\n  setVerticalAlign(newVerticalAlign) {\n    const self = this.getWritable();\n    self.__verticalAlign = newVerticalAlign || undefined;\n    return self;\n  }\n  toggleHeaderStyle(headerStateToToggle) {\n    const self = this.getWritable();\n    if ((self.__headerState & headerStateToToggle) === headerStateToToggle) {\n      self.__headerState -= headerStateToToggle;\n    } else {\n      self.__headerState += headerStateToToggle;\n    }\n    return self;\n  }\n  hasHeaderState(headerState) {\n    return (this.getHeaderStyles() & headerState) === headerState;\n  }\n  hasHeader() {\n    return this.getLatest().__headerState !== TableCellHeaderStates.NO_STATUS;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__headerState !== this.__headerState || prevNode.__width !== this.__width || prevNode.__colSpan !== this.__colSpan || prevNode.__rowSpan !== this.__rowSpan || prevNode.__backgroundColor !== this.__backgroundColor || prevNode.__verticalAlign !== this.__verticalAlign;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  collapseAtStart() {\n    return true;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction isValidVerticalAlign(verticalAlign) {\n  return verticalAlign === 'middle' || verticalAlign === 'bottom';\n}\nfunction $convertTableCellNodeElement(domNode) {\n  const domNode_ = domNode;\n  const nodeName = domNode.nodeName.toLowerCase();\n  let width = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.width)) {\n    width = parseFloat(domNode_.style.width);\n  }\n  const tableCellNode = $createTableCellNode(nodeName === 'th' ? TableCellHeaderStates.ROW : TableCellHeaderStates.NO_STATUS, domNode_.colSpan, width);\n  tableCellNode.__rowSpan = domNode_.rowSpan;\n  const backgroundColor = domNode_.style.backgroundColor;\n  if (backgroundColor !== '') {\n    tableCellNode.__backgroundColor = backgroundColor;\n  }\n  const verticalAlign = domNode_.style.verticalAlign;\n  if (isValidVerticalAlign(verticalAlign)) {\n    tableCellNode.__verticalAlign = verticalAlign;\n  }\n  const style = domNode_.style;\n  const textDecoration = (style && style.textDecoration || '').split(' ');\n  const hasBoldFontWeight = style.fontWeight === '700' || style.fontWeight === 'bold';\n  const hasLinethroughTextDecoration = textDecoration.includes('line-through');\n  const hasItalicFontStyle = style.fontStyle === 'italic';\n  const hasUnderlineTextDecoration = textDecoration.includes('underline');\n  return {\n    after: childLexicalNodes => {\n      const result = [];\n      let paragraphNode = null;\n      const removeSingleLineBreakNode = () => {\n        if (paragraphNode) {\n          const firstChild = paragraphNode.getFirstChild();\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(firstChild) && paragraphNode.getChildrenSize() === 1) {\n            firstChild.remove();\n          }\n        }\n      };\n      for (const child of childLexicalNodes) {\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isInlineElementOrDecoratorNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isLineBreakNode)(child)) {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            if (hasBoldFontWeight) {\n              child.toggleFormat('bold');\n            }\n            if (hasLinethroughTextDecoration) {\n              child.toggleFormat('strikethrough');\n            }\n            if (hasItalicFontStyle) {\n              child.toggleFormat('italic');\n            }\n            if (hasUnderlineTextDecoration) {\n              child.toggleFormat('underline');\n            }\n          }\n          if (paragraphNode) {\n            paragraphNode.append(child);\n          } else {\n            paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)().append(child);\n            result.push(paragraphNode);\n          }\n        } else {\n          result.push(child);\n          removeSingleLineBreakNode();\n          paragraphNode = null;\n        }\n      }\n      removeSingleLineBreakNode();\n      if (result.length === 0) {\n        result.push((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      }\n      return result;\n    },\n    node: tableCellNode\n  };\n}\nfunction $createTableCellNode(headerState = TableCellHeaderStates.NO_STATUS, colSpan = 1, width) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableCellNode(headerState, colSpan, width));\n}\nfunction $isTableCellNode(node) {\n  return node instanceof TableCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst INSERT_TABLE_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('INSERT_TABLE_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TableRowNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'tablerow';\n  }\n  static clone(node) {\n    return new TableRowNode(node.__height, node.__key);\n  }\n  static importDOM() {\n    return {\n      tr: node => ({\n        conversion: $convertTableRowElement,\n        priority: 0\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableRowNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setHeight(serializedNode.height);\n  }\n  constructor(height, key) {\n    super(key);\n    this.__height = height;\n  }\n  exportJSON() {\n    const height = this.getHeight();\n    return {\n      ...super.exportJSON(),\n      ...(height === undefined ? undefined : {\n        height\n      })\n    };\n  }\n  createDOM(config) {\n    const element = document.createElement('tr');\n    if (this.__height) {\n      element.style.height = `${this.__height}px`;\n    }\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.tableRow);\n    return element;\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  isShadowRoot() {\n    return true;\n  }\n  setHeight(height) {\n    const self = this.getWritable();\n    self.__height = height;\n    return self;\n  }\n  getHeight() {\n    return this.getLatest().__height;\n  }\n  updateDOM(prevNode) {\n    return prevNode.__height !== this.__height;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  canIndent() {\n    return false;\n  }\n}\nfunction $convertTableRowElement(domNode) {\n  const domNode_ = domNode;\n  let height = undefined;\n  if (PIXEL_VALUE_REG_EXP.test(domNode_.style.height)) {\n    height = parseFloat(domNode_.style.height);\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableCellNode),\n    node: $createTableRowNode(height)\n  };\n}\nfunction $createTableRowNode(height) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableRowNode(height));\n}\nfunction $isTableRowNode(node) {\n  return node instanceof TableRowNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nCAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\n\nfunction $createTableNodeWithDimensions(rowCount, columnCount, includeHeaders = true) {\n  const tableNode = $createTableNode();\n  for (let iRow = 0; iRow < rowCount; iRow++) {\n    const tableRowNode = $createTableRowNode();\n    for (let iColumn = 0; iColumn < columnCount; iColumn++) {\n      let headerState = TableCellHeaderStates.NO_STATUS;\n      if (typeof includeHeaders === 'object') {\n        if (iRow === 0 && includeHeaders.rows) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0 && includeHeaders.columns) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      } else if (includeHeaders) {\n        if (iRow === 0) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        if (iColumn === 0) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n      }\n      const tableCellNode = $createTableCellNode(headerState);\n      const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n      paragraphNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)());\n      tableCellNode.append(paragraphNode);\n      tableRowNode.append(tableCellNode);\n    }\n    tableNode.append(tableRowNode);\n  }\n  return tableNode;\n}\nfunction $getTableCellNodeFromLexicalNode(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableCellNode(n));\n  if ($isTableCellNode(node)) {\n    return node;\n  }\n  return null;\n}\nfunction $getTableRowNodeFromTableCellNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableRowNode(n));\n  if ($isTableRowNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table row.');\n}\nfunction $getTableNodeFromLexicalNodeOrThrow(startingNode) {\n  const node = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startingNode, n => $isTableNode(n));\n  if ($isTableNode(node)) {\n    return node;\n  }\n  throw new Error('Expected table cell to be inside of table.');\n}\nfunction $getTableRowIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableRowNode);\n  return tableNode.getChildren().findIndex(n => n.is(tableRowNode));\n}\nfunction $getTableColumnIndexFromTableCellNode(tableCellNode) {\n  const tableRowNode = $getTableRowNodeFromTableCellNodeOrThrow(tableCellNode);\n  return tableRowNode.getChildren().findIndex(n => n.is(tableCellNode));\n}\nfunction $getTableCellSiblingsFromTableCellNode(tableCellNode, table) {\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(tableCellNode);\n  const {\n    x,\n    y\n  } = tableNode.getCordsFromCellNode(tableCellNode, table);\n  return {\n    above: tableNode.getCellNodeFromCords(x, y - 1, table),\n    below: tableNode.getCellNodeFromCords(x, y + 1, table),\n    left: tableNode.getCellNodeFromCords(x - 1, y, table),\n    right: tableNode.getCellNodeFromCords(x + 1, y, table)\n  };\n}\nfunction $removeTableRowAtIndex(tableNode, indexToDelete) {\n  const tableRows = tableNode.getChildren();\n  if (indexToDelete >= tableRows.length || indexToDelete < 0) {\n    throw new Error('Expected table cell to be inside of table row.');\n  }\n  const targetRowNode = tableRows[indexToDelete];\n  targetRowNode.remove();\n  return tableNode;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableRowAtSelection} or {@link $insertTableRowAtNode} instead.\n */\nfunction $insertTableRow(tableNode, targetIndex, shouldInsertAfter = true, rowCount, table) {\n  const tableRows = tableNode.getChildren();\n  if (targetIndex >= tableRows.length || targetIndex < 0) {\n    throw new Error('Table row target index out of range');\n  }\n  const targetRowNode = tableRows[targetIndex];\n  if ($isTableRowNode(targetRowNode)) {\n    for (let r = 0; r < rowCount; r++) {\n      const tableRowCells = targetRowNode.getChildren();\n      const tableColumnCount = tableRowCells.length;\n      const newTableRowNode = $createTableRowNode();\n      for (let c = 0; c < tableColumnCount; c++) {\n        const tableCellFromTargetRow = tableRowCells[c];\n        if (!$isTableCellNode(tableCellFromTargetRow)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          above,\n          below\n        } = $getTableCellSiblingsFromTableCellNode(tableCellFromTargetRow, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        const width = above && above.getWidth() || below && below.getWidth() || undefined;\n        if (above && above.hasHeaderState(TableCellHeaderStates.COLUMN) || below && below.hasHeaderState(TableCellHeaderStates.COLUMN)) {\n          headerState |= TableCellHeaderStates.COLUMN;\n        }\n        const tableCellNode = $createTableCellNode(headerState, 1, width);\n        tableCellNode.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        newTableRowNode.append(tableCellNode);\n      }\n      if (shouldInsertAfter) {\n        targetRowNode.insertAfter(newTableRowNode);\n      } else {\n        targetRowNode.insertBefore(newTableRowNode);\n      }\n    }\n  } else {\n    throw new Error('Row before insertion index does not exist.');\n  }\n  return tableNode;\n}\nconst getHeaderState = (currentState, possibleState) => {\n  if (currentState === TableCellHeaderStates.BOTH || currentState === possibleState) {\n    return possibleState;\n  }\n  return TableCellHeaderStates.NO_STATUS;\n};\n\n/**\n * Inserts a table row before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableRowAtNode(anchorStartRow + anchorCell.__rowSpan > focusStartRow + focusCell.__rowSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableRowAtNode(focusStartRow < anchorStartRow ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableRowAtSelection}\n */\nconst $insertTableRow__EXPERIMENTAL = $insertTableRowAtSelection;\n\n/**\n * Inserts a table row before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * inserted table row node.\n */\nfunction $insertTableRowAtNode(cellNode, insertAfter = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const columnCount = gridMap[0].length;\n  const {\n    startRow: cellStartRow\n  } = cellMap;\n  let insertedRow = null;\n  if (insertAfter) {\n    const insertAfterEndRow = cellStartRow + cellNode.__rowSpan - 1;\n    const insertAfterEndRowMap = gridMap[insertAfterEndRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertAfterEndRowMap[i];\n      if (startRow + cell.__rowSpan - 1 <= insertAfterEndRow) {\n        const currentCell = insertAfterEndRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertAfterEndRowNode = grid.getChildAtIndex(insertAfterEndRow);\n    if (!$isTableRowNode(insertAfterEndRowNode)) {\n      formatDevErrorMessage(`insertAfterEndRow is not a TableRowNode`);\n    }\n    insertAfterEndRowNode.insertAfter(newRow);\n    insertedRow = newRow;\n  } else {\n    const insertBeforeStartRow = cellStartRow;\n    const insertBeforeStartRowMap = gridMap[insertBeforeStartRow];\n    const newRow = $createTableRowNode();\n    for (let i = 0; i < columnCount; i++) {\n      const {\n        cell,\n        startRow\n      } = insertBeforeStartRowMap[i];\n      if (startRow === insertBeforeStartRow) {\n        const currentCell = insertBeforeStartRowMap[i].cell;\n        const currentCellHeaderState = currentCell.__headerState;\n        const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.COLUMN);\n        newRow.append($createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n      } else {\n        cell.setRowSpan(cell.__rowSpan + 1);\n      }\n    }\n    const insertBeforeStartRowNode = grid.getChildAtIndex(insertBeforeStartRow);\n    if (!$isTableRowNode(insertBeforeStartRowNode)) {\n      formatDevErrorMessage(`insertBeforeStartRow is not a TableRowNode`);\n    }\n    insertBeforeStartRowNode.insertBefore(newRow);\n    insertedRow = newRow;\n  }\n  return insertedRow;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $insertTableColumnAtSelection} or {@link $insertTableColumnAtNode} instead.\n */\nfunction $insertTableColumn(tableNode, targetIndex, shouldInsertAfter = true, columnCount, table) {\n  const tableRows = tableNode.getChildren();\n  const tableCellsToBeInserted = [];\n  for (let r = 0; r < tableRows.length; r++) {\n    const currentTableRowNode = tableRows[r];\n    if ($isTableRowNode(currentTableRowNode)) {\n      for (let c = 0; c < columnCount; c++) {\n        const tableRowChildren = currentTableRowNode.getChildren();\n        if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n          throw new Error('Table column target index out of range');\n        }\n        const targetCell = tableRowChildren[targetIndex];\n        if (!$isTableCellNode(targetCell)) {\n          formatDevErrorMessage(`Expected table cell`);\n        }\n        const {\n          left,\n          right\n        } = $getTableCellSiblingsFromTableCellNode(targetCell, table);\n        let headerState = TableCellHeaderStates.NO_STATUS;\n        if (left && left.hasHeaderState(TableCellHeaderStates.ROW) || right && right.hasHeaderState(TableCellHeaderStates.ROW)) {\n          headerState |= TableCellHeaderStates.ROW;\n        }\n        const newTableCell = $createTableCellNode(headerState);\n        newTableCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n        tableCellsToBeInserted.push({\n          newTableCell,\n          targetCell\n        });\n      }\n    }\n  }\n  tableCellsToBeInserted.forEach(({\n    newTableCell,\n    targetCell\n  }) => {\n    if (shouldInsertAfter) {\n      targetCell.insertAfter(newTableCell);\n    } else {\n      targetCell.insertBefore(newTableCell);\n    }\n  });\n  return tableNode;\n}\n\n/**\n * Inserts a column before or after the current focus cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtSelection(insertAfter = true) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell] = $getNodeTriplet(anchor);\n  const [focusCell,, grid] = $getNodeTriplet(focus);\n  const [, focusCellMap, anchorCellMap] = $computeTableMap(grid, focusCell, anchorCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  if (insertAfter) {\n    return $insertTableColumnAtNode(anchorStartColumn + anchorCell.__colSpan > focusStartColumn + focusCell.__colSpan ? anchorCell : focusCell, true);\n  } else {\n    return $insertTableColumnAtNode(focusStartColumn < anchorStartColumn ? focusCell : anchorCell, false);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $insertTableColumnAtSelection}\n */\nconst $insertTableColumn__EXPERIMENTAL = $insertTableColumnAtSelection;\n\n/**\n * Inserts a column before or after the given cell node,\n * taking into account any spans. If successful, returns the\n * first inserted cell node.\n */\nfunction $insertTableColumnAtNode(cellNode, insertAfter = true, shouldSetSelection = true) {\n  const [,, grid] = $getNodeTriplet(cellNode);\n  const [gridMap, cellMap] = $computeTableMap(grid, cellNode, cellNode);\n  const rowCount = gridMap.length;\n  const {\n    startColumn\n  } = cellMap;\n  const insertAfterColumn = insertAfter ? startColumn + cellNode.__colSpan - 1 : startColumn - 1;\n  const gridFirstChild = grid.getFirstChild();\n  if (!$isTableRowNode(gridFirstChild)) {\n    formatDevErrorMessage(`Expected firstTable child to be a row`);\n  }\n  let firstInsertedCell = null;\n  function $createTableCellNodeForInsertTableColumn(headerState = TableCellHeaderStates.NO_STATUS) {\n    const cell = $createTableCellNode(headerState).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n    if (firstInsertedCell === null) {\n      firstInsertedCell = cell;\n    }\n    return cell;\n  }\n  let loopRow = gridFirstChild;\n  rowLoop: for (let i = 0; i < rowCount; i++) {\n    if (i !== 0) {\n      const currentRow = loopRow.getNextSibling();\n      if (!$isTableRowNode(currentRow)) {\n        formatDevErrorMessage(`Expected row nextSibling to be a row`);\n      }\n      loopRow = currentRow;\n    }\n    const rowMap = gridMap[i];\n    const currentCellHeaderState = rowMap[insertAfterColumn < 0 ? 0 : insertAfterColumn].cell.__headerState;\n    const headerState = getHeaderState(currentCellHeaderState, TableCellHeaderStates.ROW);\n    if (insertAfterColumn < 0) {\n      $insertFirst(loopRow, $createTableCellNodeForInsertTableColumn(headerState));\n      continue;\n    }\n    const {\n      cell: currentCell,\n      startColumn: currentStartColumn,\n      startRow: currentStartRow\n    } = rowMap[insertAfterColumn];\n    if (currentStartColumn + currentCell.__colSpan - 1 <= insertAfterColumn) {\n      let insertAfterCell = currentCell;\n      let insertAfterCellRowStart = currentStartRow;\n      let prevCellIndex = insertAfterColumn;\n      while (insertAfterCellRowStart !== i && insertAfterCell.__rowSpan > 1) {\n        prevCellIndex -= currentCell.__colSpan;\n        if (prevCellIndex >= 0) {\n          const {\n            cell: cell_,\n            startRow: startRow_\n          } = rowMap[prevCellIndex];\n          insertAfterCell = cell_;\n          insertAfterCellRowStart = startRow_;\n        } else {\n          loopRow.append($createTableCellNodeForInsertTableColumn(headerState));\n          continue rowLoop;\n        }\n      }\n      insertAfterCell.insertAfter($createTableCellNodeForInsertTableColumn(headerState));\n    } else {\n      currentCell.setColSpan(currentCell.__colSpan + 1);\n    }\n  }\n  if (firstInsertedCell !== null && shouldSetSelection) {\n    $moveSelectionToCell(firstInsertedCell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    const columnIndex = insertAfterColumn < 0 ? 0 : insertAfterColumn;\n    const newWidth = newColWidths[columnIndex];\n    newColWidths.splice(columnIndex, 0, newWidth);\n    grid.setColWidths(newColWidths);\n  }\n  return firstInsertedCell;\n}\n\n/**\n * @deprecated This function does not support merged cells. Use {@link $deleteTableColumnAtSelection} instead.\n */\nfunction $deleteTableColumn(tableNode, targetIndex) {\n  const tableRows = tableNode.getChildren();\n  for (let i = 0; i < tableRows.length; i++) {\n    const currentTableRowNode = tableRows[i];\n    if ($isTableRowNode(currentTableRowNode)) {\n      const tableRowChildren = currentTableRowNode.getChildren();\n      if (targetIndex >= tableRowChildren.length || targetIndex < 0) {\n        throw new Error('Table column target index out of range');\n      }\n      tableRowChildren[targetIndex].remove();\n    }\n  }\n  return tableNode;\n}\nfunction $deleteTableRowAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const [anchor, focus] = selection.isBackward() ? [selection.focus.getNode(), selection.anchor.getNode()] : [selection.anchor.getNode(), selection.focus.getNode()];\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startRow: anchorStartRow\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow\n  } = focusCellMap;\n  const focusEndRow = focusStartRow + focusCell.__rowSpan - 1;\n  if (gridMap.length === focusEndRow - anchorStartRow + 1) {\n    // Empty grid\n    grid.remove();\n    return;\n  }\n  const columnCount = gridMap[0].length;\n  const nextRow = gridMap[focusEndRow + 1];\n  const nextRowNode = grid.getChildAtIndex(focusEndRow + 1);\n  for (let row = focusEndRow; row >= anchorStartRow; row--) {\n    for (let column = columnCount - 1; column >= 0; column--) {\n      const {\n        cell,\n        startRow: cellStartRow,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn !== column) {\n        // Don't repeat work for the same Cell\n        continue;\n      }\n      // Rows overflowing top or bottom have to be trimmed\n      if (cellStartRow < anchorStartRow || cellStartRow + cell.__rowSpan - 1 > focusEndRow) {\n        const intersectionStart = Math.max(cellStartRow, anchorStartRow);\n        const intersectionEnd = Math.min(cell.__rowSpan + cellStartRow - 1, focusEndRow);\n        const overflowRowsCount = intersectionStart <= intersectionEnd ? intersectionEnd - intersectionStart + 1 : 0;\n        cell.setRowSpan(cell.__rowSpan - overflowRowsCount);\n      }\n      // Rows overflowing bottom have to be moved to the next row\n      if (cellStartRow >= anchorStartRow && cellStartRow + cell.__rowSpan - 1 > focusEndRow &&\n      // Handle overflow only once\n      row === focusEndRow) {\n        if (!(nextRowNode !== null)) {\n          formatDevErrorMessage(`Expected nextRowNode not to be null`);\n        }\n        let insertAfterCell = null;\n        for (let columnIndex = 0; columnIndex < column; columnIndex++) {\n          const currentCellMap = nextRow[columnIndex];\n          const currentCell = currentCellMap.cell;\n          // Checking the cell having startRow as same as nextRow\n          if (currentCellMap.startRow === row + 1) {\n            insertAfterCell = currentCell;\n          }\n          if (currentCell.__colSpan > 1) {\n            columnIndex += currentCell.__colSpan - 1;\n          }\n        }\n        if (insertAfterCell === null) {\n          $insertFirst(nextRowNode, cell);\n        } else {\n          insertAfterCell.insertAfter(cell);\n        }\n      }\n    }\n    const rowNode = grid.getChildAtIndex(row);\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableNode childAtIndex(${String(row)}) to be RowNode`);\n    }\n    rowNode.remove();\n  }\n  if (nextRow !== undefined) {\n    const {\n      cell\n    } = nextRow[0];\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = gridMap[anchorStartRow - 1];\n    const {\n      cell\n    } = previousRow[0];\n    $moveSelectionToCell(cell);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableRowAtSelection}\n */\nconst $deleteTableRow__EXPERIMENTAL = $deleteTableRowAtSelection;\nfunction $deleteTableColumnAtSelection() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const focus = selection.focus.getNode();\n  const [anchorCell,, grid] = $getNodeTriplet(anchor);\n  const [focusCell] = $getNodeTriplet(focus);\n  const [gridMap, anchorCellMap, focusCellMap] = $computeTableMap(grid, anchorCell, focusCell);\n  const {\n    startColumn: anchorStartColumn\n  } = anchorCellMap;\n  const {\n    startRow: focusStartRow,\n    startColumn: focusStartColumn\n  } = focusCellMap;\n  const startColumn = Math.min(anchorStartColumn, focusStartColumn);\n  const endColumn = Math.max(anchorStartColumn + anchorCell.__colSpan - 1, focusStartColumn + focusCell.__colSpan - 1);\n  const selectedColumnCount = endColumn - startColumn + 1;\n  const columnCount = gridMap[0].length;\n  if (columnCount === endColumn - startColumn + 1) {\n    // Empty grid\n    grid.selectPrevious();\n    grid.remove();\n    return;\n  }\n  const rowCount = gridMap.length;\n  for (let row = 0; row < rowCount; row++) {\n    for (let column = startColumn; column <= endColumn; column++) {\n      const {\n        cell,\n        startColumn: cellStartColumn\n      } = gridMap[row][column];\n      if (cellStartColumn < startColumn) {\n        if (column === startColumn) {\n          const overflowLeft = startColumn - cellStartColumn;\n          // Overflowing left\n          cell.setColSpan(cell.__colSpan -\n          // Possible overflow right too\n          Math.min(selectedColumnCount, cell.__colSpan - overflowLeft));\n        }\n      } else if (cellStartColumn + cell.__colSpan - 1 > endColumn) {\n        if (column === endColumn) {\n          // Overflowing right\n          const inSelectedArea = endColumn - cellStartColumn + 1;\n          cell.setColSpan(cell.__colSpan - inSelectedArea);\n        }\n      } else {\n        cell.remove();\n      }\n    }\n  }\n  const focusRowMap = gridMap[focusStartRow];\n  const nextColumn = anchorStartColumn > focusStartColumn ? focusRowMap[anchorStartColumn + anchorCell.__colSpan] : focusRowMap[focusStartColumn + focusCell.__colSpan];\n  if (nextColumn !== undefined) {\n    const {\n      cell\n    } = nextColumn;\n    $moveSelectionToCell(cell);\n  } else {\n    const previousRow = focusStartColumn < anchorStartColumn ? focusRowMap[focusStartColumn - 1] : focusRowMap[anchorStartColumn - 1];\n    const {\n      cell\n    } = previousRow;\n    $moveSelectionToCell(cell);\n  }\n  const colWidths = grid.getColWidths();\n  if (colWidths) {\n    const newColWidths = [...colWidths];\n    newColWidths.splice(startColumn, selectedColumnCount);\n    grid.setColWidths(newColWidths);\n  }\n}\n\n/**\n * @deprecated renamed to {@link $deleteTableColumnAtSelection}\n */\nconst $deleteTableColumn__EXPERIMENTAL = $deleteTableColumnAtSelection;\nfunction $moveSelectionToCell(cell) {\n  const firstDescendant = cell.getFirstDescendant();\n  if (firstDescendant == null) {\n    cell.selectStart();\n  } else {\n    firstDescendant.getParentOrThrow().selectStart();\n  }\n}\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\nfunction $mergeCells(cellNodes) {\n  if (cellNodes.length === 0) {\n    return null;\n  }\n\n  // Find the table node\n  const tableNode = $getTableNodeFromLexicalNodeOrThrow(cellNodes[0]);\n  const [gridMap] = $computeTableMapSkipCellCheck(tableNode, null, null);\n\n  // Find the boundaries of the selection including merged cells\n  let minRow = Infinity;\n  let maxRow = -Infinity;\n  let minCol = Infinity;\n  let maxCol = -Infinity;\n\n  // First pass: find the actual boundaries considering merged cells\n  const processedCells = new Set();\n  for (const row of gridMap) {\n    for (const mapCell of row) {\n      if (!mapCell || !mapCell.cell) {\n        continue;\n      }\n      const cellKey = mapCell.cell.getKey();\n      if (processedCells.has(cellKey)) {\n        continue;\n      }\n      if (cellNodes.some(cell => cell.is(mapCell.cell))) {\n        processedCells.add(cellKey);\n        // Get the actual position of this cell in the grid\n        const cellStartRow = mapCell.startRow;\n        const cellStartCol = mapCell.startColumn;\n        const cellRowSpan = mapCell.cell.__rowSpan || 1;\n        const cellColSpan = mapCell.cell.__colSpan || 1;\n\n        // Update boundaries considering the cell's actual position and span\n        minRow = Math.min(minRow, cellStartRow);\n        maxRow = Math.max(maxRow, cellStartRow + cellRowSpan - 1);\n        minCol = Math.min(minCol, cellStartCol);\n        maxCol = Math.max(maxCol, cellStartCol + cellColSpan - 1);\n      }\n    }\n  }\n\n  // Validate boundaries\n  if (minRow === Infinity || minCol === Infinity) {\n    return null;\n  }\n\n  // The total span of the merged cell\n  const totalRowSpan = maxRow - minRow + 1;\n  const totalColSpan = maxCol - minCol + 1;\n\n  // Use the top-left cell as the target cell\n  const targetCellMap = gridMap[minRow][minCol];\n  if (!targetCellMap.cell) {\n    return null;\n  }\n  const targetCell = targetCellMap.cell;\n\n  // Set the spans for the target cell\n  targetCell.setColSpan(totalColSpan);\n  targetCell.setRowSpan(totalRowSpan);\n\n  // Move content from other cells to the target cell\n  const seenCells = new Set([targetCell.getKey()]);\n\n  // Second pass: merge content and remove other cells\n  for (let row = minRow; row <= maxRow; row++) {\n    for (let col = minCol; col <= maxCol; col++) {\n      const mapCell = gridMap[row][col];\n      if (!mapCell.cell) {\n        continue;\n      }\n      const currentCell = mapCell.cell;\n      const key = currentCell.getKey();\n      if (!seenCells.has(key)) {\n        seenCells.add(key);\n        const isEmpty = $cellContainsEmptyParagraph(currentCell);\n        if (!isEmpty) {\n          targetCell.append(...currentCell.getChildren());\n        }\n        currentCell.remove();\n      }\n    }\n  }\n\n  // Ensure target cell has content\n  if (targetCell.getChildrenSize() === 0) {\n    targetCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n  return targetCell;\n}\nfunction $cellContainsEmptyParagraph(cell) {\n  if (cell.getChildrenSize() !== 1) {\n    return false;\n  }\n  const firstChild = cell.getFirstChildOrThrow();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(firstChild) || !firstChild.isEmpty()) {\n    return false;\n  }\n  return true;\n}\nfunction $unmergeCell() {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection))) {\n    formatDevErrorMessage(`Expected a RangeSelection or TableSelection`);\n  }\n  const anchor = selection.anchor.getNode();\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor, $isTableCellNode);\n  if (!$isTableCellNode(cellNode)) {\n    formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n  }\n  return $unmergeCellNode(cellNode);\n}\nfunction $unmergeCellNode(cellNode) {\n  const [cell, row, grid] = $getNodeTriplet(cellNode);\n  const colSpan = cell.__colSpan;\n  const rowSpan = cell.__rowSpan;\n  if (colSpan === 1 && rowSpan === 1) {\n    return;\n  }\n  const [map, cellMap] = $computeTableMap(grid, cell, cell);\n  const {\n    startColumn,\n    startRow\n  } = cellMap;\n  // Create a heuristic for what the style of the unmerged cells should be\n  // based on whether every row or column already had that state before the\n  // unmerge.\n  const baseColStyle = cell.__headerState & TableCellHeaderStates.COLUMN;\n  const colStyles = Array.from({\n    length: colSpan\n  }, (_v, i) => {\n    let colStyle = baseColStyle;\n    for (let rowIdx = 0; colStyle !== 0 && rowIdx < map.length; rowIdx++) {\n      colStyle &= map[rowIdx][i + startColumn].cell.__headerState;\n    }\n    return colStyle;\n  });\n  const baseRowStyle = cell.__headerState & TableCellHeaderStates.ROW;\n  const rowStyles = Array.from({\n    length: rowSpan\n  }, (_v, i) => {\n    let rowStyle = baseRowStyle;\n    for (let colIdx = 0; rowStyle !== 0 && colIdx < map[0].length; colIdx++) {\n      rowStyle &= map[i + startRow][colIdx].cell.__headerState;\n    }\n    return rowStyle;\n  });\n  if (colSpan > 1) {\n    for (let i = 1; i < colSpan; i++) {\n      cell.insertAfter($createTableCellNode(colStyles[i] | rowStyles[0]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n    }\n    cell.setColSpan(1);\n  }\n  if (rowSpan > 1) {\n    let currentRowNode;\n    for (let i = 1; i < rowSpan; i++) {\n      const currentRow = startRow + i;\n      const currentRowMap = map[currentRow];\n      currentRowNode = (currentRowNode || row).getNextSibling();\n      if (!$isTableRowNode(currentRowNode)) {\n        formatDevErrorMessage(`Expected row next sibling to be a row`);\n      }\n      let insertAfterCell = null;\n      for (let column = 0; column < startColumn; column++) {\n        const currentCellMap = currentRowMap[column];\n        const currentCell = currentCellMap.cell;\n        if (currentCellMap.startRow === currentRow) {\n          insertAfterCell = currentCell;\n        }\n        if (currentCell.__colSpan > 1) {\n          column += currentCell.__colSpan - 1;\n        }\n      }\n      if (insertAfterCell === null) {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          $insertFirst(currentRowNode, $createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      } else {\n        for (let j = colSpan - 1; j >= 0; j--) {\n          insertAfterCell.insertAfter($createTableCellNode(colStyles[j] | rowStyles[i]).append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)()));\n        }\n      }\n    }\n    cell.setRowSpan(1);\n  }\n}\nfunction $computeTableMap(tableNode, cellA, cellB) {\n  const [tableMap, cellAValue, cellBValue] = $computeTableMapSkipCellCheck(tableNode, cellA, cellB);\n  if (!(cellAValue !== null)) {\n    formatDevErrorMessage(`Anchor not found in Table`);\n  }\n  if (!(cellBValue !== null)) {\n    formatDevErrorMessage(`Focus not found in Table`);\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $computeTableMapSkipCellCheck(tableNode, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n  function getMapRow(i) {\n    let row = tableMap[i];\n    if (row === undefined) {\n      tableMap[i] = row = [];\n    }\n    return row;\n  }\n  const gridChildren = tableNode.getChildren();\n  for (let rowIdx = 0; rowIdx < gridChildren.length; rowIdx++) {\n    const row = gridChildren[rowIdx];\n    if (!$isTableRowNode(row)) {\n      formatDevErrorMessage(`Expected TableNode children to be TableRowNode`);\n    }\n    const startMapRow = getMapRow(rowIdx);\n    for (let cell = row.getFirstChild(), colIdx = 0; cell != null; cell = cell.getNextSibling()) {\n      if (!$isTableCellNode(cell)) {\n        formatDevErrorMessage(`Expected TableRowNode children to be TableCellNode`);\n      } // Skip past any columns that were merged from a higher row\n      while (startMapRow[colIdx] !== undefined) {\n        colIdx++;\n      }\n      const value = {\n        cell,\n        startColumn: colIdx,\n        startRow: rowIdx\n      };\n      const {\n        __rowSpan: rowSpan,\n        __colSpan: colSpan\n      } = cell;\n      for (let j = 0; j < rowSpan; j++) {\n        if (rowIdx + j >= gridChildren.length) {\n          // The table is non-rectangular with a rowSpan\n          // below the last <tr> in the table.\n          // We should probably handle this with a node transform\n          // to ensure that tables are always rectangular but this\n          // will avoid crashes such as #6584\n          // Note that there are probably still latent bugs\n          // regarding colSpan or general cell count mismatches.\n          break;\n        }\n        const mapRow = getMapRow(rowIdx + j);\n        for (let i = 0; i < colSpan; i++) {\n          mapRow[colIdx + i] = value;\n        }\n      }\n      if (cellA !== null && cellAValue === null && cellA.is(cell)) {\n        cellAValue = value;\n      }\n      if (cellB !== null && cellBValue === null && cellB.is(cell)) {\n        cellBValue = value;\n      }\n    }\n  }\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction $getNodeTriplet(source) {\n  let cell;\n  if (source instanceof TableCellNode) {\n    cell = source;\n  } else if ('__type' in source) {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source, $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  } else {\n    const cell_ = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(source.getNode(), $isTableCellNode);\n    if (!$isTableCellNode(cell_)) {\n      formatDevErrorMessage(`Expected to find a parent TableCellNode`);\n    }\n    cell = cell_;\n  }\n  const row = cell.getParent();\n  if (!$isTableRowNode(row)) {\n    formatDevErrorMessage(`Expected TableCellNode to have a parent TableRowNode`);\n  }\n  const grid = row.getParent();\n  if (!$isTableNode(grid)) {\n    formatDevErrorMessage(`Expected TableRowNode to have a parent TableNode`);\n  }\n  return [cell, row, grid];\n}\nfunction $computeTableCellRectSpans(map, boundary) {\n  const {\n    minColumn,\n    maxColumn,\n    minRow,\n    maxRow\n  } = boundary;\n  let topSpan = 1;\n  let leftSpan = 1;\n  let rightSpan = 1;\n  let bottomSpan = 1;\n  const topRow = map[minRow];\n  const bottomRow = map[maxRow];\n  for (let col = minColumn; col <= maxColumn; col++) {\n    topSpan = Math.max(topSpan, topRow[col].cell.__rowSpan);\n    bottomSpan = Math.max(bottomSpan, bottomRow[col].cell.__rowSpan);\n  }\n  for (let row = minRow; row <= maxRow; row++) {\n    leftSpan = Math.max(leftSpan, map[row][minColumn].cell.__colSpan);\n    rightSpan = Math.max(rightSpan, map[row][maxColumn].cell.__colSpan);\n  }\n  return {\n    bottomSpan,\n    leftSpan,\n    rightSpan,\n    topSpan\n  };\n}\nfunction $computeTableCellRectBoundary(map, cellAMap, cellBMap) {\n  // Initial boundaries based on the anchor and focus cells\n  let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n  let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n  let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n  let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n\n  // Keep expanding until we have a complete rectangle\n  let hasChanges;\n  do {\n    hasChanges = false;\n\n    // Check all cells in the table\n    for (let row = 0; row < map.length; row++) {\n      for (let col = 0; col < map[0].length; col++) {\n        const cell = map[row][col];\n        if (!cell) {\n          continue;\n        }\n        const cellEndCol = cell.startColumn + cell.cell.__colSpan - 1;\n        const cellEndRow = cell.startRow + cell.cell.__rowSpan - 1;\n\n        // Check if this cell intersects with our current selection rectangle\n        const intersectsHorizontally = cell.startColumn <= maxColumn && cellEndCol >= minColumn;\n        const intersectsVertically = cell.startRow <= maxRow && cellEndRow >= minRow;\n\n        // If the cell intersects either horizontally or vertically\n        if (intersectsHorizontally && intersectsVertically) {\n          // Expand boundaries to include this cell completely\n          const newMinColumn = Math.min(minColumn, cell.startColumn);\n          const newMaxColumn = Math.max(maxColumn, cellEndCol);\n          const newMinRow = Math.min(minRow, cell.startRow);\n          const newMaxRow = Math.max(maxRow, cellEndRow);\n\n          // Check if boundaries changed\n          if (newMinColumn !== minColumn || newMaxColumn !== maxColumn || newMinRow !== minRow || newMaxRow !== maxRow) {\n            minColumn = newMinColumn;\n            maxColumn = newMaxColumn;\n            minRow = newMinRow;\n            maxRow = newMaxRow;\n            hasChanges = true;\n          }\n        }\n      }\n    }\n  } while (hasChanges);\n  return {\n    maxColumn,\n    maxRow,\n    minColumn,\n    minRow\n  };\n}\nfunction $getTableCellNodeRect(tableCellNode) {\n  const [cellNode,, gridNode] = $getNodeTriplet(tableCellNode);\n  const rows = gridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length;\n\n  // Create a matrix of the same size as the table to track the position of each cell\n  const cellMatrix = new Array(rowCount);\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1;\n\n      // Put the cell into the corresponding position in the matrix\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      }\n\n      // Return to the original index, row span and column span of the cell.\n      if (cellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n      columnIndex += colSpan;\n    }\n  }\n  return null;\n}\n\nfunction $getCellNodes(tableSelection) {\n  const [[anchorNode, anchorCell, anchorRow, anchorTable], [focusNode, focusCell, focusRow, focusTable]] = ['anchor', 'focus'].map(k => {\n    const node = tableSelection[k].getNode();\n    const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n    if (!$isTableCellNode(cellNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} to be (or a child of) TableCellNode, got key ${node.getKey()} of type ${node.getType()}`);\n    }\n    const rowNode = cellNode.getParent();\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} cell parent to be a TableRowNode`);\n    }\n    const tableNode = rowNode.getParent();\n    if (!$isTableNode(tableNode)) {\n      formatDevErrorMessage(`Expected TableSelection ${k} row parent to be a TableNode`);\n    }\n    return [node, cellNode, rowNode, tableNode];\n  });\n  // TODO: nested tables may violate this\n  if (!anchorTable.is(focusTable)) {\n    formatDevErrorMessage(`Expected TableSelection anchor and focus to be in the same table`);\n  }\n  return {\n    anchorCell,\n    anchorNode,\n    anchorRow,\n    anchorTable,\n    focusCell,\n    focusNode,\n    focusRow,\n    focusTable\n  };\n}\nclass TableSelection {\n  constructor(tableKey, anchor, focus) {\n    this.anchor = anchor;\n    this.focus = focus;\n    anchor._selection = this;\n    focus._selection = this;\n    this._cachedNodes = null;\n    this.dirty = false;\n    this.tableKey = tableKey;\n  }\n  getStartEndPoints() {\n    return [this.anchor, this.focus];\n  }\n\n  /**\n   * {@link $createTableSelection} unfortunately makes it very easy to create\n   * nonsense selections, so we have a method to see if the selection probably\n   * makes sense.\n   *\n   * @returns true if the TableSelection is (probably) valid\n   */\n  isValid() {\n    return this.tableKey !== 'root' && this.anchor.key !== 'root' && this.anchor.type === 'element' && this.focus.key !== 'root' && this.focus.type === 'element';\n  }\n\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  getCachedNodes() {\n    return this._cachedNodes;\n  }\n  setCachedNodes(nodes) {\n    this._cachedNodes = nodes;\n  }\n  is(selection) {\n    return $isTableSelection(selection) && this.tableKey === selection.tableKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n  set(tableKey, anchorCellKey, focusCellKey) {\n    // note: closure compiler's acorn does not support ||=\n    this.dirty = this.dirty || tableKey !== this.tableKey || anchorCellKey !== this.anchor.key || focusCellKey !== this.focus.key;\n    this.tableKey = tableKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n  clone() {\n    return new TableSelection(this.tableKey, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.anchor.key, this.anchor.offset, this.anchor.type), (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)(this.focus.key, this.focus.offset, this.focus.type));\n  }\n  isCollapsed() {\n    return false;\n  }\n  extract() {\n    return this.getNodes();\n  }\n  insertRawText(text) {\n    // Do nothing?\n  }\n  insertText() {\n    // Do nothing?\n  }\n\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection.\n   * This will be true if any paragraph in table cells has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n  hasFormat(type) {\n    let format = 0;\n    const cellNodes = this.getNodes().filter($isTableCellNode);\n    cellNodes.forEach(cellNode => {\n      const paragraph = cellNode.getFirstChild();\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph)) {\n        format |= paragraph.getTextFormat();\n      }\n    });\n    const formatFlag = lexical__WEBPACK_IMPORTED_MODULE_0__.TEXT_TYPE_TO_FORMAT[type];\n    return (format & formatFlag) !== 0;\n  }\n  insertNodes(nodes) {\n    const focusNode = this.focus.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(focusNode)) {\n      formatDevErrorMessage(`Expected TableSelection focus to be an ElementNode`);\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(focusNode.select(0, focusNode.getChildrenSize()));\n    selection.insertNodes(nodes);\n  }\n\n  // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n  getShape() {\n    const {\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const anchorCellNodeRect = $getTableCellNodeRect(anchorCell);\n    if (!(anchorCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find AnchorNode`);\n    }\n    const focusCellNodeRect = $getTableCellNodeRect(focusCell);\n    if (!(focusCellNodeRect !== null)) {\n      formatDevErrorMessage(`getCellRect: expected to find focusCellNode`);\n    }\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex + anchorCellNodeRect.colSpan - 1, focusCellNodeRect.columnIndex + focusCellNodeRect.colSpan - 1);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex + anchorCellNodeRect.rowSpan - 1, focusCellNodeRect.rowIndex + focusCellNodeRect.rowSpan - 1);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n  getNodes() {\n    if (!this.isValid()) {\n      return [];\n    }\n    const cachedNodes = this._cachedNodes;\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n    const {\n      anchorTable: tableNode,\n      anchorCell,\n      focusCell\n    } = $getCellNodes(this);\n    const focusCellGrid = focusCell.getParents()[1];\n    if (focusCellGrid !== tableNode) {\n      if (!tableNode.isParentOf(focusCell)) {\n        // focus is on higher Grid level than anchor\n        const gridParent = tableNode.getParent();\n        if (!(gridParent != null)) {\n          formatDevErrorMessage(`Expected gridParent to have a parent`);\n        }\n        this.set(this.tableKey, gridParent.getKey(), focusCell.getKey());\n      } else {\n        // anchor is on higher Grid level than focus\n        const focusCellParent = focusCellGrid.getParent();\n        if (!(focusCellParent != null)) {\n          formatDevErrorMessage(`Expected focusCellParent to have a parent`);\n        }\n        this.set(this.tableKey, focusCell.getKey(), focusCellParent.getKey());\n      }\n      return this.getNodes();\n    }\n\n    // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing TableSelection and moving the logic to the plugin would make\n    // this possible.\n    const [map, cellAMap, cellBMap] = $computeTableMap(tableNode, anchorCell, focusCell);\n    const {\n      minColumn,\n      maxColumn,\n      minRow,\n      maxRow\n    } = $computeTableCellRectBoundary(map, cellAMap, cellBMap);\n\n    // We use a Map here because merged cells in the grid would otherwise\n    // show up multiple times in the nodes array\n    const nodeMap = new Map([[tableNode.getKey(), tableNode]]);\n    let lastRow = null;\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n        if (!$isTableRowNode(currentRow)) {\n          formatDevErrorMessage(`Expected TableCellNode parent to be a TableRowNode`);\n        }\n        if (currentRow !== lastRow) {\n          nodeMap.set(currentRow.getKey(), currentRow);\n          lastRow = currentRow;\n        }\n        if (!nodeMap.has(cell.getKey())) {\n          $visitRecursively(cell, childNode => {\n            nodeMap.set(childNode.getKey(), childNode);\n          });\n        }\n      }\n    }\n    const nodes = Array.from(nodeMap.values());\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isCurrentlyReadOnlyMode)()) {\n      this._cachedNodes = nodes;\n    }\n    return nodes;\n  }\n  getTextContent() {\n    const nodes = this.getNodes().filter(node => $isTableCellNode(node));\n    let textContent = '';\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      const row = node.__parent;\n      const nextRow = (nodes[i + 1] || {}).__parent;\n      textContent += node.getTextContent() + (nextRow !== row ? '\\n' : '\\t');\n    }\n    return textContent;\n  }\n}\nfunction $isTableSelection(x) {\n  return x instanceof TableSelection;\n}\nfunction $createTableSelection() {\n  // TODO this is a suboptimal design, it doesn't make sense to have\n  // a table selection that isn't associated with a table. This\n  // constructor should have required arguments and in true we\n  // should check that they point to a table and are element points to\n  // cell nodes of that table.\n  const anchor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  const focus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createPoint)('root', 0, 'element');\n  return new TableSelection('root', anchor, focus);\n}\nfunction $createTableSelectionFrom(tableNode, anchorCell, focusCell) {\n  const tableNodeKey = tableNode.getKey();\n  const anchorCellKey = anchorCell.getKey();\n  const focusCellKey = focusCell.getKey();\n  {\n    if (!tableNode.isAttached()) {\n      formatDevErrorMessage(`$createTableSelectionFrom: tableNode ${tableNodeKey} is not attached`);\n    }\n    if (!tableNode.is($findTableNode(anchorCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: anchorCell ${anchorCellKey} is not in table ${tableNodeKey}`);\n    }\n    if (!tableNode.is($findTableNode(focusCell))) {\n      formatDevErrorMessage(`$createTableSelectionFrom: focusCell ${focusCellKey} is not in table ${tableNodeKey}`);\n    } // TODO: Check for rectangular grid\n  }\n  const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  const nextSelection = $isTableSelection(prevSelection) ? prevSelection.clone() : $createTableSelection();\n  nextSelection.set(tableNode.getKey(), anchorCell.getKey(), focusCell.getKey());\n  return nextSelection;\n}\n\n/**\n * Depth first visitor\n * @param node The starting node\n * @param $visit The function to call for each node. If the function returns false, then children of this node will not be explored\n */\nfunction $visitRecursively(node, $visit) {\n  const stack = [[node]];\n  for (let currentArray = stack.at(-1); currentArray !== undefined && stack.length > 0; currentArray = stack.at(-1)) {\n    const currentNode = currentArray.pop();\n    if (currentNode === undefined) {\n      stack.pop();\n    } else if ($visit(currentNode) !== false && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      stack.push(currentNode.getChildren());\n    }\n  }\n}\n\nfunction $getTableAndElementByKey(tableNodeKey, editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(tableNodeKey);\n  if (!$isTableNode(tableNode)) {\n    formatDevErrorMessage(`TableObserver: Expected tableNodeKey ${tableNodeKey} to be a TableNode`);\n  }\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNodeKey));\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`TableObserver: Expected to find TableElement in DOM for key ${tableNodeKey}`);\n  }\n  return {\n    tableElement,\n    tableNode\n  };\n}\nclass TableObserver {\n  constructor(editor, tableNodeKey) {\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.listenersToRemove = new Set();\n    this.tableNodeKey = tableNodeKey;\n    this.editor = editor;\n    this.table = {\n      columns: 0,\n      domRows: [],\n      rows: 0\n    };\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.isSelecting = false;\n    this.pointerType = null;\n    this.shouldCheckSelection = false;\n    this.abortController = new AbortController();\n    this.listenerOptions = {\n      signal: this.abortController.signal\n    };\n    this.nextFocus = null;\n    this.trackTable();\n  }\n  getTable() {\n    return this.table;\n  }\n  removeListeners() {\n    this.abortController.abort('removeListeners');\n    Array.from(this.listenersToRemove).forEach(removeListener => removeListener());\n    this.listenersToRemove.clear();\n  }\n  $lookup() {\n    return $getTableAndElementByKey(this.tableNodeKey, this.editor);\n  }\n  trackTable() {\n    const observer = new MutationObserver(records => {\n      this.editor.getEditorState().read(() => {\n        let gridNeedsRedraw = false;\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const target = record.target;\n          const nodeName = target.nodeName;\n          if (nodeName === 'TABLE' || nodeName === 'TBODY' || nodeName === 'THEAD' || nodeName === 'TR') {\n            gridNeedsRedraw = true;\n            break;\n          }\n        }\n        if (!gridNeedsRedraw) {\n          return;\n        }\n        const {\n          tableNode,\n          tableElement\n        } = this.$lookup();\n        this.table = getTable(tableNode, tableElement);\n      }, {\n        editor: this.editor\n      });\n    });\n    this.editor.getEditorState().read(() => {\n      const {\n        tableNode,\n        tableElement\n      } = this.$lookup();\n      this.table = getTable(tableNode, tableElement);\n      observer.observe(tableElement, {\n        attributes: true,\n        childList: true,\n        subtree: true\n      });\n    }, {\n      editor: this.editor\n    });\n  }\n  $clearHighlight() {\n    const editor = this.editor;\n    this.isHighlightingCells = false;\n    this.anchorX = -1;\n    this.anchorY = -1;\n    this.focusX = -1;\n    this.focusY = -1;\n    this.tableSelection = null;\n    this.anchorCellNodeKey = null;\n    this.focusCellNodeKey = null;\n    this.anchorCell = null;\n    this.focusCell = null;\n    this.hasHijackedSelectionStyles = false;\n    this.$enableHighlightStyle();\n    const {\n      tableNode,\n      tableElement\n    } = this.$lookup();\n    const grid = getTable(tableNode, tableElement);\n    $updateDOMForSelection(editor, grid, null);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() !== null) {\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n      editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n    }\n  }\n  $enableHighlightStyle() {\n    const editor = this.editor;\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(tableElement, editor._config.theme.tableSelection);\n    tableElement.classList.remove('disable-selection');\n    this.hasHijackedSelectionStyles = false;\n  }\n  $disableHighlightStyle() {\n    const {\n      tableElement\n    } = this.$lookup();\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, this.editor._config.theme.tableSelection);\n    this.hasHijackedSelectionStyles = true;\n  }\n  $updateTableTableSelection(selection) {\n    if (selection !== null) {\n      if (!(selection.tableKey === this.tableNodeKey)) {\n        formatDevErrorMessage(`TableObserver.$updateTableTableSelection: selection.tableKey !== this.tableNodeKey ('${selection.tableKey}' !== '${this.tableNodeKey}')`);\n      }\n      const editor = this.editor;\n      this.tableSelection = selection;\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n      this.updateDOMSelection();\n      $updateDOMForSelection(editor, this.table, this.tableSelection);\n    } else {\n      this.$clearHighlight();\n    }\n  }\n\n  /**\n   * @internal\n   * Firefox has a strange behavior where pressing the down arrow key from\n   * above the table will move the caret after the table and then lexical\n   * will select the last cell instead of the first.\n   * We do still want to let the browser handle caret movement but we will\n   * use this property to \"tag\" the update so that we can recheck the\n   * selection after the event is processed.\n   */\n  setShouldCheckSelection() {\n    this.shouldCheckSelection = true;\n  }\n  /**\n   * @internal\n   */\n  getAndClearShouldCheckSelection() {\n    if (this.shouldCheckSelection) {\n      this.shouldCheckSelection = false;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @internal\n   * When handling mousemove events we track what the focus cell should be, but\n   * the DOM selection may end up somewhere else entirely. We don't have an elegant\n   * way to handle this after the DOM selection has been resolved in a\n   * SELECTION_CHANGE_COMMAND callback.\n   */\n  setNextFocus(nextFocus) {\n    this.nextFocus = nextFocus;\n  }\n\n  /** @internal */\n  getAndClearNextFocus() {\n    const {\n      nextFocus\n    } = this;\n    if (nextFocus !== null) {\n      this.nextFocus = null;\n    }\n    return nextFocus;\n  }\n\n  /** @internal */\n  updateDOMSelection() {\n    if (this.anchorCell !== null && this.focusCell !== null) {\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(this.editor._window);\n      // We are not using a native selection for tables, and if we\n      // set one then the reconciler will undo it.\n      // TODO - it would make sense to have one so that native\n      //        copy/paste worked. Right now we have to emulate with\n      //        keyboard events but it won't fire if triggered from the menu\n      if (domSelection && domSelection.rangeCount > 0) {\n        domSelection.removeAllRanges();\n      }\n    }\n  }\n  $setFocusCellForSelection(cell, ignoreStart = false) {\n    const editor = this.editor;\n    const {\n      tableNode\n    } = this.$lookup();\n    const cellX = cell.x;\n    const cellY = cell.y;\n    this.focusCell = cell;\n    if (!this.isHighlightingCells && (this.anchorX !== cellX || this.anchorY !== cellY || ignoreStart)) {\n      this.isHighlightingCells = true;\n      this.$disableHighlightStyle();\n    } else if (cellX === this.focusX && cellY === this.focusY) {\n      return false;\n    }\n    this.focusX = cellX;\n    this.focusY = cellY;\n    if (this.isHighlightingCells) {\n      const focusTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n      if (this.tableSelection != null && this.anchorCellNodeKey != null && focusTableCellNode !== null) {\n        this.focusCellNodeKey = focusTableCellNode.getKey();\n        this.tableSelection = $createTableSelectionFrom(tableNode, this.$getAnchorTableCellOrThrow(), focusTableCellNode);\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(this.tableSelection);\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n        $updateDOMForSelection(editor, this.table, this.tableSelection);\n        return true;\n      }\n    }\n    return false;\n  }\n  $getAnchorTableCell() {\n    return this.anchorCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.anchorCellNodeKey) : null;\n  }\n  $getAnchorTableCellOrThrow() {\n    const anchorTableCell = this.$getAnchorTableCell();\n    if (!(anchorTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver anchorTableCell is null`);\n    }\n    return anchorTableCell;\n  }\n  $getFocusTableCell() {\n    return this.focusCellNodeKey ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.focusCellNodeKey) : null;\n  }\n  $getFocusTableCellOrThrow() {\n    const focusTableCell = this.$getFocusTableCell();\n    if (!(focusTableCell !== null)) {\n      formatDevErrorMessage(`TableObserver focusTableCell is null`);\n    }\n    return focusTableCell;\n  }\n  $setAnchorCellForSelection(cell) {\n    this.isHighlightingCells = false;\n    this.anchorCell = cell;\n    this.anchorX = cell.x;\n    this.anchorY = cell.y;\n    const {\n      tableNode\n    } = this.$lookup();\n    const anchorTableCellNode = $getNearestTableCellInTableFromDOMNode(tableNode, cell.elem);\n    if (anchorTableCellNode !== null) {\n      const anchorNodeKey = anchorTableCellNode.getKey();\n      this.tableSelection = this.tableSelection != null ? this.tableSelection.clone() : $createTableSelection();\n      this.anchorCellNodeKey = anchorNodeKey;\n    }\n  }\n  $formatCells(type) {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected Table selection`);\n    }\n    const formatSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelection)();\n    const anchor = formatSelection.anchor;\n    const focus = formatSelection.focus;\n    const cellNodes = selection.getNodes().filter($isTableCellNode);\n    if (!(cellNodes.length > 0)) {\n      formatDevErrorMessage(`No table cells present`);\n    }\n    const paragraph = cellNodes[0].getFirstChild();\n    const alignFormatWith = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(paragraph) ? paragraph.getFormatFlags(type, null) : null;\n    cellNodes.forEach(cellNode => {\n      anchor.set(cellNode.getKey(), 0, 'element');\n      focus.set(cellNode.getKey(), cellNode.getChildrenSize(), 'element');\n      formatSelection.formatText(type, alignFormatWith);\n    });\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(selection);\n    this.editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n  $clearText() {\n    const {\n      editor\n    } = this;\n    const tableNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNodeByKey)(this.tableNodeKey);\n    if (!$isTableNode(tableNode)) {\n      throw new Error('Expected TableNode.');\n    }\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection)) {\n      formatDevErrorMessage(`Expected TableSelection`);\n    }\n    const selectedNodes = selection.getNodes().filter($isTableCellNode);\n\n    // Check if the entire table is selected by verifying first and last cells\n    const firstRow = tableNode.getFirstChild();\n    const lastRow = tableNode.getLastChild();\n    const isEntireTableSelected = selectedNodes.length > 0 && firstRow !== null && lastRow !== null && $isTableRowNode(firstRow) && $isTableRowNode(lastRow) && selectedNodes[0] === firstRow.getFirstChild() && selectedNodes[selectedNodes.length - 1] === lastRow.getLastChild();\n    if (isEntireTableSelected) {\n      tableNode.selectPrevious();\n      const parent = tableNode.getParent();\n      // Delete entire table\n      tableNode.remove();\n      // Handle case when table was the only node\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootNode)(parent) && parent.isEmpty()) {\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, undefined);\n      }\n      return;\n    }\n    selectedNodes.forEach(cellNode => {\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(cellNode)) {\n        const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n        const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)();\n        paragraphNode.append(textNode);\n        cellNode.append(paragraphNode);\n        cellNode.getChildren().forEach(child => {\n          if (child !== paragraphNode) {\n            child.remove();\n          }\n        });\n      }\n    });\n    $updateDOMForSelection(editor, this.table, null);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(null);\n    editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nconst LEXICAL_ELEMENT_KEY = '__lexicalTableSelection';\nconst isPointerDownOnEvent = event => {\n  return (event.buttons & 1) === 1;\n};\nfunction isHTMLTableElement(el) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(el) && el.nodeName === 'TABLE';\n}\nfunction getTableElement(tableNode, dom) {\n  if (!dom) {\n    return dom;\n  }\n  const element = isHTMLTableElement(dom) ? dom : tableNode.getDOMSlot(dom).element;\n  if (!(element.nodeName === 'TABLE')) {\n    formatDevErrorMessage(`getTableElement: Expecting table in as DOM node for TableNode, not ${dom.nodeName}`);\n  }\n  return element;\n}\nfunction getEditorWindow(editor) {\n  return editor._window;\n}\nfunction $findParentTableCellNodeInTable(tableNode, node) {\n  for (let currentNode = node, lastTableCellNode = null; currentNode !== null; currentNode = currentNode.getParent()) {\n    if (tableNode.is(currentNode)) {\n      return lastTableCellNode;\n    } else if ($isTableCellNode(currentNode)) {\n      lastTableCellNode = currentNode;\n    }\n  }\n  return null;\n}\nconst ARROW_KEY_COMMANDS_WITH_DIRECTION = [[lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_DOWN_COMMAND, 'down'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_UP_COMMAND, 'up'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_LEFT_COMMAND, 'backward'], [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ARROW_RIGHT_COMMAND, 'forward']];\nconst DELETE_TEXT_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_WORD_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_CHARACTER_COMMAND];\nconst DELETE_KEY_COMMANDS = [lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_BACKSPACE_COMMAND, lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_DELETE_COMMAND];\nfunction applyTableHandlers(tableNode, element, editor, hasTabHandler) {\n  const rootElement = editor.getRootElement();\n  const editorWindow = getEditorWindow(editor);\n  if (!(rootElement !== null && editorWindow !== null)) {\n    formatDevErrorMessage(`applyTableHandlers: editor has no root element set`);\n  }\n  const tableObserver = new TableObserver(editor, tableNode.getKey());\n  const tableElement = getTableElement(tableNode, element);\n  attachTableObserverToTableElement(tableElement, tableObserver);\n  tableObserver.listenersToRemove.add(() => detachTableObserverFromTableElement(tableElement, tableObserver));\n  const createPointerHandlers = () => {\n    if (tableObserver.isSelecting) {\n      return;\n    }\n    const onPointerUp = () => {\n      tableObserver.isSelecting = false;\n      editorWindow.removeEventListener('pointerup', onPointerUp);\n      editorWindow.removeEventListener('pointermove', onPointerMove);\n    };\n    const onPointerMove = moveEvent => {\n      if (!isPointerDownOnEvent(moveEvent) && tableObserver.isSelecting) {\n        tableObserver.isSelecting = false;\n        editorWindow.removeEventListener('pointerup', onPointerUp);\n        editorWindow.removeEventListener('pointermove', onPointerMove);\n        return;\n      }\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(moveEvent.target)) {\n        return;\n      }\n      let focusCell = null;\n      // In firefox the moveEvent.target may be captured so we must always\n      // consult the coordinates #7245\n      const override = !(IS_FIREFOX || tableElement.contains(moveEvent.target));\n      if (override) {\n        focusCell = getDOMCellInTableFromTarget(tableElement, moveEvent.target);\n      } else {\n        for (const el of document.elementsFromPoint(moveEvent.clientX, moveEvent.clientY)) {\n          focusCell = getDOMCellInTableFromTarget(tableElement, el);\n          if (focusCell) {\n            break;\n          }\n        }\n      }\n      if (focusCell && (tableObserver.focusCell === null || focusCell.elem !== tableObserver.focusCell.elem)) {\n        tableObserver.setNextFocus({\n          focusCell,\n          override\n        });\n        editor.dispatchCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, undefined);\n      }\n    };\n    tableObserver.isSelecting = true;\n    editorWindow.addEventListener('pointerup', onPointerUp, tableObserver.listenerOptions);\n    editorWindow.addEventListener('pointermove', onPointerMove, tableObserver.listenerOptions);\n  };\n  const onPointerDown = event => {\n    tableObserver.pointerType = event.pointerType;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target) || !editorWindow) {\n      return;\n    }\n    const targetCell = getDOMCellFromTarget(event.target);\n    if (targetCell !== null) {\n      editor.update(() => {\n        const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n        // We can't trust Firefox to do the right thing with the selection and\n        // we don't have a proper state machine to do this \"correctly\" but\n        // if we go ahead and make the table selection now it will work\n        if (IS_FIREFOX && event.shiftKey && $isSelectionInTable(prevSelection, tableNode) && ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) || $isTableSelection(prevSelection))) {\n          const prevAnchorNode = prevSelection.anchor.getNode();\n          const prevAnchorCell = $findParentTableCellNodeInTable(tableNode, prevSelection.anchor.getNode());\n          if (prevAnchorCell) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCell));\n            tableObserver.$setFocusCellForSelection(targetCell);\n            stopEvent(event);\n          } else {\n            const newSelection = tableNode.isBefore(prevAnchorNode) ? tableNode.selectStart() : tableNode.selectEnd();\n            newSelection.anchor.set(prevSelection.anchor.key, prevSelection.anchor.offset, prevSelection.anchor.type);\n          }\n        } else {\n          // Only set anchor cell for selection if this is not a simple touch tap\n          // Touch taps should not initiate table selection mode\n          if (event.pointerType !== 'touch') {\n            tableObserver.$setAnchorCellForSelection(targetCell);\n          }\n        }\n      });\n    }\n    createPointerHandlers();\n  };\n  tableElement.addEventListener('pointerdown', onPointerDown, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('pointerdown', onPointerDown);\n  });\n  const onTripleClick = event => {\n    if (event.detail >= 3 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n      const targetCell = getDOMCellFromTarget(event.target);\n      if (targetCell !== null) {\n        event.preventDefault();\n      }\n    }\n  };\n  tableElement.addEventListener('mousedown', onTripleClick, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    tableElement.removeEventListener('mousedown', onTripleClick);\n  });\n\n  // Clear selection when clicking outside of dom.\n  const pointerDownCallback = event => {\n    const target = event.target;\n    if (event.button !== 0 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(target)) {\n      return;\n    }\n    editor.update(() => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey && rootElement.contains(target)) {\n        tableObserver.$clearHighlight();\n      }\n    });\n  };\n  editorWindow.addEventListener('pointerdown', pointerDownCallback, tableObserver.listenerOptions);\n  tableObserver.listenersToRemove.add(() => {\n    editorWindow.removeEventListener('pointerdown', pointerDownCallback);\n  });\n  for (const [command, direction] of ARROW_KEY_COMMANDS_WITH_DIRECTION) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, event => $handleArrowKey(editor, event, direction, tableNode, tableObserver), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_ESCAPE_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ($isTableSelection(selection)) {\n      const focusCellNode = $findParentTableCellNodeInTable(tableNode, selection.focus.getNode());\n      if (focusCellNode !== null) {\n        stopEvent(event);\n        focusCellNode.selectEnd();\n        return true;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  const deleteTextHandler = command => () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearText();\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = $findParentTableCellNodeInTable(tableNode, selection.anchor.getNode());\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      const anchorNode = selection.anchor.getNode();\n      const focusNode = selection.focus.getNode();\n      const isAnchorInside = tableNode.isParentOf(anchorNode);\n      const isFocusInside = tableNode.isParentOf(focusNode);\n      const selectionContainsPartialTable = isAnchorInside && !isFocusInside || isFocusInside && !isAnchorInside;\n      if (selectionContainsPartialTable) {\n        tableObserver.$clearText();\n        return true;\n      }\n      const nearestElementNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n));\n      const topLevelCellElementNode = nearestElementNode && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(nearestElementNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && $isTableCellNode(n.getParent()));\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topLevelCellElementNode) || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nearestElementNode)) {\n        return false;\n      }\n      if (command === lexical__WEBPACK_IMPORTED_MODULE_0__.DELETE_LINE_COMMAND && topLevelCellElementNode.getPreviousSibling() === null) {\n        // TODO: Fix Delete Line in Table Cells.\n        return true;\n      }\n    }\n    return false;\n  };\n  for (const command of DELETE_TEXT_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, deleteTextHandler(command), lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  const $deleteCellHandler = event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n      return false;\n    }\n\n    // If the selection is inside the table but should remove the whole table\n    // we expand the selection so that both the anchor and focus are outside\n    // the table and the editor's command listener will handle the delete\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    if (isAnchorInside !== isFocusInside) {\n      const tablePoint = isAnchorInside ? 'anchor' : 'focus';\n      const outerPoint = isAnchorInside ? 'focus' : 'anchor';\n      // Preserve the outer point\n      const {\n        key,\n        offset,\n        type\n      } = selection[outerPoint];\n      // Expand the selection around the table\n      const newSelection = tableNode[selection[tablePoint].isBefore(selection[outerPoint]) ? 'selectPrevious' : 'selectNext']();\n      // Restore the outer point of the selection\n      newSelection[outerPoint].set(key, offset, type);\n      // Let the base implementation handle the rest\n      return false;\n    }\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      if (event) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      tableObserver.$clearText();\n      return true;\n    }\n    return false;\n  };\n  for (const command of DELETE_KEY_COMMANDS) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(command, $deleteCellHandler, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CUT_COMMAND, event => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (selection) {\n      if (!($isTableSelection(selection) || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection))) {\n        return false;\n      }\n      // Copying to the clipboard is async so we must capture the data\n      // before we delete it\n      void (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.copyToClipboard)(editor, (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.objectKlassEquals)(event, ClipboardEvent) ? event : null, (0,_lexical_clipboard__WEBPACK_IMPORTED_MODULE_2__.$getClipboardDataFromSelection)(selection));\n      const intercepted = $deleteCellHandler(event);\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n        selection.removeText();\n        return true;\n      }\n      return intercepted;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_TEXT_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$formatCells(payload);\n      return true;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FORMAT_ELEMENT_COMMAND, formatType => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isTableSelection(selection) || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (!$isTableCellNode(anchorNode) || !$isTableCellNode(focusNode)) {\n      return false;\n    }\n\n    // Align the table if the entire table is selected\n    if ($isFullTableSelection(selection, tableNode)) {\n      tableNode.setFormat(formatType);\n      return true;\n    }\n    const [tableMap, anchorCell, focusCell] = $computeTableMap(tableNode, anchorNode, focusNode);\n    const maxRow = Math.max(anchorCell.startRow + anchorCell.cell.__rowSpan - 1, focusCell.startRow + focusCell.cell.__rowSpan - 1);\n    const maxColumn = Math.max(anchorCell.startColumn + anchorCell.cell.__colSpan - 1, focusCell.startColumn + focusCell.cell.__colSpan - 1);\n    const minRow = Math.min(anchorCell.startRow, focusCell.startRow);\n    const minColumn = Math.min(anchorCell.startColumn, focusCell.startColumn);\n    const visited = new Set();\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const cell = tableMap[i][j].cell;\n        if (visited.has(cell)) {\n          continue;\n        }\n        visited.add(cell);\n        cell.setFormat(formatType);\n        const cellChildren = cell.getChildren();\n        for (let k = 0; k < cellChildren.length; k++) {\n          const child = cellChildren[k];\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child) && !child.isInline()) {\n            child.setFormat(formatType);\n          }\n        }\n      }\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CONTROLLED_TEXT_INSERTION_COMMAND, payload => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    if ($isTableSelection(selection)) {\n      tableObserver.$clearHighlight();\n      return false;\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const tableCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n      if (!$isTableCellNode(tableCellNode)) {\n        return false;\n      }\n      if (typeof payload === 'string') {\n        const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n        if (edgePosition) {\n          $insertParagraphAtTableEdge(edgePosition, tableNode, [(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(payload)]);\n          return true;\n        }\n      }\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  if (hasTabHandler) {\n    tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.KEY_TAB_COMMAND, event => {\n      const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n        return false;\n      }\n      const tableCellNode = $findCellNode(selection.anchor.getNode());\n      if (tableCellNode === null || !tableNode.is($findTableNode(tableCellNode))) {\n        return false;\n      }\n      stopEvent(event);\n      $selectAdjacentCell(tableCellNode, event.shiftKey ? 'previous' : 'next');\n      return true;\n    }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  }\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.FOCUS_COMMAND, payload => {\n    return tableNode.isSelected();\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_HIGH));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, (selectionPayload, dispatchEditor) => {\n    if (editor !== dispatchEditor) {\n      return false;\n    }\n    const {\n      nodes,\n      selection\n    } = selectionPayload;\n    const anchorAndFocus = selection.getStartEndPoints();\n    const isTableSelection = $isTableSelection(selection);\n    const isRangeSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection);\n    const isSelectionInsideOfGrid = isRangeSelection && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n)) !== null && (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.focus.getNode(), n => $isTableCellNode(n)) !== null || isTableSelection;\n    if (nodes.length !== 1 || !$isTableNode(nodes[0]) || !isSelectionInsideOfGrid || anchorAndFocus === null) {\n      return false;\n    }\n    const [anchor, focus] = anchorAndFocus;\n    const [anchorCellNode, anchorRowNode, gridNode] = $getNodeTriplet(anchor);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), n => $isTableCellNode(n));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableRowNode(anchorRowNode) || !$isTableNode(gridNode)) {\n      return false;\n    }\n    const templateGrid = nodes[0];\n    const [initialGridMap, anchorCellMap, focusCellMap] = $computeTableMap(gridNode, anchorCellNode, focusCellNode);\n    const [templateGridMap] = $computeTableMapSkipCellCheck(templateGrid, null, null);\n    const initialRowCount = initialGridMap.length;\n    const initialColCount = initialRowCount > 0 ? initialGridMap[0].length : 0;\n\n    // If we have a range selection, we'll fit the template grid into the\n    // table, growing the table if necessary.\n    let startRow = anchorCellMap.startRow;\n    let startCol = anchorCellMap.startColumn;\n    let affectedRowCount = templateGridMap.length;\n    let affectedColCount = affectedRowCount > 0 ? templateGridMap[0].length : 0;\n    if (isTableSelection) {\n      // If we have a table selection, we'll only modify the cells within\n      // the selection boundary.\n      const selectionBoundary = $computeTableCellRectBoundary(initialGridMap, anchorCellMap, focusCellMap);\n      const selectionRowCount = selectionBoundary.maxRow - selectionBoundary.minRow + 1;\n      const selectionColCount = selectionBoundary.maxColumn - selectionBoundary.minColumn + 1;\n      startRow = selectionBoundary.minRow;\n      startCol = selectionBoundary.minColumn;\n      affectedRowCount = Math.min(affectedRowCount, selectionRowCount);\n      affectedColCount = Math.min(affectedColCount, selectionColCount);\n    }\n\n    // Step 1: Unmerge all merged cells within the affected area\n    let didPerformMergeOperations = false;\n    const lastRowForUnmerge = Math.min(initialRowCount, startRow + affectedRowCount) - 1;\n    const lastColForUnmerge = Math.min(initialColCount, startCol + affectedColCount) - 1;\n    const unmergedKeys = new Set();\n    for (let row = startRow; row <= lastRowForUnmerge; row++) {\n      for (let col = startCol; col <= lastColForUnmerge; col++) {\n        const cellMap = initialGridMap[row][col];\n        if (unmergedKeys.has(cellMap.cell.getKey())) {\n          continue; // cell was a merged cell that was already handled\n        }\n        if (cellMap.cell.__rowSpan === 1 && cellMap.cell.__colSpan === 1) {\n          continue; // cell is not a merged cell\n        }\n        $unmergeCellNode(cellMap.cell);\n        unmergedKeys.add(cellMap.cell.getKey());\n        didPerformMergeOperations = true;\n      }\n    }\n    let [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 2: Expand current table (if needed)\n    const rowsToInsert = affectedRowCount - initialRowCount + startRow;\n    for (let i = 0; i < rowsToInsert; i++) {\n      const cellMap = interimGridMap[initialRowCount - 1][0];\n      $insertTableRowAtNode(cellMap.cell);\n    }\n    const colsToInsert = affectedColCount - initialColCount + startCol;\n    for (let i = 0; i < colsToInsert; i++) {\n      const cellMap = interimGridMap[0][initialColCount - 1];\n      $insertTableColumnAtNode(cellMap.cell, true, false);\n    }\n    [interimGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n\n    // Step 3: Merge cells and set cell content, to match template grid\n    for (let row = startRow; row < startRow + affectedRowCount; row++) {\n      for (let col = startCol; col < startCol + affectedColCount; col++) {\n        const templateRow = row - startRow;\n        const templateCol = col - startCol;\n        const templateCellMap = templateGridMap[templateRow][templateCol];\n        if (templateCellMap.startRow !== templateRow || templateCellMap.startColumn !== templateCol) {\n          continue; // cell is a merged cell that was already handled\n        }\n        const templateCell = templateCellMap.cell;\n        if (templateCell.__rowSpan !== 1 || templateCell.__colSpan !== 1) {\n          const cellsToMerge = [];\n          const lastRowForMerge = Math.min(row + templateCell.__rowSpan, startRow + affectedRowCount) - 1;\n          const lastColForMerge = Math.min(col + templateCell.__colSpan, startCol + affectedColCount) - 1;\n          for (let r = row; r <= lastRowForMerge; r++) {\n            for (let c = col; c <= lastColForMerge; c++) {\n              const cellMap = interimGridMap[r][c];\n              cellsToMerge.push(cellMap.cell);\n            }\n          }\n          $mergeCells(cellsToMerge);\n          didPerformMergeOperations = true;\n        }\n        const {\n          cell\n        } = interimGridMap[row][col];\n        const originalChildren = cell.getChildren();\n        templateCell.getChildren().forEach(child => {\n          if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n            const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n            paragraphNode.append(child);\n            cell.append(child);\n          } else {\n            cell.append(child);\n          }\n        });\n        originalChildren.forEach(n => n.remove());\n      }\n    }\n    if (isTableSelection && didPerformMergeOperations) {\n      // reset the table selection in case the anchor or focus cell was\n      // removed via merge operations\n      const [finalGridMap] = $computeTableMapSkipCellCheck(gridNode.getWritable(), null, null);\n      const newAnchorCellMap = finalGridMap[anchorCellMap.startRow][anchorCellMap.startColumn];\n      newAnchorCellMap.cell.selectEnd();\n    }\n    return true;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_CHANGE_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    const prevSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n    const nextFocus = tableObserver.getAndClearNextFocus();\n    if (nextFocus !== null) {\n      const {\n        focusCell\n      } = nextFocus;\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        if (focusCell.x === tableObserver.focusX && focusCell.y === tableObserver.focusY) {\n          // The selection is already the correct table selection\n          return false;\n        } else {\n          tableObserver.$setFocusCellForSelection(focusCell);\n          return true;\n        }\n      } else if (focusCell !== tableObserver.anchorCell && $isSelectionInTable(selection, tableNode)) {\n        // The selection has crossed cells\n        tableObserver.$setFocusCellForSelection(focusCell);\n        return true;\n      }\n    }\n    const shouldCheckSelection = tableObserver.getAndClearShouldCheckSelection();\n    // If they pressed the down arrow with the selection outside of the\n    // table, and then the selection ends up in the table but not in the\n    // first cell, then move the selection to the first cell.\n    if (shouldCheckSelection && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && selection.isCollapsed()) {\n      const anchor = selection.anchor.getNode();\n      const firstRow = tableNode.getFirstChild();\n      const anchorCell = $findCellNode(anchor);\n      if (anchorCell !== null && $isTableRowNode(firstRow)) {\n        const firstCell = firstRow.getFirstChild();\n        if ($isTableCellNode(firstCell) && tableNode.is((0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, node => node.is(tableNode) || node.is(firstCell)))) {\n          // The selection moved to the table, but not in the first cell\n          firstCell.selectStart();\n          return true;\n        }\n      }\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorNode = anchor.getNode();\n      const focusNode = focus.getNode();\n      // Using explicit comparison with table node to ensure it's not a nested table\n      // as in that case we'll leave selection resolving to that table\n      const anchorCellNode = $findCellNode(anchorNode);\n      const focusCellNode = $findCellNode(focusNode);\n      const isAnchorInside = !!(anchorCellNode && tableNode.is($findTableNode(anchorCellNode)));\n      const isFocusInside = !!(focusCellNode && tableNode.is($findTableNode(focusCellNode)));\n      const isPartiallyWithinTable = isAnchorInside !== isFocusInside;\n      const isWithinTable = isAnchorInside && isFocusInside;\n      const isBackward = selection.isBackward();\n      if (isPartiallyWithinTable) {\n        const newSelection = selection.clone();\n        if (isFocusInside) {\n          const [tableMap] = $computeTableMap(tableNode, focusCellNode, focusCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          newSelection.focus.set(isBackward ? firstCell.getKey() : lastCell.getKey(), isBackward ? firstCell.getChildrenSize() : lastCell.getChildrenSize(), 'element');\n        } else if (isAnchorInside) {\n          const [tableMap] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n          const firstCell = tableMap[0][0].cell;\n          const lastCell = tableMap[tableMap.length - 1].at(-1).cell;\n          /**\n           * If isBackward, set the anchor to be at the end of the table so that when the cursor moves outside of\n           * the table in the backward direction, the entire table will be selected from its end.\n           * Otherwise, if forward, set the anchor to be at the start of the table so that when the focus is dragged\n           * outside th end of the table, it will start from the beginning of the table.\n           */\n          newSelection.anchor.set(isBackward ? lastCell.getKey() : firstCell.getKey(), isBackward ? lastCell.getChildrenSize() : 0, 'element');\n        }\n        (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n        $addHighlightStyleToTable(editor, tableObserver);\n      } else if (isWithinTable) {\n        // Handle case when selection spans across multiple cells but still\n        // has range selection, then we convert it into table selection\n        if (!anchorCellNode.is(focusCellNode)) {\n          tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, anchorCellNode));\n          tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n        }\n\n        // Handle case when the pointer type is touch and the current and\n        // previous selection are collapsed, and the previous anchor and current\n        // focus cell nodes are different, then we convert it into table selection\n        // However, only do this if the table observer is actively selecting (user dragging)\n        // to prevent unwanted selections when simply tapping between cells on mobile\n        if (tableObserver.pointerType === 'touch' && tableObserver.isSelecting && selection.isCollapsed() && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(prevSelection) && prevSelection.isCollapsed()) {\n          const prevAnchorCellNode = $findCellNode(prevSelection.anchor.getNode());\n          if (prevAnchorCellNode && !prevAnchorCellNode.is(focusCellNode)) {\n            tableObserver.$setAnchorCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, prevAnchorCellNode));\n            tableObserver.$setFocusCellForSelection($getObserverCellFromCellNodeOrThrow(tableObserver, focusCellNode), true);\n            tableObserver.pointerType = null;\n          }\n        }\n      }\n    } else if (selection && $isTableSelection(selection) && selection.is(prevSelection) && selection.tableKey === tableNode.getKey()) {\n      // if selection goes outside of the table we need to change it to Range selection\n      const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(editorWindow);\n      if (domSelection && domSelection.anchorNode && domSelection.focusNode) {\n        const focusNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.focusNode);\n        const isFocusOutside = focusNode && !tableNode.isParentOf(focusNode);\n        const anchorNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(domSelection.anchorNode);\n        const isAnchorInside = anchorNode && tableNode.isParentOf(anchorNode);\n        if (isFocusOutside && isAnchorInside && domSelection.rangeCount > 0) {\n          const newSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createRangeSelectionFromDom)(domSelection, editor);\n          if (newSelection) {\n            newSelection.anchor.set(tableNode.getKey(), selection.isBackward() ? tableNode.getChildrenSize() : 0, 'element');\n            domSelection.removeAllRanges();\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          }\n        }\n      }\n    }\n    if (selection && !selection.is(prevSelection) && ($isTableSelection(selection) || $isTableSelection(prevSelection)) && tableObserver.tableSelection && !tableObserver.tableSelection.is(prevSelection)) {\n      if ($isTableSelection(selection) && selection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(selection);\n      } else if (!$isTableSelection(selection) && $isTableSelection(prevSelection) && prevSelection.tableKey === tableObserver.tableNodeKey) {\n        tableObserver.$updateTableTableSelection(null);\n      }\n      return false;\n    }\n    if (tableObserver.hasHijackedSelectionStyles && !tableNode.isSelected()) {\n      $removeHighlightStyleToTable(editor, tableObserver);\n    } else if (!tableObserver.hasHijackedSelectionStyles && tableNode.isSelected()) {\n      $addHighlightStyleToTable(editor, tableObserver);\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  tableObserver.listenersToRemove.add(editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || !selection.isCollapsed() || !$isSelectionInTable(selection, tableNode)) {\n      return false;\n    }\n    const edgePosition = $getTableEdgeCursorPosition(editor, selection, tableNode);\n    if (edgePosition) {\n      $insertParagraphAtTableEdge(edgePosition, tableNode);\n      return true;\n    }\n    return false;\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_CRITICAL));\n  return tableObserver;\n}\nfunction detachTableObserverFromTableElement(tableElement, tableObserver) {\n  if (getTableObserverFromTableElement(tableElement) === tableObserver) {\n    delete tableElement[LEXICAL_ELEMENT_KEY];\n  }\n}\nfunction attachTableObserverToTableElement(tableElement, tableObserver) {\n  if (!(getTableObserverFromTableElement(tableElement) === null)) {\n    formatDevErrorMessage(`tableElement already has an attached TableObserver`);\n  }\n  tableElement[LEXICAL_ELEMENT_KEY] = tableObserver;\n}\nfunction getTableObserverFromTableElement(tableElement) {\n  return tableElement[LEXICAL_ELEMENT_KEY] || null;\n}\nfunction getDOMCellFromTarget(node) {\n  let currentNode = node;\n  while (currentNode != null) {\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      const cell = currentNode._cell;\n      if (cell === undefined) {\n        return null;\n      }\n      return cell;\n    }\n    currentNode = currentNode.parentNode;\n  }\n  return null;\n}\nfunction getDOMCellInTableFromTarget(table, node) {\n  if (!table.contains(node)) {\n    return null;\n  }\n  let cell = null;\n  for (let currentNode = node; currentNode != null; currentNode = currentNode.parentNode) {\n    if (currentNode === table) {\n      return cell;\n    }\n    const nodeName = currentNode.nodeName;\n    if (nodeName === 'TD' || nodeName === 'TH') {\n      // @ts-expect-error: internal field\n      cell = currentNode._cell || null;\n    }\n  }\n  return null;\n}\nfunction getTable(tableNode, dom) {\n  const tableElement = getTableElement(tableNode, dom);\n  const domRows = [];\n  const grid = {\n    columns: 0,\n    domRows,\n    rows: 0\n  };\n  let currentNode = tableElement.querySelector('tr');\n  let x = 0;\n  let y = 0;\n  domRows.length = 0;\n  while (currentNode != null) {\n    const nodeMame = currentNode.nodeName;\n    if (nodeMame === 'TD' || nodeMame === 'TH') {\n      const elem = currentNode;\n      const cell = {\n        elem,\n        hasBackgroundColor: elem.style.backgroundColor !== '',\n        highlighted: false,\n        x,\n        y\n      };\n\n      // @ts-expect-error: internal field\n      currentNode._cell = cell;\n      let row = domRows[y];\n      if (row === undefined) {\n        row = domRows[y] = [];\n      }\n      row[x] = cell;\n    } else {\n      const child = currentNode.firstChild;\n      if (child != null) {\n        currentNode = child;\n        continue;\n      }\n    }\n    const sibling = currentNode.nextSibling;\n    if (sibling != null) {\n      x++;\n      currentNode = sibling;\n      continue;\n    }\n    const parent = currentNode.parentNode;\n    if (parent != null) {\n      const parentSibling = parent.nextSibling;\n      if (parentSibling == null) {\n        break;\n      }\n      y++;\n      x = 0;\n      currentNode = parentSibling;\n    }\n  }\n  grid.columns = x + 1;\n  grid.rows = y + 1;\n  return grid;\n}\nfunction $updateDOMForSelection(editor, table, selection) {\n  const selectedCellNodes = new Set(selection ? selection.getNodes() : []);\n  $forEachTableCell(table, (cell, lexicalNode) => {\n    const elem = cell.elem;\n    if (selectedCellNodes.has(lexicalNode)) {\n      cell.highlighted = true;\n      $addHighlightToDOM(editor, cell);\n    } else {\n      cell.highlighted = false;\n      $removeHighlightFromDOM(editor, cell);\n      if (!elem.getAttribute('style')) {\n        elem.removeAttribute('style');\n      }\n    }\n  });\n}\nfunction $forEachTableCell(grid, cb) {\n  const {\n    domRows\n  } = grid;\n  for (let y = 0; y < domRows.length; y++) {\n    const row = domRows[y];\n    if (!row) {\n      continue;\n    }\n    for (let x = 0; x < row.length; x++) {\n      const cell = row[x];\n      if (!cell) {\n        continue;\n      }\n      const lexicalNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n      if (lexicalNode !== null) {\n        cb(cell, lexicalNode, {\n          x,\n          y\n        });\n      }\n    }\n  }\n}\nfunction $addHighlightStyleToTable(editor, tableSelection) {\n  tableSelection.$disableHighlightStyle();\n  $forEachTableCell(tableSelection.table, cell => {\n    cell.highlighted = true;\n    $addHighlightToDOM(editor, cell);\n  });\n}\nfunction $removeHighlightStyleToTable(editor, tableObserver) {\n  tableObserver.$enableHighlightStyle();\n  $forEachTableCell(tableObserver.table, cell => {\n    const elem = cell.elem;\n    cell.highlighted = false;\n    $removeHighlightFromDOM(editor, cell);\n    if (!elem.getAttribute('style')) {\n      elem.removeAttribute('style');\n    }\n  });\n}\nfunction $selectAdjacentCell(tableCellNode, direction) {\n  const siblingMethod = direction === 'next' ? 'getNextSibling' : 'getPreviousSibling';\n  const childMethod = direction === 'next' ? 'getFirstChild' : 'getLastChild';\n  const sibling = tableCellNode[siblingMethod]();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n    return sibling.selectEnd();\n  }\n  const parentRow = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(tableCellNode, $isTableRowNode);\n  if (!(parentRow !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Cell not in table row`);\n  }\n  for (let nextRow = parentRow[siblingMethod](); $isTableRowNode(nextRow); nextRow = nextRow[siblingMethod]()) {\n    const child = nextRow[childMethod]();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(child)) {\n      return child.selectEnd();\n    }\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(parentRow, $isTableNode);\n  if (!(parentTable !== null)) {\n    formatDevErrorMessage(`selectAdjacentCell: Row not in table`);\n  }\n  return direction === 'next' ? parentTable.selectNext() : parentTable.selectPrevious();\n}\nconst selectTableNodeInDirection = (tableObserver, tableNode, x, y, direction) => {\n  const isForward = direction === 'forward';\n  switch (direction) {\n    case 'backward':\n    case 'forward':\n      if (x !== (isForward ? tableObserver.table.columns - 1 : 0)) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x + (isForward ? 1 : -1), y, tableObserver.table), isForward);\n      } else {\n        if (y !== (isForward ? tableObserver.table.rows - 1 : 0)) {\n          selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(isForward ? 0 : tableObserver.table.columns - 1, y + (isForward ? 1 : -1), tableObserver.table), isForward);\n        } else if (!isForward) {\n          tableNode.selectPrevious();\n        } else {\n          tableNode.selectNext();\n        }\n      }\n      return true;\n    case 'up':\n      if (y !== 0) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y - 1, tableObserver.table), false);\n      } else {\n        tableNode.selectPrevious();\n      }\n      return true;\n    case 'down':\n      if (y !== tableObserver.table.rows - 1) {\n        selectTableCellNode(tableNode.getCellNodeFromCordsOrThrow(x, y + 1, tableObserver.table), true);\n      } else {\n        tableNode.selectNext();\n      }\n      return true;\n    default:\n      return false;\n  }\n};\nfunction getCorner(rect, cellValue) {\n  let colName;\n  let rowName;\n  if (cellValue.startColumn === rect.minColumn) {\n    colName = 'minColumn';\n  } else if (cellValue.startColumn + cellValue.cell.__colSpan - 1 === rect.maxColumn) {\n    colName = 'maxColumn';\n  } else {\n    return null;\n  }\n  if (cellValue.startRow === rect.minRow) {\n    rowName = 'minRow';\n  } else if (cellValue.startRow + cellValue.cell.__rowSpan - 1 === rect.maxRow) {\n    rowName = 'maxRow';\n  } else {\n    return null;\n  }\n  return [colName, rowName];\n}\nfunction getCornerOrThrow(rect, cellValue) {\n  const corner = getCorner(rect, cellValue);\n  if (!(corner !== null)) {\n    formatDevErrorMessage(`getCornerOrThrow: cell ${cellValue.cell.getKey()} is not at a corner of rect`);\n  }\n  return corner;\n}\nfunction oppositeCorner([colName, rowName]) {\n  return [colName === 'minColumn' ? 'maxColumn' : 'minColumn', rowName === 'minRow' ? 'maxRow' : 'minRow'];\n}\nfunction cellAtCornerOrThrow(tableMap, rect, [colName, rowName]) {\n  const rowNum = rect[rowName];\n  const rowMap = tableMap[rowNum];\n  if (!(rowMap !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${rowName} = ${String(rowNum)} missing in tableMap`);\n  }\n  const colNum = rect[colName];\n  const cell = rowMap[colNum];\n  if (!(cell !== undefined)) {\n    formatDevErrorMessage(`cellAtCornerOrThrow: ${colName} = ${String(colNum)} missing in tableMap`);\n  }\n  return cell;\n}\nfunction $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue) {\n  // We are sure that the focus now either contracts or expands the rect\n  // but both the anchor and focus might be moved to ensure a rectangle\n  // given a potentially ragged merge shape\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorCorner = getCorner(rect, anchorCellValue);\n  if (anchorCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, anchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(anchorCorner))];\n  }\n  const newFocusCorner = getCorner(rect, newFocusCellValue);\n  if (newFocusCorner) {\n    return [cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newFocusCorner)), cellAtCornerOrThrow(tableMap, rect, newFocusCorner)];\n  }\n  // TODO this doesn't have to be arbitrary, use the closest corner instead\n  const newAnchorCorner = ['minColumn', 'minRow'];\n  return [cellAtCornerOrThrow(tableMap, rect, newAnchorCorner), cellAtCornerOrThrow(tableMap, rect, oppositeCorner(newAnchorCorner))];\n}\nfunction $adjustFocusInDirection(tableObserver, tableMap, anchorCellValue, focusCellValue, direction) {\n  const rect = $computeTableCellRectBoundary(tableMap, anchorCellValue, focusCellValue);\n  const spans = $computeTableCellRectSpans(tableMap, rect);\n  const {\n    topSpan,\n    leftSpan,\n    bottomSpan,\n    rightSpan\n  } = spans;\n  const anchorCorner = getCornerOrThrow(rect, anchorCellValue);\n  const [focusColumn, focusRow] = oppositeCorner(anchorCorner);\n  let fCol = rect[focusColumn];\n  let fRow = rect[focusRow];\n  if (direction === 'forward') {\n    fCol += focusColumn === 'maxColumn' ? 1 : leftSpan;\n  } else if (direction === 'backward') {\n    fCol -= focusColumn === 'minColumn' ? 1 : rightSpan;\n  } else if (direction === 'down') {\n    fRow += focusRow === 'maxRow' ? 1 : topSpan;\n  } else if (direction === 'up') {\n    fRow -= focusRow === 'minRow' ? 1 : bottomSpan;\n  }\n  const targetRowMap = tableMap[fRow];\n  if (targetRowMap === undefined) {\n    return false;\n  }\n  const newFocusCellValue = targetRowMap[fCol];\n  if (newFocusCellValue === undefined) {\n    return false;\n  }\n  // We can be certain that anchorCellValue and newFocusCellValue are\n  // contained within the desired selection, but we are not certain if\n  // they need to be expanded or not to maintain a rectangular shape\n  const [finalAnchorCell, finalFocusCell] = $extractRectCorners(tableMap, anchorCellValue, newFocusCellValue);\n  const anchorDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalAnchorCell.cell);\n  const focusDOM = $getObserverCellFromCellNodeOrThrow(tableObserver, finalFocusCell.cell);\n  tableObserver.$setAnchorCellForSelection(anchorDOM);\n  tableObserver.$setFocusCellForSelection(focusDOM, true);\n  return true;\n}\nfunction $isSelectionInTable(selection, tableNode) {\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) || $isTableSelection(selection)) {\n    // TODO this should probably return false if there's an unrelated\n    //      shadow root between the node and the table (e.g. another table,\n    //      collapsible, etc.)\n    const isAnchorInside = tableNode.isParentOf(selection.anchor.getNode());\n    const isFocusInside = tableNode.isParentOf(selection.focus.getNode());\n    return isAnchorInside && isFocusInside;\n  }\n  return false;\n}\nfunction $isFullTableSelection(selection, tableNode) {\n  if ($isTableSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    if (tableNode && anchorNode && focusNode) {\n      const [map] = $computeTableMap(tableNode, anchorNode, focusNode);\n      return anchorNode.getKey() === map[0][0].cell.getKey() && focusNode.getKey() === map[map.length - 1].at(-1).cell.getKey();\n    }\n  }\n  return false;\n}\nfunction selectTableCellNode(tableCell, fromStart) {\n  if (fromStart) {\n    tableCell.selectStart();\n  } else {\n    tableCell.selectEnd();\n  }\n}\nfunction $addHighlightToDOM(editor, cell) {\n  const element = cell.elem;\n  const editorThemeClasses = editor._config.theme;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $removeHighlightFromDOM(editor, cell) {\n  const element = cell.elem;\n  const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(element);\n  if (!$isTableCellNode(node)) {\n    formatDevErrorMessage(`Expected to find LexicalNode from Table Cell DOMNode`);\n  }\n  const editorThemeClasses = editor._config.theme;\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(element, editorThemeClasses.tableCellSelected);\n}\nfunction $findCellNode(node) {\n  const cellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableCellNode);\n  return $isTableCellNode(cellNode) ? cellNode : null;\n}\nfunction $findTableNode(node) {\n  const tableNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, $isTableNode);\n  return $isTableNode(tableNode) ? tableNode : null;\n}\nfunction $getBlockParentIfFirstNode(node) {\n  for (let prevNode = node, currentNode = node; currentNode !== null; prevNode = currentNode, currentNode = currentNode.getParent()) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(currentNode)) {\n      if (currentNode !== prevNode && currentNode.getFirstChild() !== prevNode) {\n        // Not the first child or the initial node\n        return null;\n      } else if (!currentNode.isInline()) {\n        return currentNode;\n      }\n    }\n  }\n  return null;\n}\nfunction $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, isBackward, tableNode, tableObserver) {\n  const initialFocus = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$caretFromPoint)(selection.focus, isBackward ? 'previous' : 'next');\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isExtendableTextPointCaret)(initialFocus)) {\n    return false;\n  }\n  let lastCaret = initialFocus;\n  // TableCellNode is the only shadow root we are interested in piercing so\n  // we find the last internal caret and then check its parent\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialFocus).iterNodeCarets('shadowRoot')) {\n    if (!((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isSiblingCaret)(nextCaret) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(nextCaret.origin))) {\n      return false;\n    }\n    lastCaret = nextCaret;\n  }\n  const lastCaretParent = lastCaret.getParentAtCaret();\n  if (!$isTableCellNode(lastCaretParent)) {\n    return false;\n  }\n  const anchorCell = lastCaretParent;\n  const focusCaret = $findNextTableCell((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCell, lastCaret.direction));\n  const anchorCellTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCell, $isTableNode);\n  if (!(anchorCellTable && anchorCellTable.is(tableNode))) {\n    return false;\n  }\n  const anchorCellDOM = editor.getElementByKey(anchorCell.getKey());\n  const anchorDOMCell = getDOMCellFromTarget(anchorCellDOM);\n  if (!anchorCellDOM || !anchorDOMCell) {\n    return false;\n  }\n  const anchorCellTableElement = $getElementForTableNode(editor, anchorCellTable);\n  tableObserver.table = anchorCellTableElement;\n  if (!focusCaret) {\n    if (alter === 'extend') {\n      // extend the selection from a range inside the cell to a table selection of the cell\n      tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n      tableObserver.$setFocusCellForSelection(anchorDOMCell, true);\n    } else {\n      // exit the table\n      const outerFocusCaret = $getTableExitCaret((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSiblingCaret)(anchorCellTable, initialFocus.direction));\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, outerFocusCaret);\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, outerFocusCaret);\n    }\n  } else if (alter === 'extend') {\n    const focusDOMCell = getDOMCellFromTarget(editor.getElementByKey(focusCaret.origin.getKey()));\n    if (!focusDOMCell) {\n      return false;\n    }\n    tableObserver.$setAnchorCellForSelection(anchorDOMCell);\n    tableObserver.$setFocusCellForSelection(focusDOMCell, true);\n  } else {\n    // alter === 'move'\n    const innerFocusCaret = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(focusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.anchor, innerFocusCaret);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setPointFromCaret)(selection.focus, innerFocusCaret);\n  }\n  stopEvent(event);\n  return true;\n}\nfunction $getTableExitCaret(initialCaret) {\n  const adjacent = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getAdjacentChildCaret)(initialCaret);\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(adjacent) ? (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeCaret)(adjacent) : initialCaret;\n}\nfunction $findNextTableCell(initialCaret) {\n  for (const nextCaret of (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$extendCaretToRange)(initialCaret).iterNodeCarets('root')) {\n    const {\n      origin\n    } = nextCaret;\n    if ($isTableCellNode(origin)) {\n      // not sure why ts isn't narrowing here (even if the guard is on nextCaret.origin)\n      // but returning a new caret is fine\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isChildCaret)(nextCaret)) {\n        return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getChildCaret)(origin, initialCaret.direction);\n      }\n    } else if (!$isTableRowNode(origin)) {\n      break;\n    }\n  }\n  return null;\n}\nfunction $handleArrowKey(editor, event, direction, tableNode, tableObserver) {\n  if ((direction === 'up' || direction === 'down') && isTypeaheadMenuInView(editor)) {\n    return false;\n  }\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!$isSelectionInTable(selection, tableNode)) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      if (direction === 'backward') {\n        if (selection.focus.offset > 0) {\n          return false;\n        }\n        const parentNode = $getBlockParentIfFirstNode(selection.focus.getNode());\n        if (!parentNode) {\n          return false;\n        }\n        const siblingNode = parentNode.getPreviousSibling();\n        if (!$isTableNode(siblingNode)) {\n          return false;\n        }\n        stopEvent(event);\n        if (event.shiftKey) {\n          selection.focus.set(siblingNode.getParentOrThrow().getKey(), siblingNode.getIndexWithinParent(), 'element');\n        } else {\n          siblingNode.selectEnd();\n        }\n        return true;\n      } else if (event.shiftKey && (direction === 'up' || direction === 'down')) {\n        const focusNode = selection.focus.getNode();\n        const isTableUnselect = !selection.isCollapsed() && (direction === 'up' && !selection.isBackward() || direction === 'down' && selection.isBackward());\n        if (isTableUnselect) {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => $isTableNode(n));\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (focusParentNode !== tableNode) {\n            return false;\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if (!sibling) {\n            return false;\n          }\n          let newOffset = 0;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              newOffset = sibling.getChildrenSize();\n            }\n          }\n          let newFocusNode = sibling;\n          if (direction === 'up') {\n            if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(sibling)) {\n              const lastCell = sibling.getLastChild();\n              newFocusNode = lastCell ? lastCell : sibling;\n              newOffset = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? newFocusNode.getTextContentSize() : 0;\n            }\n          }\n          const newSelection = selection.clone();\n          newSelection.focus.set(newFocusNode.getKey(), newOffset, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(newFocusNode) ? 'text' : 'element');\n          (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n          stopEvent(event);\n          return true;\n        } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRootOrShadowRoot)(focusNode)) {\n          const selectedNode = direction === 'up' ? selection.getNodes()[selection.getNodes().length - 1] : selection.getNodes()[0];\n          if (selectedNode) {\n            const tableCellNode = $findParentTableCellNodeInTable(tableNode, selectedNode);\n            if (tableCellNode !== null) {\n              const firstDescendant = tableNode.getFirstDescendant();\n              const lastDescendant = tableNode.getLastDescendant();\n              if (!firstDescendant || !lastDescendant) {\n                return false;\n              }\n              const [firstCellNode] = $getNodeTriplet(firstDescendant);\n              const [lastCellNode] = $getNodeTriplet(lastDescendant);\n              const firstCellCoords = tableNode.getCordsFromCellNode(firstCellNode, tableObserver.table);\n              const lastCellCoords = tableNode.getCordsFromCellNode(lastCellNode, tableObserver.table);\n              const firstCellDOM = tableNode.getDOMCellFromCordsOrThrow(firstCellCoords.x, firstCellCoords.y, tableObserver.table);\n              const lastCellDOM = tableNode.getDOMCellFromCordsOrThrow(lastCellCoords.x, lastCellCoords.y, tableObserver.table);\n              tableObserver.$setAnchorCellForSelection(firstCellDOM);\n              tableObserver.$setFocusCellForSelection(lastCellDOM, true);\n              return true;\n            }\n          }\n          return false;\n        } else {\n          let focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusNode, n => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(n) && !n.isInline());\n          if ($isTableCellNode(focusParentNode)) {\n            focusParentNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focusParentNode, $isTableNode);\n          }\n          if (!focusParentNode) {\n            return false;\n          }\n          const sibling = direction === 'down' ? focusParentNode.getNextSibling() : focusParentNode.getPreviousSibling();\n          if ($isTableNode(sibling) && tableObserver.tableNodeKey === sibling.getKey()) {\n            const firstDescendant = sibling.getFirstDescendant();\n            const lastDescendant = sibling.getLastDescendant();\n            if (!firstDescendant || !lastDescendant) {\n              return false;\n            }\n            const [firstCellNode] = $getNodeTriplet(firstDescendant);\n            const [lastCellNode] = $getNodeTriplet(lastDescendant);\n            const newSelection = selection.clone();\n            newSelection.focus.set((direction === 'up' ? firstCellNode : lastCellNode).getKey(), direction === 'up' ? 0 : lastCellNode.getChildrenSize(), 'element');\n            stopEvent(event);\n            (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)(newSelection);\n            return true;\n          }\n        }\n      }\n    }\n    if (direction === 'down' && $isScrollableTablesActive(editor)) {\n      // Enable Firefox workaround\n      tableObserver.setShouldCheckSelection();\n    }\n    return false;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    if (direction === 'backward' || direction === 'forward') {\n      const alter = event.shiftKey ? 'extend' : 'move';\n      return $handleHorizontalArrowKeyRangeSelection(editor, event, selection, alter, direction === 'backward', tableNode, tableObserver);\n    }\n    if (selection.isCollapsed()) {\n      const {\n        anchor,\n        focus\n      } = selection;\n      const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n      const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n      if (!$isTableCellNode(anchorCellNode) || !anchorCellNode.is(focusCellNode)) {\n        return false;\n      }\n      const anchorCellTable = $findTableNode(anchorCellNode);\n      if (anchorCellTable !== tableNode && anchorCellTable != null) {\n        const anchorCellTableElement = getTableElement(anchorCellTable, editor.getElementByKey(anchorCellTable.getKey()));\n        if (anchorCellTableElement != null) {\n          tableObserver.table = getTable(anchorCellTable, anchorCellTableElement);\n          return $handleArrowKey(editor, event, direction, anchorCellTable, tableObserver);\n        }\n      }\n      const anchorCellDom = editor.getElementByKey(anchorCellNode.__key);\n      const anchorDOM = editor.getElementByKey(anchor.key);\n      if (anchorDOM == null || anchorCellDom == null) {\n        return false;\n      }\n      let edgeSelectionRect;\n      if (anchor.type === 'element') {\n        edgeSelectionRect = anchorDOM.getBoundingClientRect();\n      } else {\n        const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n        if (domSelection === null || domSelection.rangeCount === 0) {\n          return false;\n        }\n        const range = domSelection.getRangeAt(0);\n        edgeSelectionRect = range.getBoundingClientRect();\n      }\n      const edgeChild = direction === 'up' ? anchorCellNode.getFirstChild() : anchorCellNode.getLastChild();\n      if (edgeChild == null) {\n        return false;\n      }\n      const edgeChildDOM = editor.getElementByKey(edgeChild.__key);\n      if (edgeChildDOM == null) {\n        return false;\n      }\n      const edgeRect = edgeChildDOM.getBoundingClientRect();\n      const isExiting = direction === 'up' ? edgeRect.top > edgeSelectionRect.top - edgeSelectionRect.height : edgeSelectionRect.bottom + edgeSelectionRect.height > edgeRect.bottom;\n      if (isExiting) {\n        stopEvent(event);\n        const cords = tableNode.getCordsFromCellNode(anchorCellNode, tableObserver.table);\n        if (event.shiftKey) {\n          const cell = tableNode.getDOMCellFromCordsOrThrow(cords.x, cords.y, tableObserver.table);\n          tableObserver.$setAnchorCellForSelection(cell);\n          tableObserver.$setFocusCellForSelection(cell, true);\n        } else {\n          return selectTableNodeInDirection(tableObserver, tableNode, cords.x, cords.y, direction);\n        }\n        return true;\n      }\n    }\n  } else if ($isTableSelection(selection)) {\n    const {\n      anchor,\n      focus\n    } = selection;\n    const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchor.getNode(), $isTableCellNode);\n    const focusCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(focus.getNode(), $isTableCellNode);\n    const [tableNodeFromSelection] = selection.getNodes();\n    if (!$isTableNode(tableNodeFromSelection)) {\n      formatDevErrorMessage(`$handleArrowKey: TableSelection.getNodes()[0] expected to be TableNode`);\n    }\n    const tableElement = getTableElement(tableNodeFromSelection, editor.getElementByKey(tableNodeFromSelection.getKey()));\n    if (!$isTableCellNode(anchorCellNode) || !$isTableCellNode(focusCellNode) || !$isTableNode(tableNodeFromSelection) || tableElement == null) {\n      return false;\n    }\n    tableObserver.$updateTableTableSelection(selection);\n    const grid = getTable(tableNodeFromSelection, tableElement);\n    const cordsAnchor = tableNode.getCordsFromCellNode(anchorCellNode, grid);\n    const anchorCell = tableNode.getDOMCellFromCordsOrThrow(cordsAnchor.x, cordsAnchor.y, grid);\n    tableObserver.$setAnchorCellForSelection(anchorCell);\n    stopEvent(event);\n    if (event.shiftKey) {\n      const [tableMap, anchorValue, focusValue] = $computeTableMap(tableNode, anchorCellNode, focusCellNode);\n      return $adjustFocusInDirection(tableObserver, tableMap, anchorValue, focusValue, direction);\n    } else {\n      focusCellNode.selectEnd();\n    }\n    return true;\n  }\n  return false;\n}\nfunction stopEvent(event) {\n  event.preventDefault();\n  event.stopImmediatePropagation();\n  event.stopPropagation();\n}\nfunction isTypeaheadMenuInView(editor) {\n  // There is no inbuilt way to check if the component picker is in view\n  // but we can check if the root DOM element has the aria-controls attribute \"typeahead-menu\".\n  const root = editor.getRootElement();\n  if (!root) {\n    return false;\n  }\n  return root.hasAttribute('aria-controls') && root.getAttribute('aria-controls') === 'typeahead-menu';\n}\nfunction $insertParagraphAtTableEdge(edgePosition, tableNode, children) {\n  const paragraphNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)();\n  if (edgePosition === 'first') {\n    tableNode.insertBefore(paragraphNode);\n  } else {\n    tableNode.insertAfter(paragraphNode);\n  }\n  paragraphNode.append(...(children || []));\n  paragraphNode.selectEnd();\n}\nfunction $getTableEdgeCursorPosition(editor, selection, tableNode) {\n  const tableNodeParent = tableNode.getParent();\n  if (!tableNodeParent) {\n    return undefined;\n  }\n\n  // TODO: Add support for nested tables\n  const domSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.getDOMSelection)(getEditorWindow(editor));\n  if (!domSelection) {\n    return undefined;\n  }\n  const domAnchorNode = domSelection.anchorNode;\n  const tableNodeParentDOM = editor.getElementByKey(tableNodeParent.getKey());\n  const tableElement = getTableElement(tableNode, editor.getElementByKey(tableNode.getKey()));\n  // We are only interested in the scenario where the\n  // native selection anchor is:\n  // - at or inside the table's parent DOM\n  // - and NOT at or inside the table DOM\n  // It may be adjacent to the table DOM (e.g. in a wrapper)\n  if (!domAnchorNode || !tableNodeParentDOM || !tableElement || !tableNodeParentDOM.contains(domAnchorNode) || tableElement.contains(domAnchorNode)) {\n    return undefined;\n  }\n  const anchorCellNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(selection.anchor.getNode(), n => $isTableCellNode(n));\n  if (!anchorCellNode) {\n    return undefined;\n  }\n  const parentTable = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(anchorCellNode, n => $isTableNode(n));\n  if (!$isTableNode(parentTable) || !parentTable.is(tableNode)) {\n    return undefined;\n  }\n  const [tableMap, cellValue] = $computeTableMap(tableNode, anchorCellNode, anchorCellNode);\n  const firstCell = tableMap[0][0];\n  const lastCell = tableMap[tableMap.length - 1][tableMap[0].length - 1];\n  const {\n    startRow,\n    startColumn\n  } = cellValue;\n  const isAtFirstCell = startRow === firstCell.startRow && startColumn === firstCell.startColumn;\n  const isAtLastCell = startRow === lastCell.startRow && startColumn === lastCell.startColumn;\n  if (isAtFirstCell) {\n    return 'first';\n  } else if (isAtLastCell) {\n    return 'last';\n  } else {\n    return undefined;\n  }\n}\nfunction $getObserverCellFromCellNodeOrThrow(tableObserver, tableCellNode) {\n  const {\n    tableNode\n  } = tableObserver.$lookup();\n  const currentCords = tableNode.getCordsFromCellNode(tableCellNode, tableObserver.table);\n  return tableNode.getDOMCellFromCordsOrThrow(currentCords.x, currentCords.y, tableObserver.table);\n}\nfunction $getNearestTableCellInTableFromDOMNode(tableNode, startingDOM, editorState) {\n  return $findParentTableCellNodeInTable(tableNode, (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(startingDOM, editorState));\n}\n\nfunction isHTMLDivElement(element) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) && element.nodeName === 'DIV';\n}\nfunction updateColgroup(dom, config, colCount, colWidths) {\n  const colGroup = dom.querySelector('colgroup');\n  if (!colGroup) {\n    return;\n  }\n  const cols = [];\n  for (let i = 0; i < colCount; i++) {\n    const col = document.createElement('col');\n    const width = colWidths && colWidths[i];\n    if (width) {\n      col.style.width = `${width}px`;\n    }\n    cols.push(col);\n  }\n  colGroup.replaceChildren(...cols);\n}\nfunction setRowStriping(dom, config, rowStriping) {\n  if (rowStriping) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableRowStriping);\n    dom.setAttribute('data-lexical-row-striping', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableRowStriping);\n    dom.removeAttribute('data-lexical-row-striping');\n  }\n}\nfunction setFrozenColumns(dom, tableElement, config, frozenColumnCount) {\n  if (frozenColumnCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.setAttribute('data-lexical-frozen-column', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenColumn);\n    tableElement.removeAttribute('data-lexical-frozen-column');\n  }\n}\nfunction setFrozenRows(dom, tableElement, config, frozenRowCount) {\n  if (frozenRowCount > 0) {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, config.theme.tableFrozenRow);\n    tableElement.setAttribute('data-lexical-frozen-row', 'true');\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, config.theme.tableFrozenRow);\n    tableElement.removeAttribute('data-lexical-frozen-row');\n  }\n}\nfunction alignTableElement(dom, config, formatType) {\n  if (!config.theme.tableAlignment) {\n    return;\n  }\n  const removeClasses = [];\n  const addClasses = [];\n  for (const format of ['center', 'right']) {\n    const classes = config.theme.tableAlignment[format];\n    if (!classes) {\n      continue;\n    }\n    (format === formatType ? addClasses : removeClasses).push(classes);\n  }\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.removeClassNamesFromElement)(dom, ...removeClasses);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(dom, ...addClasses);\n}\nconst scrollableEditors = new WeakSet();\nfunction $isScrollableTablesActive(editor = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getEditor)()) {\n  return scrollableEditors.has(editor);\n}\nfunction setScrollableTablesActive(editor, active) {\n  if (active) {\n    if (!editor._config.theme.tableScrollableWrapper) {\n      console.warn('TableNode: hasHorizontalScroll is active but theme.tableScrollableWrapper is not defined.');\n    }\n    scrollableEditors.add(editor);\n  } else {\n    scrollableEditors.delete(editor);\n  }\n}\n\n/** @noInheritDoc */\nclass TableNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  static getType() {\n    return 'table';\n  }\n  getColWidths() {\n    const self = this.getLatest();\n    return self.__colWidths;\n  }\n  setColWidths(colWidths) {\n    const self = this.getWritable();\n    // NOTE: Node properties should be immutable. Freeze to prevent accidental mutation.\n    self.__colWidths = colWidths !== undefined && true ? Object.freeze(colWidths) : colWidths;\n    return self;\n  }\n  static clone(node) {\n    return new TableNode(node.__key);\n  }\n  afterCloneFrom(prevNode) {\n    super.afterCloneFrom(prevNode);\n    this.__colWidths = prevNode.__colWidths;\n    this.__rowStriping = prevNode.__rowStriping;\n    this.__frozenColumnCount = prevNode.__frozenColumnCount;\n    this.__frozenRowCount = prevNode.__frozenRowCount;\n  }\n  static importDOM() {\n    return {\n      table: _node => ({\n        conversion: $convertTableElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createTableNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setRowStriping(serializedNode.rowStriping || false).setFrozenColumns(serializedNode.frozenColumnCount || 0).setFrozenRows(serializedNode.frozenRowCount || 0).setColWidths(serializedNode.colWidths);\n  }\n  constructor(key) {\n    super(key);\n    this.__rowStriping = false;\n    this.__frozenColumnCount = 0;\n    this.__frozenRowCount = 0;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      colWidths: this.getColWidths(),\n      frozenColumnCount: this.__frozenColumnCount ? this.__frozenColumnCount : undefined,\n      frozenRowCount: this.__frozenRowCount ? this.__frozenRowCount : undefined,\n      rowStriping: this.__rowStriping ? this.__rowStriping : undefined\n    };\n  }\n  extractWithChild(child, selection, destination) {\n    return destination === 'html';\n  }\n  getDOMSlot(element) {\n    const tableElement = !isHTMLTableElement(element) ? element.querySelector('table') : element;\n    if (!isHTMLTableElement(tableElement)) {\n      formatDevErrorMessage(`TableNode.getDOMSlot: createDOM() did not return a table`);\n    }\n    return super.getDOMSlot(element).withElement(tableElement).withAfter(tableElement.querySelector('colgroup'));\n  }\n  createDOM(config, editor) {\n    const tableElement = document.createElement('table');\n    if (this.__style) {\n      tableElement.style.cssText = this.__style;\n    }\n    const colGroup = document.createElement('colgroup');\n    tableElement.appendChild(colGroup);\n    (0,lexical__WEBPACK_IMPORTED_MODULE_0__.setDOMUnmanaged)(colGroup);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(tableElement, config.theme.table);\n    this.updateTableElement(null, tableElement, config);\n    if ($isScrollableTablesActive(editor)) {\n      const wrapperElement = document.createElement('div');\n      const classes = config.theme.tableScrollableWrapper;\n      if (classes) {\n        (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(wrapperElement, classes);\n      } else {\n        wrapperElement.style.cssText = 'overflow-x: auto;';\n      }\n      wrapperElement.appendChild(tableElement);\n      this.updateTableWrapper(null, wrapperElement, tableElement, config);\n      return wrapperElement;\n    }\n    return tableElement;\n  }\n  updateTableWrapper(prevNode, tableWrapper, tableElement, config) {\n    if (this.__frozenColumnCount !== (prevNode ? prevNode.__frozenColumnCount : 0)) {\n      setFrozenColumns(tableWrapper, tableElement, config, this.__frozenColumnCount);\n    }\n    if (this.__frozenRowCount !== (prevNode ? prevNode.__frozenRowCount : 0)) {\n      setFrozenRows(tableWrapper, tableElement, config, this.__frozenRowCount);\n    }\n  }\n  updateTableElement(prevNode, tableElement, config) {\n    if (this.__style !== (prevNode ? prevNode.__style : '')) {\n      tableElement.style.cssText = this.__style;\n    }\n    if (this.__rowStriping !== (prevNode ? prevNode.__rowStriping : false)) {\n      setRowStriping(tableElement, config, this.__rowStriping);\n    }\n    updateColgroup(tableElement, config, this.getColumnCount(), this.getColWidths());\n    alignTableElement(tableElement, config, this.getFormatType());\n  }\n  updateDOM(prevNode, dom, config) {\n    const slot = this.getDOMSlot(dom);\n    const tableElement = slot.element;\n    if (dom === tableElement === $isScrollableTablesActive()) {\n      return true;\n    }\n    if (isHTMLDivElement(dom)) {\n      this.updateTableWrapper(prevNode, dom, tableElement, config);\n    }\n    this.updateTableElement(prevNode, tableElement, config);\n    return false;\n  }\n  exportDOM(editor) {\n    const superExport = super.exportDOM(editor);\n    const {\n      element\n    } = superExport;\n    return {\n      after: tableElement => {\n        if (superExport.after) {\n          tableElement = superExport.after(tableElement);\n        }\n        if (!isHTMLTableElement(tableElement) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(tableElement)) {\n          tableElement = tableElement.querySelector('table');\n        }\n        if (!isHTMLTableElement(tableElement)) {\n          return null;\n        }\n        alignTableElement(tableElement, editor._config, this.getFormatType());\n\n        // Scan the table map to build a map of table cell key to the columns it needs\n        const [tableMap] = $computeTableMapSkipCellCheck(this, null, null);\n        const cellValues = new Map();\n        for (const mapRow of tableMap) {\n          for (const mapValue of mapRow) {\n            const key = mapValue.cell.getKey();\n            if (!cellValues.has(key)) {\n              cellValues.set(key, {\n                colSpan: mapValue.cell.getColSpan(),\n                startColumn: mapValue.startColumn\n              });\n            }\n          }\n        }\n\n        // scan the DOM to find the table cell keys that were used and mark those columns\n        const knownColumns = new Set();\n        for (const cellDOM of tableElement.querySelectorAll(':scope > tr > [data-temporary-table-cell-lexical-key]')) {\n          const key = cellDOM.getAttribute('data-temporary-table-cell-lexical-key');\n          if (key) {\n            const cellSpan = cellValues.get(key);\n            cellDOM.removeAttribute('data-temporary-table-cell-lexical-key');\n            if (cellSpan) {\n              cellValues.delete(key);\n              for (let i = 0; i < cellSpan.colSpan; i++) {\n                knownColumns.add(i + cellSpan.startColumn);\n              }\n            }\n          }\n        }\n\n        // Compute the colgroup and columns in the export\n        const colGroup = tableElement.querySelector(':scope > colgroup');\n        if (colGroup) {\n          // Only include the <col /> for rows that are in the output\n          const cols = Array.from(tableElement.querySelectorAll(':scope > colgroup > col')).filter((dom, i) => knownColumns.has(i));\n          colGroup.replaceChildren(...cols);\n        }\n\n        // Wrap direct descendant rows in a tbody for export\n        const rows = tableElement.querySelectorAll(':scope > tr');\n        if (rows.length > 0) {\n          const tBody = document.createElement('tbody');\n          for (const row of rows) {\n            tBody.appendChild(row);\n          }\n          tableElement.append(tBody);\n        }\n        return tableElement;\n      },\n      element: !isHTMLTableElement(element) && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) ? element.querySelector('table') : element\n    };\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isShadowRoot() {\n    return true;\n  }\n  getCordsFromCellNode(tableCellNode, table) {\n    const {\n      rows,\n      domRows\n    } = table;\n    for (let y = 0; y < rows; y++) {\n      const row = domRows[y];\n      if (row == null) {\n        continue;\n      }\n      for (let x = 0; x < row.length; x++) {\n        const cell = row[x];\n        if (cell == null) {\n          continue;\n        }\n        const {\n          elem\n        } = cell;\n        const cellNode = $getNearestTableCellInTableFromDOMNode(this, elem);\n        if (cellNode !== null && tableCellNode.is(cellNode)) {\n          return {\n            x,\n            y\n          };\n        }\n      }\n    }\n    throw new Error('Cell not found in table.');\n  }\n  getDOMCellFromCords(x, y, table) {\n    const {\n      domRows\n    } = table;\n    const row = domRows[y];\n    if (row == null) {\n      return null;\n    }\n    const index = x < row.length ? x : row.length - 1;\n    const cell = row[index];\n    if (cell == null) {\n      return null;\n    }\n    return cell;\n  }\n  getDOMCellFromCordsOrThrow(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (!cell) {\n      throw new Error('Cell not found at cords.');\n    }\n    return cell;\n  }\n  getCellNodeFromCords(x, y, table) {\n    const cell = this.getDOMCellFromCords(x, y, table);\n    if (cell == null) {\n      return null;\n    }\n    const node = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(cell.elem);\n    if ($isTableCellNode(node)) {\n      return node;\n    }\n    return null;\n  }\n  getCellNodeFromCordsOrThrow(x, y, table) {\n    const node = this.getCellNodeFromCords(x, y, table);\n    if (!node) {\n      throw new Error('Node at cords not TableCellNode.');\n    }\n    return node;\n  }\n  getRowStriping() {\n    return Boolean(this.getLatest().__rowStriping);\n  }\n  setRowStriping(newRowStriping) {\n    const self = this.getWritable();\n    self.__rowStriping = newRowStriping;\n    return self;\n  }\n  setFrozenColumns(columnCount) {\n    const self = this.getWritable();\n    self.__frozenColumnCount = columnCount;\n    return self;\n  }\n  getFrozenColumns() {\n    return this.getLatest().__frozenColumnCount;\n  }\n  setFrozenRows(rowCount) {\n    const self = this.getWritable();\n    self.__frozenRowCount = rowCount;\n    return self;\n  }\n  getFrozenRows() {\n    return this.getLatest().__frozenRowCount;\n  }\n  canSelectBefore() {\n    return true;\n  }\n  canIndent() {\n    return false;\n  }\n  getColumnCount() {\n    const firstRow = this.getFirstChild();\n    if (!firstRow) {\n      return 0;\n    }\n    let columnCount = 0;\n    firstRow.getChildren().forEach(cell => {\n      if ($isTableCellNode(cell)) {\n        columnCount += cell.getColSpan();\n      }\n    });\n    return columnCount;\n  }\n}\nfunction $getElementForTableNode(editor, tableNode) {\n  const tableElement = editor.getElementByKey(tableNode.getKey());\n  if (!(tableElement !== null)) {\n    formatDevErrorMessage(`$getElementForTableNode: Table Element Not Found`);\n  }\n  return getTable(tableNode, tableElement);\n}\nfunction $convertTableElement(domNode) {\n  const tableNode = $createTableNode();\n  if (domNode.hasAttribute('data-lexical-row-striping')) {\n    tableNode.setRowStriping(true);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-column')) {\n    tableNode.setFrozenColumns(1);\n  }\n  if (domNode.hasAttribute('data-lexical-frozen-row')) {\n    tableNode.setFrozenRows(1);\n  }\n  const colGroup = domNode.querySelector(':scope > colgroup');\n  if (colGroup) {\n    let columns = [];\n    for (const col of colGroup.querySelectorAll(':scope > col')) {\n      let width = col.style.width || '';\n      if (!PIXEL_VALUE_REG_EXP.test(width)) {\n        // Also support deprecated width attribute for google docs\n        width = col.getAttribute('width') || '';\n        if (!/^\\d+$/.test(width)) {\n          columns = undefined;\n          break;\n        }\n      }\n      columns.push(parseFloat(width));\n    }\n    if (columns) {\n      tableNode.setColWidths(columns);\n    }\n  }\n  return {\n    after: children => (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$descendantsMatching)(children, $isTableRowNode),\n    node: tableNode\n  };\n}\nfunction $createTableNode() {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new TableNode());\n}\nfunction $isTableNode(node) {\n  return node instanceof TableNode;\n}\n\nfunction $insertTableCommandListener({\n  rows,\n  columns,\n  includeHeaders\n}) {\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)() || (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getPreviousSelection)();\n  if (!selection || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n    return false;\n  }\n\n  // Prevent nested tables by checking if we're already inside a table\n  if ($findTableNode(selection.anchor.getNode())) {\n    return false;\n  }\n  const tableNode = $createTableNodeWithDimensions(Number(rows), Number(columns), includeHeaders);\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertNodeToNearestRoot)(tableNode);\n  const firstDescendant = tableNode.getFirstDescendant();\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(firstDescendant)) {\n    firstDescendant.select();\n  }\n  return true;\n}\nfunction $tableCellTransform(node) {\n  if (!$isTableRowNode(node.getParent())) {\n    // TableCellNode must be a child of TableRowNode.\n    node.remove();\n  } else if (node.isEmpty()) {\n    // TableCellNode should never be empty\n    node.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n  }\n}\nfunction $tableRowTransform(node) {\n  if (!$isTableNode(node.getParent())) {\n    // TableRowNode must be a child of TableNode.\n    // TODO: Future support of tbody/thead/tfoot may change this\n    node.remove();\n  } else {\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableCellNode);\n  }\n}\nfunction $tableTransform(node) {\n  // TableRowNode is the only valid child for TableNode\n  // TODO: Future support of tbody/thead/tfoot/caption may change this\n  (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$unwrapAndFilterDescendants)(node, $isTableRowNode);\n  const [gridMap] = $computeTableMapSkipCellCheck(node, null, null);\n  const maxRowLength = gridMap.reduce((curLength, row) => {\n    return Math.max(curLength, row.length);\n  }, 0);\n  const rowNodes = node.getChildren();\n  for (let i = 0; i < gridMap.length; ++i) {\n    const rowNode = rowNodes[i];\n    if (!rowNode) {\n      continue;\n    }\n    if (!$isTableRowNode(rowNode)) {\n      formatDevErrorMessage(`TablePlugin: Expecting all children of TableNode to be TableRowNode, found ${rowNode.constructor.name} (type ${rowNode.getType()})`);\n    }\n    const rowLength = gridMap[i].reduce((acc, cell) => cell ? 1 + acc : acc, 0);\n    if (rowLength === maxRowLength) {\n      continue;\n    }\n    for (let j = rowLength; j < maxRowLength; ++j) {\n      // TODO: inherit header state from another header or body\n      const newCell = $createTableCellNode();\n      newCell.append((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createParagraphNode)());\n      rowNode.append(newCell);\n    }\n  }\n}\nfunction $tableClickCommand(event) {\n  if (event.detail < 3 || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.isDOMNode)(event.target)) {\n    return false;\n  }\n  const startNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getNearestNodeFromDOMNode)(event.target);\n  if (startNode === null) {\n    return false;\n  }\n  const blockNode = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(startNode, node => (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node) && !node.isInline());\n  if (blockNode === null) {\n    return false;\n  }\n  const rootNode = blockNode.getParent();\n  if (!$isTableCellNode(rootNode)) {\n    return false;\n  }\n  blockNode.select(0);\n  return true;\n}\n\n/**\n * Register a transform to ensure that all TableCellNode have a colSpan and rowSpan of 1.\n * This should only be registered when you do not want to support merged cells.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTableCellUnmergeTransform(editor) {\n  return editor.registerNodeTransform(TableCellNode, node => {\n    if (node.getColSpan() > 1 || node.getRowSpan() > 1) {\n      // When we have rowSpan we have to map the entire Table to understand where the new Cells\n      // fit best; let's analyze all Cells at once to save us from further transform iterations\n      const [,, gridNode] = $getNodeTriplet(node);\n      const [gridMap] = $computeTableMap(gridNode, node, node);\n      // TODO this function expects Tables to be normalized. Look into this once it exists\n      const rowsCount = gridMap.length;\n      const columnsCount = gridMap[0].length;\n      let row = gridNode.getFirstChild();\n      if (!$isTableRowNode(row)) {\n        formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n      }\n      const unmerged = [];\n      for (let i = 0; i < rowsCount; i++) {\n        if (i !== 0) {\n          row = row.getNextSibling();\n          if (!$isTableRowNode(row)) {\n            formatDevErrorMessage(`Expected TableNode first child to be a RowNode`);\n          }\n        }\n        let lastRowCell = null;\n        for (let j = 0; j < columnsCount; j++) {\n          const cellMap = gridMap[i][j];\n          const cell = cellMap.cell;\n          if (cellMap.startRow === i && cellMap.startColumn === j) {\n            lastRowCell = cell;\n            unmerged.push(cell);\n          } else if (cell.getColSpan() > 1 || cell.getRowSpan() > 1) {\n            if (!$isTableCellNode(cell)) {\n              formatDevErrorMessage(`Expected TableNode cell to be a TableCellNode`);\n            }\n            const newCell = $createTableCellNode(cell.__headerState);\n            if (lastRowCell !== null) {\n              lastRowCell.insertAfter(newCell);\n            } else {\n              (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$insertFirst)(row, newCell);\n            }\n          }\n        }\n      }\n      for (const cell of unmerged) {\n        cell.setColSpan(1);\n        cell.setRowSpan(1);\n      }\n    }\n  });\n}\nfunction registerTableSelectionObserver(editor, hasTabHandler = true) {\n  const tableSelections = new Map();\n  const initializeTableNode = (tableNode, nodeKey, dom) => {\n    const tableElement = getTableElement(tableNode, dom);\n    const tableSelection = applyTableHandlers(tableNode, tableElement, editor, hasTabHandler);\n    tableSelections.set(nodeKey, [tableSelection, tableElement]);\n  };\n  const unregisterMutationListener = editor.registerMutationListener(TableNode, nodeMutations => {\n    editor.getEditorState().read(() => {\n      for (const [nodeKey, mutation] of nodeMutations) {\n        const tableSelection = tableSelections.get(nodeKey);\n        if (mutation === 'created' || mutation === 'updated') {\n          const {\n            tableNode,\n            tableElement\n          } = $getTableAndElementByKey(nodeKey);\n          if (tableSelection === undefined) {\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          } else if (tableElement !== tableSelection[1]) {\n            // The update created a new DOM node, destroy the existing TableObserver\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n            initializeTableNode(tableNode, nodeKey, tableElement);\n          }\n        } else if (mutation === 'destroyed') {\n          if (tableSelection !== undefined) {\n            tableSelection[0].removeListeners();\n            tableSelections.delete(nodeKey);\n          }\n        }\n      }\n    }, {\n      editor\n    });\n  }, {\n    skipInitialization: false\n  });\n  return () => {\n    unregisterMutationListener();\n    // Hook might be called multiple times so cleaning up tables listeners as well,\n    // as it'll be reinitialized during recurring call\n    for (const [, [tableSelection]] of tableSelections) {\n      tableSelection.removeListeners();\n    }\n  };\n}\n\n/**\n * Register the INSERT_TABLE_COMMAND listener and the table integrity transforms. The\n * table selection observer should be registered separately after this with\n * {@link registerTableSelectionObserver}.\n *\n * @param editor The editor\n * @returns An unregister callback\n */\nfunction registerTablePlugin(editor) {\n  if (!editor.hasNodes([TableNode])) {\n    {\n      formatDevErrorMessage(`TablePlugin: TableNode is not registered on editor`);\n    }\n  }\n  return (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.mergeRegister)(editor.registerCommand(INSERT_TABLE_COMMAND, $insertTableCommandListener, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.SELECTION_INSERT_CLIPBOARD_NODES_COMMAND, ({\n    nodes,\n    selection\n  }, dispatchEditor) => {\n    if (editor !== dispatchEditor || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const isInsideTableCell = $findTableNode(selection.anchor.getNode()) !== null;\n    return isInsideTableCell && nodes.some($isTableNode);\n  }, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical__WEBPACK_IMPORTED_MODULE_0__.CLICK_COMMAND, $tableClickCommand, lexical__WEBPACK_IMPORTED_MODULE_0__.COMMAND_PRIORITY_EDITOR), editor.registerNodeTransform(TableNode, $tableTransform), editor.registerNodeTransform(TableRowNode, $tableRowTransform), editor.registerNodeTransform(TableCellNode, $tableCellTransform));\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTJSO0FBQ29nQztBQUMxc0M7O0FBRXJGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBVztBQUN2Qzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGFBQWE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLHNFQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsc0RBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdDQUFnQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsdURBQXVELEdBQUc7QUFDMUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sNkJBQTZCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxxREFBWSx5REFBeUQscURBQVk7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx5REFBZ0I7QUFDMUI7QUFDQTtBQUNBLEtBQUs7QUFDTCx1QkFBdUIsd0RBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0Esc0JBQXNCLDBFQUFpQztBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FB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QUFDUCwrQ0FBK0Msc0RBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG1FQUEwQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQixzREFBYSxNQUFNLDhEQUFxQjtBQUM1RCxxQkFBcUIsMERBQWlCO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsd0VBQXdCO0FBQzFCO0FBQ0EsTUFBTSxvREFBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsZ0JBQWdCLDZEQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixJQUFJLDJFQUEyQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSwyRUFBMkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esa0JBQWtCLG9CQUFvQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHLDBCQUEwQixRQUFRLGtCQUFrQjtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0EscUJBQXFCLDZEQUFvQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtEQUFTO0FBQ3BDO0FBQ0E7QUFDQSxvQkFBb0IsbUVBQTBCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtRUFBbUIsb0JBQW9CLHVEQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsY0FBYyw0REFBYztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUkscUNBQXFDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw2REFBYSwyRUFBMkUsNERBQXVCLDBCQUEwQiw2RUFBd0M7QUFDMUw7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQ0FBc0MsMERBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxFQUFFLDREQUF1QiwwQkFBMEIsa0RBQWEsc0JBQXNCLDREQUF1QjtBQUNoSDs7QUFFdXZDIiwic291cmNlcyI6WyIvVXNlcnMvbWFjL1N5bmMvcHJvamVjdC9lY29tbWVyY2Uvc2hvcHNhYXMvaHRtbGNvbnZlcnRlci9wYXlsb2Fkc2Fhcy9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGFibGVAMC4zNS4wL25vZGVfbW9kdWxlcy9AbGV4aWNhbC90YWJsZS9MZXhpY2FsVGFibGUuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsICRkZXNjZW5kYW50c01hdGNoaW5nLCAkZmluZE1hdGNoaW5nUGFyZW50LCByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQsIG9iamVjdEtsYXNzRXF1YWxzLCBpc0hUTUxFbGVtZW50IGFzIGlzSFRNTEVsZW1lbnQkMSwgJGluc2VydEZpcnN0IGFzICRpbnNlcnRGaXJzdCQxLCBtZXJnZVJlZ2lzdGVyLCAkaW5zZXJ0Tm9kZVRvTmVhcmVzdFJvb3QsICR1bndyYXBBbmRGaWx0ZXJEZXNjZW5kYW50cyB9IGZyb20gJ0BsZXhpY2FsL3V0aWxzJztcbmltcG9ydCB7IEVsZW1lbnROb2RlLCBpc0hUTUxFbGVtZW50LCAkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlLCAkaXNUZXh0Tm9kZSwgJGlzTGluZUJyZWFrTm9kZSwgJGNyZWF0ZVBhcmFncmFwaE5vZGUsICRhcHBseU5vZGVSZXBsYWNlbWVudCwgY3JlYXRlQ29tbWFuZCwgJGNyZWF0ZVRleHROb2RlLCAkZ2V0U2VsZWN0aW9uLCAkaXNSYW5nZVNlbGVjdGlvbiwgJGlzUGFyYWdyYXBoTm9kZSwgJGNyZWF0ZVBvaW50LCAkaXNFbGVtZW50Tm9kZSwgJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMLCBpc0N1cnJlbnRseVJlYWRPbmx5TW9kZSwgVEVYVF9UWVBFX1RPX0ZPUk1BVCwgJGdldE5vZGVCeUtleSwgJGdldEVkaXRvciwgJHNldFNlbGVjdGlvbiwgU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCBnZXRET01TZWxlY3Rpb24sICRjcmVhdGVSYW5nZVNlbGVjdGlvbiwgJGlzUm9vdE5vZGUsIElOU0VSVF9QQVJBR1JBUEhfQ09NTUFORCwgQ09NTUFORF9QUklPUklUWV9ISUdILCBLRVlfRVNDQVBFX0NPTU1BTkQsIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwsIENVVF9DT01NQU5ELCBGT1JNQVRfVEVYVF9DT01NQU5ELCBGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIEtFWV9UQUJfQ09NTUFORCwgRk9DVVNfQ09NTUFORCwgU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgJGdldFByZXZpb3VzU2VsZWN0aW9uLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZSwgJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbSwgJGlzUm9vdE9yU2hhZG93Um9vdCwgS0VZX0FSUk9XX0RPV05fQ09NTUFORCwgS0VZX0FSUk9XX1VQX0NPTU1BTkQsIEtFWV9BUlJPV19MRUZUX0NPTU1BTkQsIEtFWV9BUlJPV19SSUdIVF9DT01NQU5ELCBERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkQsIEtFWV9CQUNLU1BBQ0VfQ09NTUFORCwgS0VZX0RFTEVURV9DT01NQU5ELCBpc0RPTU5vZGUsICRjYXJldEZyb21Qb2ludCwgJGlzRXh0ZW5kYWJsZVRleHRQb2ludENhcmV0LCAkZXh0ZW5kQ2FyZXRUb1JhbmdlLCAkaXNTaWJsaW5nQ2FyZXQsICRnZXRTaWJsaW5nQ2FyZXQsICRzZXRQb2ludEZyb21DYXJldCwgJG5vcm1hbGl6ZUNhcmV0LCAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0LCAkaXNDaGlsZENhcmV0LCAkZ2V0Q2hpbGRDYXJldCwgc2V0RE9NVW5tYW5hZ2VkLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiwgQ0xJQ0tfQ09NTUFORCB9IGZyb20gJ2xleGljYWwnO1xuaW1wb3J0IHsgY29weVRvQ2xpcGJvYXJkLCAkZ2V0Q2xpcGJvYXJkRGF0YUZyb21TZWxlY3Rpb24gfSBmcm9tICdAbGV4aWNhbC9jbGlwYm9hcmQnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IFBJWEVMX1ZBTFVFX1JFR19FWFAgPSAvXihcXGQrKD86XFwuXFxkKyk/KXB4JC87XG5cbi8vIC5QbGF5Z3JvdW5kRWRpdG9yVGhlbWVfX3RhYmxlQ2VsbCB3aWR0aCB2YWx1ZSBmcm9tXG4vLyBwYWNrYWdlcy9sZXhpY2FsLXBsYXlncm91bmQvc3JjL3RoZW1lcy9QbGF5Z3JvdW5kRWRpdG9yVGhlbWUuY3NzXG5jb25zdCBDT0xVTU5fV0lEVEggPSA3NTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMgPSB7XG4gIEJPVEg6IDMsXG4gIENPTFVNTjogMixcbiAgTk9fU1RBVFVTOiAwLFxuICBST1c6IDFcbn07XG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVDZWxsTm9kZSBleHRlbmRzIEVsZW1lbnROb2RlIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZWNlbGwnO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZUNlbGxOb2RlKG5vZGUuX19oZWFkZXJTdGF0ZSwgbm9kZS5fX2NvbFNwYW4sIG5vZGUuX193aWR0aCwgbm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20obm9kZSkge1xuICAgIHN1cGVyLmFmdGVyQ2xvbmVGcm9tKG5vZGUpO1xuICAgIHRoaXMuX19yb3dTcGFuID0gbm9kZS5fX3Jvd1NwYW47XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG5vZGUuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSBub2RlLl9fdmVydGljYWxBbGlnbjtcbiAgfVxuICBzdGF0aWMgaW1wb3J0RE9NKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSksXG4gICAgICB0aDogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZUNlbGxOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRIZWFkZXJTdHlsZXMoc2VyaWFsaXplZE5vZGUuaGVhZGVyU3RhdGUpLnNldENvbFNwYW4oc2VyaWFsaXplZE5vZGUuY29sU3BhbiB8fCAxKS5zZXRSb3dTcGFuKHNlcmlhbGl6ZWROb2RlLnJvd1NwYW4gfHwgMSkuc2V0V2lkdGgoc2VyaWFsaXplZE5vZGUud2lkdGggfHwgdW5kZWZpbmVkKS5zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VyaWFsaXplZE5vZGUuYmFja2dyb3VuZENvbG9yIHx8IG51bGwpLnNldFZlcnRpY2FsQWxpZ24oc2VyaWFsaXplZE5vZGUudmVydGljYWxBbGlnbiB8fCB1bmRlZmluZWQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoLCBrZXkpIHtcbiAgICBzdXBlcihrZXkpO1xuICAgIHRoaXMuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICB0aGlzLl9fcm93U3BhbiA9IDE7XG4gICAgdGhpcy5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGU7XG4gICAgdGhpcy5fX3dpZHRoID0gd2lkdGg7XG4gICAgdGhpcy5fX2JhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgdGhpcy5fX3ZlcnRpY2FsQWxpZ24gPSB1bmRlZmluZWQ7XG4gIH1cbiAgY3JlYXRlRE9NKGNvbmZpZykge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMuZ2V0VGFnKCkpO1xuICAgIGlmICh0aGlzLl9fd2lkdGgpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLl9fd2lkdGh9cHhgO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICBlbGVtZW50LmNvbFNwYW4gPSB0aGlzLl9fY29sU3BhbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgZWxlbWVudC5yb3dTcGFuID0gdGhpcy5fX3Jvd1NwYW47XG4gICAgfVxuICAgIGlmICh0aGlzLl9fYmFja2dyb3VuZENvbG9yICE9PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IHRoaXMuX19iYWNrZ3JvdW5kQ29sb3I7XG4gICAgfVxuICAgIGlmIChpc1ZhbGlkVmVydGljYWxBbGlnbih0aGlzLl9fdmVydGljYWxBbGlnbikpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICAgIH1cbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZUNlbGwsIHRoaXMuaGFzSGVhZGVyKCkgJiYgY29uZmlnLnRoZW1lLnRhYmxlQ2VsbEhlYWRlcik7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgZXhwb3J0RE9NKGVkaXRvcikge1xuICAgIGNvbnN0IG91dHB1dCA9IHN1cGVyLmV4cG9ydERPTShlZGl0b3IpO1xuICAgIGlmIChpc0hUTUxFbGVtZW50KG91dHB1dC5lbGVtZW50KSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IG91dHB1dC5lbGVtZW50O1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXknLCB0aGlzLmdldEtleSgpKTtcbiAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCBibGFjayc7XG4gICAgICBpZiAodGhpcy5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgIGVsZW1lbnQuY29sU3BhbiA9IHRoaXMuX19jb2xTcGFuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBlbGVtZW50LnJvd1NwYW4gPSB0aGlzLl9fcm93U3BhbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHt0aGlzLmdldFdpZHRoKCkgfHwgQ09MVU1OX1dJRFRIfXB4YDtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IHRoaXMuZ2V0VmVydGljYWxBbGlnbigpIHx8ICd0b3AnO1xuICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSAnc3RhcnQnO1xuICAgICAgaWYgKHRoaXMuX19iYWNrZ3JvdW5kQ29sb3IgPT09IG51bGwgJiYgdGhpcy5oYXNIZWFkZXIoKSkge1xuICAgICAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjZjJmM2Y1JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICAuLi4oaXNWYWxpZFZlcnRpY2FsQWxpZ24odGhpcy5fX3ZlcnRpY2FsQWxpZ24pICYmIHtcbiAgICAgICAgdmVydGljYWxBbGlnbjogdGhpcy5fX3ZlcnRpY2FsQWxpZ25cbiAgICAgIH0pLFxuICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGlzLmdldEJhY2tncm91bmRDb2xvcigpLFxuICAgICAgY29sU3BhbjogdGhpcy5fX2NvbFNwYW4sXG4gICAgICBoZWFkZXJTdGF0ZTogdGhpcy5fX2hlYWRlclN0YXRlLFxuICAgICAgcm93U3BhbjogdGhpcy5fX3Jvd1NwYW4sXG4gICAgICB3aWR0aDogdGhpcy5nZXRXaWR0aCgpXG4gICAgfTtcbiAgfVxuICBnZXRDb2xTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fY29sU3BhbjtcbiAgfVxuICBzZXRDb2xTcGFuKGNvbFNwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19jb2xTcGFuID0gY29sU3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRSb3dTcGFuKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fcm93U3BhbjtcbiAgfVxuICBzZXRSb3dTcGFuKHJvd1NwYW4pIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19yb3dTcGFuID0gcm93U3BhbjtcbiAgICByZXR1cm4gc2VsZjtcbiAgfVxuICBnZXRUYWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzSGVhZGVyKCkgPyAndGgnIDogJ3RkJztcbiAgfVxuICBzZXRIZWFkZXJTdHlsZXMoaGVhZGVyU3RhdGUsIG1hc2sgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQk9USCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2hlYWRlclN0YXRlID0gaGVhZGVyU3RhdGUgJiBtYXNrIHwgc2VsZi5fX2hlYWRlclN0YXRlICYgfm1hc2s7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVhZGVyU3R5bGVzKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVhZGVyU3RhdGU7XG4gIH1cbiAgc2V0V2lkdGgod2lkdGgpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX193aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldFdpZHRoKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fd2lkdGg7XG4gIH1cbiAgZ2V0QmFja2dyb3VuZENvbG9yKCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9fYmFja2dyb3VuZENvbG9yO1xuICB9XG4gIHNldEJhY2tncm91bmRDb2xvcihuZXdCYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19iYWNrZ3JvdW5kQ29sb3IgPSBuZXdCYWNrZ3JvdW5kQ29sb3I7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0VmVydGljYWxBbGlnbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3ZlcnRpY2FsQWxpZ247XG4gIH1cbiAgc2V0VmVydGljYWxBbGlnbihuZXdWZXJ0aWNhbEFsaWduKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9fdmVydGljYWxBbGlnbiA9IG5ld1ZlcnRpY2FsQWxpZ24gfHwgdW5kZWZpbmVkO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHRvZ2dsZUhlYWRlclN0eWxlKGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIGlmICgoc2VsZi5fX2hlYWRlclN0YXRlICYgaGVhZGVyU3RhdGVUb1RvZ2dsZSkgPT09IGhlYWRlclN0YXRlVG9Ub2dnbGUpIHtcbiAgICAgIHNlbGYuX19oZWFkZXJTdGF0ZSAtPSBoZWFkZXJTdGF0ZVRvVG9nZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLl9faGVhZGVyU3RhdGUgKz0gaGVhZGVyU3RhdGVUb1RvZ2dsZTtcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgaGFzSGVhZGVyU3RhdGUoaGVhZGVyU3RhdGUpIHtcbiAgICByZXR1cm4gKHRoaXMuZ2V0SGVhZGVyU3R5bGVzKCkgJiBoZWFkZXJTdGF0ZSkgPT09IGhlYWRlclN0YXRlO1xuICB9XG4gIGhhc0hlYWRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2hlYWRlclN0YXRlICE9PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlYWRlclN0YXRlICE9PSB0aGlzLl9faGVhZGVyU3RhdGUgfHwgcHJldk5vZGUuX193aWR0aCAhPT0gdGhpcy5fX3dpZHRoIHx8IHByZXZOb2RlLl9fY29sU3BhbiAhPT0gdGhpcy5fX2NvbFNwYW4gfHwgcHJldk5vZGUuX19yb3dTcGFuICE9PSB0aGlzLl9fcm93U3BhbiB8fCBwcmV2Tm9kZS5fX2JhY2tncm91bmRDb2xvciAhPT0gdGhpcy5fX2JhY2tncm91bmRDb2xvciB8fCBwcmV2Tm9kZS5fX3ZlcnRpY2FsQWxpZ24gIT09IHRoaXMuX192ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGlzU2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb2xsYXBzZUF0U3RhcnQoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZFZlcnRpY2FsQWxpZ24odmVydGljYWxBbGlnbikge1xuICByZXR1cm4gdmVydGljYWxBbGlnbiA9PT0gJ21pZGRsZScgfHwgdmVydGljYWxBbGlnbiA9PT0gJ2JvdHRvbSc7XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlQ2VsbE5vZGVFbGVtZW50KGRvbU5vZGUpIHtcbiAgY29uc3QgZG9tTm9kZV8gPSBkb21Ob2RlO1xuICBjb25zdCBub2RlTmFtZSA9IGRvbU5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgbGV0IHdpZHRoID0gdW5kZWZpbmVkO1xuICBpZiAoUElYRUxfVkFMVUVfUkVHX0VYUC50ZXN0KGRvbU5vZGVfLnN0eWxlLndpZHRoKSkge1xuICAgIHdpZHRoID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS53aWR0aCk7XG4gIH1cbiAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKG5vZGVOYW1lID09PSAndGgnID8gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVyA6IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVMsIGRvbU5vZGVfLmNvbFNwYW4sIHdpZHRoKTtcbiAgdGFibGVDZWxsTm9kZS5fX3Jvd1NwYW4gPSBkb21Ob2RlXy5yb3dTcGFuO1xuICBjb25zdCBiYWNrZ3JvdW5kQ29sb3IgPSBkb21Ob2RlXy5zdHlsZS5iYWNrZ3JvdW5kQ29sb3I7XG4gIGlmIChiYWNrZ3JvdW5kQ29sb3IgIT09ICcnKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX2JhY2tncm91bmRDb2xvciA9IGJhY2tncm91bmRDb2xvcjtcbiAgfVxuICBjb25zdCB2ZXJ0aWNhbEFsaWduID0gZG9tTm9kZV8uc3R5bGUudmVydGljYWxBbGlnbjtcbiAgaWYgKGlzVmFsaWRWZXJ0aWNhbEFsaWduKHZlcnRpY2FsQWxpZ24pKSB7XG4gICAgdGFibGVDZWxsTm9kZS5fX3ZlcnRpY2FsQWxpZ24gPSB2ZXJ0aWNhbEFsaWduO1xuICB9XG4gIGNvbnN0IHN0eWxlID0gZG9tTm9kZV8uc3R5bGU7XG4gIGNvbnN0IHRleHREZWNvcmF0aW9uID0gKHN0eWxlICYmIHN0eWxlLnRleHREZWNvcmF0aW9uIHx8ICcnKS5zcGxpdCgnICcpO1xuICBjb25zdCBoYXNCb2xkRm9udFdlaWdodCA9IHN0eWxlLmZvbnRXZWlnaHQgPT09ICc3MDAnIHx8IHN0eWxlLmZvbnRXZWlnaHQgPT09ICdib2xkJztcbiAgY29uc3QgaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbiA9IHRleHREZWNvcmF0aW9uLmluY2x1ZGVzKCdsaW5lLXRocm91Z2gnKTtcbiAgY29uc3QgaGFzSXRhbGljRm9udFN0eWxlID0gc3R5bGUuZm9udFN0eWxlID09PSAnaXRhbGljJztcbiAgY29uc3QgaGFzVW5kZXJsaW5lVGV4dERlY29yYXRpb24gPSB0ZXh0RGVjb3JhdGlvbi5pbmNsdWRlcygndW5kZXJsaW5lJyk7XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkTGV4aWNhbE5vZGVzID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgbGV0IHBhcmFncmFwaE5vZGUgPSBudWxsO1xuICAgICAgY29uc3QgcmVtb3ZlU2luZ2xlTGluZUJyZWFrTm9kZSA9ICgpID0+IHtcbiAgICAgICAgaWYgKHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gcGFyYWdyYXBoTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICAgICAgaWYgKCRpc0xpbmVCcmVha05vZGUoZmlyc3RDaGlsZCkgJiYgcGFyYWdyYXBoTm9kZS5nZXRDaGlsZHJlblNpemUoKSA9PT0gMSkge1xuICAgICAgICAgICAgZmlyc3RDaGlsZC5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkTGV4aWNhbE5vZGVzKSB7XG4gICAgICAgIGlmICgkaXNJbmxpbmVFbGVtZW50T3JEZWNvcmF0b3JOb2RlKGNoaWxkKSB8fCAkaXNUZXh0Tm9kZShjaGlsZCkgfHwgJGlzTGluZUJyZWFrTm9kZShjaGlsZCkpIHtcbiAgICAgICAgICBpZiAoJGlzVGV4dE5vZGUoY2hpbGQpKSB7XG4gICAgICAgICAgICBpZiAoaGFzQm9sZEZvbnRXZWlnaHQpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdib2xkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzTGluZXRocm91Z2hUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3N0cmlrZXRocm91Z2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNJdGFsaWNGb250U3R5bGUpIHtcbiAgICAgICAgICAgICAgY2hpbGQudG9nZ2xlRm9ybWF0KCdpdGFsaWMnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNVbmRlcmxpbmVUZXh0RGVjb3JhdGlvbikge1xuICAgICAgICAgICAgICBjaGlsZC50b2dnbGVGb3JtYXQoJ3VuZGVybGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocGFyYWdyYXBoTm9kZSkge1xuICAgICAgICAgICAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlID0gJGNyZWF0ZVBhcmFncmFwaE5vZGUoKS5hcHBlbmQoY2hpbGQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyYWdyYXBoTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICByZW1vdmVTaW5nbGVMaW5lQnJlYWtOb2RlKCk7XG4gICAgICAgICAgcGFyYWdyYXBoTm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlbW92ZVNpbmdsZUxpbmVCcmVha05vZGUoKTtcbiAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIG5vZGU6IHRhYmxlQ2VsbE5vZGVcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUywgY29sU3BhbiA9IDEsIHdpZHRoKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIGNvbFNwYW4sIHdpZHRoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBUYWJsZUNlbGxOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IElOU0VSVF9UQUJMRV9DT01NQU5EID0gY3JlYXRlQ29tbWFuZCgnSU5TRVJUX1RBQkxFX0NPTU1BTkQnKTtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKiBAbm9Jbmhlcml0RG9jICovXG5jbGFzcyBUYWJsZVJvd05vZGUgZXh0ZW5kcyBFbGVtZW50Tm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICBzdGF0aWMgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gJ3RhYmxlcm93JztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgVGFibGVSb3dOb2RlKG5vZGUuX19oZWlnaHQsIG5vZGUuX19rZXkpO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyOiBub2RlID0+ICh7XG4gICAgICAgIGNvbnZlcnNpb246ICRjb252ZXJ0VGFibGVSb3dFbGVtZW50LFxuICAgICAgICBwcmlvcml0eTogMFxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVUYWJsZVJvd05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldEhlaWdodChzZXJpYWxpemVkTm9kZS5oZWlnaHQpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGhlaWdodCwga2V5KSB7XG4gICAgc3VwZXIoa2V5KTtcbiAgICB0aGlzLl9faGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5nZXRIZWlnaHQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZXhwb3J0SlNPTigpLFxuICAgICAgLi4uKGhlaWdodCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDoge1xuICAgICAgICBoZWlnaHRcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgaWYgKHRoaXMuX19oZWlnaHQpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhpcy5fX2hlaWdodH1weGA7XG4gICAgfVxuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZWxlbWVudCwgY29uZmlnLnRoZW1lLnRhYmxlUm93KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgcmV0dXJuIGRlc3RpbmF0aW9uID09PSAnaHRtbCc7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19oZWlnaHQgPSBoZWlnaHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0SGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldExhdGVzdCgpLl9faGVpZ2h0O1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSkge1xuICAgIHJldHVybiBwcmV2Tm9kZS5fX2hlaWdodCAhPT0gdGhpcy5fX2hlaWdodDtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5JbmRlbnQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiAkY29udmVydFRhYmxlUm93RWxlbWVudChkb21Ob2RlKSB7XG4gIGNvbnN0IGRvbU5vZGVfID0gZG9tTm9kZTtcbiAgbGV0IGhlaWdodCA9IHVuZGVmaW5lZDtcbiAgaWYgKFBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpKSB7XG4gICAgaGVpZ2h0ID0gcGFyc2VGbG9hdChkb21Ob2RlXy5zdHlsZS5oZWlnaHQpO1xuICB9XG4gIHJldHVybiB7XG4gICAgYWZ0ZXI6IGNoaWxkcmVuID0+ICRkZXNjZW5kYW50c01hdGNoaW5nKGNoaWxkcmVuLCAkaXNUYWJsZUNlbGxOb2RlKSxcbiAgICBub2RlOiAkY3JlYXRlVGFibGVSb3dOb2RlKGhlaWdodClcbiAgfTtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVJvd05vZGUoaGVpZ2h0KSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IFRhYmxlUm93Tm9kZShoZWlnaHQpKTtcbn1cbmZ1bmN0aW9uICRpc1RhYmxlUm93Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgVGFibGVSb3dOb2RlO1xufVxuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmNvbnN0IENBTl9VU0VfRE9NID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG5jb25zdCBkb2N1bWVudE1vZGUgPSBDQU5fVVNFX0RPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IG51bGw7XG5jb25zdCBJU19GSVJFRk9YID0gQ0FOX1VTRV9ET00gJiYgL14oPyEuKlNlYW1vbmtleSkoPz0uKkZpcmVmb3gpLiovaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuQ0FOX1VTRV9ET00gJiYgJ0lucHV0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlID8gJ2dldFRhcmdldFJhbmdlcycgaW4gbmV3IHdpbmRvdy5JbnB1dEV2ZW50KCdpbnB1dCcpIDogZmFsc2U7XG5cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZU5vZGVXaXRoRGltZW5zaW9ucyhyb3dDb3VudCwgY29sdW1uQ291bnQsIGluY2x1ZGVIZWFkZXJzID0gdHJ1ZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGZvciAobGV0IGlSb3cgPSAwOyBpUm93IDwgcm93Q291bnQ7IGlSb3crKykge1xuICAgIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpQ29sdW1uID0gMDsgaUNvbHVtbiA8IGNvbHVtbkNvdW50OyBpQ29sdW1uKyspIHtcbiAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICBpZiAodHlwZW9mIGluY2x1ZGVIZWFkZXJzID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5yb3dzKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLlJPVztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaUNvbHVtbiA9PT0gMCAmJiBpbmNsdWRlSGVhZGVycy5jb2x1bW5zKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbmNsdWRlSGVhZGVycykge1xuICAgICAgICBpZiAoaVJvdyA9PT0gMCkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlDb2x1bW4gPT09IDApIHtcbiAgICAgICAgICBoZWFkZXJTdGF0ZSB8PSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCgkY3JlYXRlVGV4dE5vZGUoKSk7XG4gICAgICB0YWJsZUNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgIHRhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgfVxuICAgIHRhYmxlTm9kZS5hcHBlbmQodGFibGVSb3dOb2RlKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVGcm9tTGV4aWNhbE5vZGUoc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3coc3RhcnRpbmdOb2RlKSB7XG4gIGNvbnN0IG5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHN0YXJ0aW5nTm9kZSwgbiA9PiAkaXNUYWJsZVJvd05vZGUobikpO1xuICBpZiAoJGlzVGFibGVSb3dOb2RlKG5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0YWJsZSBjZWxsIHRvIGJlIGluc2lkZSBvZiB0YWJsZSByb3cuJyk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVOb2RlRnJvbUxleGljYWxOb2RlT3JUaHJvdyhzdGFydGluZ05vZGUpIHtcbiAgY29uc3Qgbm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnRpbmdOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICgkaXNUYWJsZU5vZGUobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRhYmxlIGNlbGwgdG8gYmUgaW5zaWRlIG9mIHRhYmxlLicpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlUm93SW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlUm93Tm9kZSk7XG4gIHJldHVybiB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlUm93Tm9kZSkpO1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ29sdW1uSW5kZXhGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSB7XG4gIGNvbnN0IHRhYmxlUm93Tm9kZSA9ICRnZXRUYWJsZVJvd05vZGVGcm9tVGFibGVDZWxsTm9kZU9yVGhyb3codGFibGVDZWxsTm9kZSk7XG4gIHJldHVybiB0YWJsZVJvd05vZGUuZ2V0Q2hpbGRyZW4oKS5maW5kSW5kZXgobiA9PiBuLmlzKHRhYmxlQ2VsbE5vZGUpKTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUodGFibGVDZWxsTm9kZSwgdGFibGUpO1xuICByZXR1cm4ge1xuICAgIGFib3ZlOiB0YWJsZU5vZGUuZ2V0Q2VsbE5vZGVGcm9tQ29yZHMoeCwgeSAtIDEsIHRhYmxlKSxcbiAgICBiZWxvdzogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHkgKyAxLCB0YWJsZSksXG4gICAgbGVmdDogdGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzKHggLSAxLCB5LCB0YWJsZSksXG4gICAgcmlnaHQ6IHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkcyh4ICsgMSwgeSwgdGFibGUpXG4gIH07XG59XG5mdW5jdGlvbiAkcmVtb3ZlVGFibGVSb3dBdEluZGV4KHRhYmxlTm9kZSwgaW5kZXhUb0RlbGV0ZSkge1xuICBjb25zdCB0YWJsZVJvd3MgPSB0YWJsZU5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgaWYgKGluZGV4VG9EZWxldGUgPj0gdGFibGVSb3dzLmxlbmd0aCB8fCBpbmRleFRvRGVsZXRlIDwgMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGFibGUgY2VsbCB0byBiZSBpbnNpZGUgb2YgdGFibGUgcm93LicpO1xuICB9XG4gIGNvbnN0IHRhcmdldFJvd05vZGUgPSB0YWJsZVJvd3NbaW5kZXhUb0RlbGV0ZV07XG4gIHRhcmdldFJvd05vZGUucmVtb3ZlKCk7XG4gIHJldHVybiB0YWJsZU5vZGU7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbn0gb3Ige0BsaW5rICRpbnNlcnRUYWJsZVJvd0F0Tm9kZX0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlUm93KHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgsIHNob3VsZEluc2VydEFmdGVyID0gdHJ1ZSwgcm93Q291bnQsIHRhYmxlKSB7XG4gIGNvbnN0IHRhYmxlUm93cyA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dzLmxlbmd0aCB8fCB0YXJnZXRJbmRleCA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIHJvdyB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gIH1cbiAgY29uc3QgdGFyZ2V0Um93Tm9kZSA9IHRhYmxlUm93c1t0YXJnZXRJbmRleF07XG4gIGlmICgkaXNUYWJsZVJvd05vZGUodGFyZ2V0Um93Tm9kZSkpIHtcbiAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgIGNvbnN0IHRhYmxlUm93Q2VsbHMgPSB0YXJnZXRSb3dOb2RlLmdldENoaWxkcmVuKCk7XG4gICAgICBjb25zdCB0YWJsZUNvbHVtbkNvdW50ID0gdGFibGVSb3dDZWxscy5sZW5ndGg7XG4gICAgICBjb25zdCBuZXdUYWJsZVJvd05vZGUgPSAkY3JlYXRlVGFibGVSb3dOb2RlKCk7XG4gICAgICBmb3IgKGxldCBjID0gMDsgYyA8IHRhYmxlQ29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZUNlbGxGcm9tVGFyZ2V0Um93ID0gdGFibGVSb3dDZWxsc1tjXTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbEZyb21UYXJnZXRSb3cpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGFib3ZlLFxuICAgICAgICAgIGJlbG93XG4gICAgICAgIH0gPSAkZ2V0VGFibGVDZWxsU2libGluZ3NGcm9tVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxGcm9tVGFyZ2V0Um93LCB0YWJsZSk7XG4gICAgICAgIGxldCBoZWFkZXJTdGF0ZSA9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5OT19TVEFUVVM7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gYWJvdmUgJiYgYWJvdmUuZ2V0V2lkdGgoKSB8fCBiZWxvdyAmJiBiZWxvdy5nZXRXaWR0aCgpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGFib3ZlICYmIGFib3ZlLmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pIHx8IGJlbG93ICYmIGJlbG93Lmhhc0hlYWRlclN0YXRlKFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pKSB7XG4gICAgICAgICAgaGVhZGVyU3RhdGUgfD0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLkNPTFVNTjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUsIDEsIHdpZHRoKTtcbiAgICAgICAgdGFibGVDZWxsTm9kZS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgICAgIG5ld1RhYmxlUm93Tm9kZS5hcHBlbmQodGFibGVDZWxsTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkSW5zZXJ0QWZ0ZXIpIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRBZnRlcihuZXdUYWJsZVJvd05vZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0Um93Tm9kZS5pbnNlcnRCZWZvcmUobmV3VGFibGVSb3dOb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb3cgYmVmb3JlIGluc2VydGlvbiBpbmRleCBkb2VzIG5vdCBleGlzdC4nKTtcbiAgfVxuICByZXR1cm4gdGFibGVOb2RlO1xufVxuY29uc3QgZ2V0SGVhZGVyU3RhdGUgPSAoY3VycmVudFN0YXRlLCBwb3NzaWJsZVN0YXRlKSA9PiB7XG4gIGlmIChjdXJyZW50U3RhdGUgPT09IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5CT1RIIHx8IGN1cnJlbnRTdGF0ZSA9PT0gcG9zc2libGVTdGF0ZSkge1xuICAgIHJldHVybiBwb3NzaWJsZVN0YXRlO1xuICB9XG4gIHJldHVybiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdGFibGUgcm93IGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGluc2VydGVkIHRhYmxlIHJvdyBub2RlLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbihpbnNlcnRBZnRlciA9IHRydWUpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGZvY3VzID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgY29uc3QgW2FuY2hvckNlbGxdID0gJGdldE5vZGVUcmlwbGV0KGFuY2hvcik7XG4gIGNvbnN0IFtmb2N1c0NlbGwsLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChmb2N1cyk7XG4gIGNvbnN0IFssIGZvY3VzQ2VsbE1hcCwgYW5jaG9yQ2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGZvY3VzQ2VsbCwgYW5jaG9yQ2VsbCk7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogYW5jaG9yU3RhcnRSb3dcbiAgfSA9IGFuY2hvckNlbGxNYXA7XG4gIGNvbnN0IHtcbiAgICBzdGFydFJvdzogZm9jdXNTdGFydFJvd1xuICB9ID0gZm9jdXNDZWxsTWFwO1xuICBpZiAoaW5zZXJ0QWZ0ZXIpIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlUm93QXROb2RlKGFuY2hvclN0YXJ0Um93ICsgYW5jaG9yQ2VsbC5fX3Jvd1NwYW4gPiBmb2N1c1N0YXJ0Um93ICsgZm9jdXNDZWxsLl9fcm93U3BhbiA/IGFuY2hvckNlbGwgOiBmb2N1c0NlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAkaW5zZXJ0VGFibGVSb3dBdE5vZGUoZm9jdXNTdGFydFJvdyA8IGFuY2hvclN0YXJ0Um93ID8gZm9jdXNDZWxsIDogYW5jaG9yQ2VsbCwgZmFsc2UpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRpbnNlcnRUYWJsZVJvd19fRVhQRVJJTUVOVEFMID0gJGluc2VydFRhYmxlUm93QXRTZWxlY3Rpb247XG5cbi8qKlxuICogSW5zZXJ0cyBhIHRhYmxlIHJvdyBiZWZvcmUgb3IgYWZ0ZXIgdGhlIGdpdmVuIGNlbGwgbm9kZSxcbiAqIHRha2luZyBpbnRvIGFjY291bnQgYW55IHNwYW5zLiBJZiBzdWNjZXNzZnVsLCByZXR1cm5zIHRoZVxuICogaW5zZXJ0ZWQgdGFibGUgcm93IG5vZGUuXG4gKi9cbmZ1bmN0aW9uICRpbnNlcnRUYWJsZVJvd0F0Tm9kZShjZWxsTm9kZSwgaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IFssLCBncmlkXSA9ICRnZXROb2RlVHJpcGxldChjZWxsTm9kZSk7XG4gIGNvbnN0IFtncmlkTWFwLCBjZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgY2VsbE5vZGUsIGNlbGxOb2RlKTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBjZWxsU3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIGxldCBpbnNlcnRlZFJvdyA9IG51bGw7XG4gIGlmIChpbnNlcnRBZnRlcikge1xuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93ID0gY2VsbFN0YXJ0Um93ICsgY2VsbE5vZGUuX19yb3dTcGFuIC0gMTtcbiAgICBjb25zdCBpbnNlcnRBZnRlckVuZFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QWZ0ZXJFbmRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRBZnRlckVuZFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyArIGNlbGwuX19yb3dTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckVuZFJvdykge1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGluc2VydEFmdGVyRW5kUm93TWFwW2ldLmNlbGw7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSBjdXJyZW50Q2VsbC5fX2hlYWRlclN0YXRlO1xuICAgICAgICBjb25zdCBoZWFkZXJTdGF0ZSA9IGdldEhlYWRlclN0YXRlKGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU4pO1xuICAgICAgICBuZXdSb3cuYXBwZW5kKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuICsgMSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGluc2VydEFmdGVyRW5kUm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KGluc2VydEFmdGVyRW5kUm93KTtcbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShpbnNlcnRBZnRlckVuZFJvd05vZGUpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGluc2VydEFmdGVyRW5kUm93IGlzIG5vdCBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBpbnNlcnRBZnRlckVuZFJvd05vZGUuaW5zZXJ0QWZ0ZXIobmV3Um93KTtcbiAgICBpbnNlcnRlZFJvdyA9IG5ld1JvdztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvdyA9IGNlbGxTdGFydFJvdztcbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd01hcCA9IGdyaWRNYXBbaW5zZXJ0QmVmb3JlU3RhcnRSb3ddO1xuICAgIGNvbnN0IG5ld1JvdyA9ICRjcmVhdGVUYWJsZVJvd05vZGUoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgY2VsbCxcbiAgICAgICAgc3RhcnRSb3dcbiAgICAgIH0gPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXTtcbiAgICAgIGlmIChzdGFydFJvdyA9PT0gaW5zZXJ0QmVmb3JlU3RhcnRSb3cpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSBpbnNlcnRCZWZvcmVTdGFydFJvd01hcFtpXS5jZWxsO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEhlYWRlclN0YXRlID0gY3VycmVudENlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICAgICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuQ09MVU1OKTtcbiAgICAgICAgbmV3Um93LmFwcGVuZCgkY3JlYXRlVGFibGVDZWxsTm9kZShoZWFkZXJTdGF0ZSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwuc2V0Um93U3BhbihjZWxsLl9fcm93U3BhbiArIDEpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnNlcnRCZWZvcmVTdGFydFJvd05vZGUgPSBncmlkLmdldENoaWxkQXRJbmRleChpbnNlcnRCZWZvcmVTdGFydFJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBpbnNlcnRCZWZvcmVTdGFydFJvdyBpcyBub3QgYSBUYWJsZVJvd05vZGVgKTtcbiAgICB9XG4gICAgaW5zZXJ0QmVmb3JlU3RhcnRSb3dOb2RlLmluc2VydEJlZm9yZShuZXdSb3cpO1xuICAgIGluc2VydGVkUm93ID0gbmV3Um93O1xuICB9XG4gIHJldHVybiBpbnNlcnRlZFJvdztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbWVyZ2VkIGNlbGxzLiBVc2Uge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufSBvciB7QGxpbmsgJGluc2VydFRhYmxlQ29sdW1uQXROb2RlfSBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiAkaW5zZXJ0VGFibGVDb2x1bW4odGFibGVOb2RlLCB0YXJnZXRJbmRleCwgc2hvdWxkSW5zZXJ0QWZ0ZXIgPSB0cnVlLCBjb2x1bW5Db3VudCwgdGFibGUpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGNvbnN0IHRhYmxlQ2VsbHNUb0JlSW5zZXJ0ZWQgPSBbXTtcbiAgZm9yIChsZXQgciA9IDA7IHIgPCB0YWJsZVJvd3MubGVuZ3RoOyByKyspIHtcbiAgICBjb25zdCBjdXJyZW50VGFibGVSb3dOb2RlID0gdGFibGVSb3dzW3JdO1xuICAgIGlmICgkaXNUYWJsZVJvd05vZGUoY3VycmVudFRhYmxlUm93Tm9kZSkpIHtcbiAgICAgIGZvciAobGV0IGMgPSAwOyBjIDwgY29sdW1uQ291bnQ7IGMrKykge1xuICAgICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPj0gdGFibGVSb3dDaGlsZHJlbi5sZW5ndGggfHwgdGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJsZSBjb2x1bW4gdGFyZ2V0IGluZGV4IG91dCBvZiByYW5nZScpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENlbGwgPSB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKHRhcmdldENlbGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0YWJsZSBjZWxsYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGxlZnQsXG4gICAgICAgICAgcmlnaHRcbiAgICAgICAgfSA9ICRnZXRUYWJsZUNlbGxTaWJsaW5nc0Zyb21UYWJsZUNlbGxOb2RlKHRhcmdldENlbGwsIHRhYmxlKTtcbiAgICAgICAgbGV0IGhlYWRlclN0YXRlID0gVGFibGVDZWxsSGVhZGVyU3RhdGVzLk5PX1NUQVRVUztcbiAgICAgICAgaWYgKGxlZnQgJiYgbGVmdC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSB8fCByaWdodCAmJiByaWdodC5oYXNIZWFkZXJTdGF0ZShUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKSkge1xuICAgICAgICAgIGhlYWRlclN0YXRlIHw9IFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5ST1c7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3VGFibGVDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoaGVhZGVyU3RhdGUpO1xuICAgICAgICBuZXdUYWJsZUNlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICAgICAgICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLnB1c2goe1xuICAgICAgICAgIG5ld1RhYmxlQ2VsbCxcbiAgICAgICAgICB0YXJnZXRDZWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0YWJsZUNlbGxzVG9CZUluc2VydGVkLmZvckVhY2goKHtcbiAgICBuZXdUYWJsZUNlbGwsXG4gICAgdGFyZ2V0Q2VsbFxuICB9KSA9PiB7XG4gICAgaWYgKHNob3VsZEluc2VydEFmdGVyKSB7XG4gICAgICB0YXJnZXRDZWxsLmluc2VydEFmdGVyKG5ld1RhYmxlQ2VsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldENlbGwuaW5zZXJ0QmVmb3JlKG5ld1RhYmxlQ2VsbCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cblxuLyoqXG4gKiBJbnNlcnRzIGEgY29sdW1uIGJlZm9yZSBvciBhZnRlciB0aGUgY3VycmVudCBmb2N1cyBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oaW5zZXJ0QWZ0ZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsXSA9ICRnZXROb2RlVHJpcGxldChhbmNob3IpO1xuICBjb25zdCBbZm9jdXNDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbLCBmb2N1c0NlbGxNYXAsIGFuY2hvckNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBmb2N1c0NlbGwsIGFuY2hvckNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGFuY2hvclN0YXJ0Q29sdW1uXG4gIH0gPSBhbmNob3JDZWxsTWFwO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW46IGZvY3VzU3RhcnRDb2x1bW5cbiAgfSA9IGZvY3VzQ2VsbE1hcDtcbiAgaWYgKGluc2VydEFmdGVyKSB7XG4gICAgcmV0dXJuICRpbnNlcnRUYWJsZUNvbHVtbkF0Tm9kZShhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuID4gZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gPyBhbmNob3JDZWxsIDogZm9jdXNDZWxsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGZvY3VzU3RhcnRDb2x1bW4gPCBhbmNob3JTdGFydENvbHVtbiA/IGZvY3VzQ2VsbCA6IGFuY2hvckNlbGwsIGZhbHNlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCA9ICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uO1xuXG4vKipcbiAqIEluc2VydHMgYSBjb2x1bW4gYmVmb3JlIG9yIGFmdGVyIHRoZSBnaXZlbiBjZWxsIG5vZGUsXG4gKiB0YWtpbmcgaW50byBhY2NvdW50IGFueSBzcGFucy4gSWYgc3VjY2Vzc2Z1bCwgcmV0dXJucyB0aGVcbiAqIGZpcnN0IGluc2VydGVkIGNlbGwgbm9kZS5cbiAqL1xuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29sdW1uQXROb2RlKGNlbGxOb2RlLCBpbnNlcnRBZnRlciA9IHRydWUsIHNob3VsZFNldFNlbGVjdGlvbiA9IHRydWUpIHtcbiAgY29uc3QgWywsIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXAsIGNlbGxNYXBdID0gJGNvbXB1dGVUYWJsZU1hcChncmlkLCBjZWxsTm9kZSwgY2VsbE5vZGUpO1xuICBjb25zdCByb3dDb3VudCA9IGdyaWRNYXAubGVuZ3RoO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxNYXA7XG4gIGNvbnN0IGluc2VydEFmdGVyQ29sdW1uID0gaW5zZXJ0QWZ0ZXIgPyBzdGFydENvbHVtbiArIGNlbGxOb2RlLl9fY29sU3BhbiAtIDEgOiBzdGFydENvbHVtbiAtIDE7XG4gIGNvbnN0IGdyaWRGaXJzdENoaWxkID0gZ3JpZC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKGdyaWRGaXJzdENoaWxkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgZmlyc3RUYWJsZSBjaGlsZCB0byBiZSBhIHJvd2ApO1xuICB9XG4gIGxldCBmaXJzdEluc2VydGVkQ2VsbCA9IG51bGw7XG4gIGZ1bmN0aW9uICRjcmVhdGVUYWJsZUNlbGxOb2RlRm9ySW5zZXJ0VGFibGVDb2x1bW4oaGVhZGVyU3RhdGUgPSBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuTk9fU1RBVFVTKSB7XG4gICAgY29uc3QgY2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKGhlYWRlclN0YXRlKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSk7XG4gICAgaWYgKGZpcnN0SW5zZXJ0ZWRDZWxsID09PSBudWxsKSB7XG4gICAgICBmaXJzdEluc2VydGVkQ2VsbCA9IGNlbGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGxldCBsb29wUm93ID0gZ3JpZEZpcnN0Q2hpbGQ7XG4gIHJvd0xvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGlmIChpICE9PSAwKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gbG9vcFJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKCEkaXNUYWJsZVJvd05vZGUoY3VycmVudFJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCByb3cgbmV4dFNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxvb3BSb3cgPSBjdXJyZW50Um93O1xuICAgIH1cbiAgICBjb25zdCByb3dNYXAgPSBncmlkTWFwW2ldO1xuICAgIGNvbnN0IGN1cnJlbnRDZWxsSGVhZGVyU3RhdGUgPSByb3dNYXBbaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uXS5jZWxsLl9faGVhZGVyU3RhdGU7XG4gICAgY29uc3QgaGVhZGVyU3RhdGUgPSBnZXRIZWFkZXJTdGF0ZShjdXJyZW50Q2VsbEhlYWRlclN0YXRlLCBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XKTtcbiAgICBpZiAoaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwKSB7XG4gICAgICAkaW5zZXJ0Rmlyc3QobG9vcFJvdywgJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGNlbGw6IGN1cnJlbnRDZWxsLFxuICAgICAgc3RhcnRDb2x1bW46IGN1cnJlbnRTdGFydENvbHVtbixcbiAgICAgIHN0YXJ0Um93OiBjdXJyZW50U3RhcnRSb3dcbiAgICB9ID0gcm93TWFwW2luc2VydEFmdGVyQ29sdW1uXTtcbiAgICBpZiAoY3VycmVudFN0YXJ0Q29sdW1uICsgY3VycmVudENlbGwuX19jb2xTcGFuIC0gMSA8PSBpbnNlcnRBZnRlckNvbHVtbikge1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgbGV0IGluc2VydEFmdGVyQ2VsbFJvd1N0YXJ0ID0gY3VycmVudFN0YXJ0Um93O1xuICAgICAgbGV0IHByZXZDZWxsSW5kZXggPSBpbnNlcnRBZnRlckNvbHVtbjtcbiAgICAgIHdoaWxlIChpbnNlcnRBZnRlckNlbGxSb3dTdGFydCAhPT0gaSAmJiBpbnNlcnRBZnRlckNlbGwuX19yb3dTcGFuID4gMSkge1xuICAgICAgICBwcmV2Q2VsbEluZGV4IC09IGN1cnJlbnRDZWxsLl9fY29sU3BhbjtcbiAgICAgICAgaWYgKHByZXZDZWxsSW5kZXggPj0gMCkge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNlbGw6IGNlbGxfLFxuICAgICAgICAgICAgc3RhcnRSb3c6IHN0YXJ0Um93X1xuICAgICAgICAgIH0gPSByb3dNYXBbcHJldkNlbGxJbmRleF07XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY2VsbF87XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsUm93U3RhcnQgPSBzdGFydFJvd187XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9vcFJvdy5hcHBlbmQoJGNyZWF0ZVRhYmxlQ2VsbE5vZGVGb3JJbnNlcnRUYWJsZUNvbHVtbihoZWFkZXJTdGF0ZSkpO1xuICAgICAgICAgIGNvbnRpbnVlIHJvd0xvb3A7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGluc2VydEFmdGVyQ2VsbC5pbnNlcnRBZnRlcigkY3JlYXRlVGFibGVDZWxsTm9kZUZvckluc2VydFRhYmxlQ29sdW1uKGhlYWRlclN0YXRlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnRDZWxsLnNldENvbFNwYW4oY3VycmVudENlbGwuX19jb2xTcGFuICsgMSk7XG4gICAgfVxuICB9XG4gIGlmIChmaXJzdEluc2VydGVkQ2VsbCAhPT0gbnVsbCAmJiBzaG91bGRTZXRTZWxlY3Rpb24pIHtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChmaXJzdEluc2VydGVkQ2VsbCk7XG4gIH1cbiAgY29uc3QgY29sV2lkdGhzID0gZ3JpZC5nZXRDb2xXaWR0aHMoKTtcbiAgaWYgKGNvbFdpZHRocykge1xuICAgIGNvbnN0IG5ld0NvbFdpZHRocyA9IFsuLi5jb2xXaWR0aHNdO1xuICAgIGNvbnN0IGNvbHVtbkluZGV4ID0gaW5zZXJ0QWZ0ZXJDb2x1bW4gPCAwID8gMCA6IGluc2VydEFmdGVyQ29sdW1uO1xuICAgIGNvbnN0IG5ld1dpZHRoID0gbmV3Q29sV2lkdGhzW2NvbHVtbkluZGV4XTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKGNvbHVtbkluZGV4LCAwLCBuZXdXaWR0aCk7XG4gICAgZ3JpZC5zZXRDb2xXaWR0aHMobmV3Q29sV2lkdGhzKTtcbiAgfVxuICByZXR1cm4gZmlyc3RJbnNlcnRlZENlbGw7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBzdXBwb3J0IG1lcmdlZCBjZWxscy4gVXNlIHtAbGluayAkZGVsZXRlVGFibGVDb2x1bW5BdFNlbGVjdGlvbn0gaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uKHRhYmxlTm9kZSwgdGFyZ2V0SW5kZXgpIHtcbiAgY29uc3QgdGFibGVSb3dzID0gdGFibGVOb2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFibGVSb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudFRhYmxlUm93Tm9kZSA9IHRhYmxlUm93c1tpXTtcbiAgICBpZiAoJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRUYWJsZVJvd05vZGUpKSB7XG4gICAgICBjb25zdCB0YWJsZVJvd0NoaWxkcmVuID0gY3VycmVudFRhYmxlUm93Tm9kZS5nZXRDaGlsZHJlbigpO1xuICAgICAgaWYgKHRhcmdldEluZGV4ID49IHRhYmxlUm93Q2hpbGRyZW4ubGVuZ3RoIHx8IHRhcmdldEluZGV4IDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhYmxlIGNvbHVtbiB0YXJnZXQgaW5kZXggb3V0IG9mIHJhbmdlJyk7XG4gICAgICB9XG4gICAgICB0YWJsZVJvd0NoaWxkcmVuW3RhcmdldEluZGV4XS5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlTm9kZTtcbn1cbmZ1bmN0aW9uICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uKCkge1xuICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgfHwgJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIGEgUmFuZ2VTZWxlY3Rpb24gb3IgVGFibGVTZWxlY3Rpb25gKTtcbiAgfVxuICBjb25zdCBbYW5jaG9yLCBmb2N1c10gPSBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gW3NlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCksIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpXSA6IFtzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKV07XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBhbmNob3JTdGFydFJvd1xuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93XG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IGZvY3VzRW5kUm93ID0gZm9jdXNTdGFydFJvdyArIGZvY3VzQ2VsbC5fX3Jvd1NwYW4gLSAxO1xuICBpZiAoZ3JpZE1hcC5sZW5ndGggPT09IGZvY3VzRW5kUm93IC0gYW5jaG9yU3RhcnRSb3cgKyAxKSB7XG4gICAgLy8gRW1wdHkgZ3JpZFxuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHVtbkNvdW50ID0gZ3JpZE1hcFswXS5sZW5ndGg7XG4gIGNvbnN0IG5leHRSb3cgPSBncmlkTWFwW2ZvY3VzRW5kUm93ICsgMV07XG4gIGNvbnN0IG5leHRSb3dOb2RlID0gZ3JpZC5nZXRDaGlsZEF0SW5kZXgoZm9jdXNFbmRSb3cgKyAxKTtcbiAgZm9yIChsZXQgcm93ID0gZm9jdXNFbmRSb3c7IHJvdyA+PSBhbmNob3JTdGFydFJvdzsgcm93LS0pIHtcbiAgICBmb3IgKGxldCBjb2x1bW4gPSBjb2x1bW5Db3VudCAtIDE7IGNvbHVtbiA+PSAwOyBjb2x1bW4tLSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydFJvdzogY2VsbFN0YXJ0Um93LFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uICE9PSBjb2x1bW4pIHtcbiAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHdvcmsgZm9yIHRoZSBzYW1lIENlbGxcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBSb3dzIG92ZXJmbG93aW5nIHRvcCBvciBib3R0b20gaGF2ZSB0byBiZSB0cmltbWVkXG4gICAgICBpZiAoY2VsbFN0YXJ0Um93IDwgYW5jaG9yU3RhcnRSb3cgfHwgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uU3RhcnQgPSBNYXRoLm1heChjZWxsU3RhcnRSb3csIGFuY2hvclN0YXJ0Um93KTtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0aW9uRW5kID0gTWF0aC5taW4oY2VsbC5fX3Jvd1NwYW4gKyBjZWxsU3RhcnRSb3cgLSAxLCBmb2N1c0VuZFJvdyk7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93Um93c0NvdW50ID0gaW50ZXJzZWN0aW9uU3RhcnQgPD0gaW50ZXJzZWN0aW9uRW5kID8gaW50ZXJzZWN0aW9uRW5kIC0gaW50ZXJzZWN0aW9uU3RhcnQgKyAxIDogMDtcbiAgICAgICAgY2VsbC5zZXRSb3dTcGFuKGNlbGwuX19yb3dTcGFuIC0gb3ZlcmZsb3dSb3dzQ291bnQpO1xuICAgICAgfVxuICAgICAgLy8gUm93cyBvdmVyZmxvd2luZyBib3R0b20gaGF2ZSB0byBiZSBtb3ZlZCB0byB0aGUgbmV4dCByb3dcbiAgICAgIGlmIChjZWxsU3RhcnRSb3cgPj0gYW5jaG9yU3RhcnRSb3cgJiYgY2VsbFN0YXJ0Um93ICsgY2VsbC5fX3Jvd1NwYW4gLSAxID4gZm9jdXNFbmRSb3cgJiZcbiAgICAgIC8vIEhhbmRsZSBvdmVyZmxvdyBvbmx5IG9uY2VcbiAgICAgIHJvdyA9PT0gZm9jdXNFbmRSb3cpIHtcbiAgICAgICAgaWYgKCEobmV4dFJvd05vZGUgIT09IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBuZXh0Um93Tm9kZSBub3QgdG8gYmUgbnVsbGApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBjb2x1bW5JbmRleCA9IDA7IGNvbHVtbkluZGV4IDwgY29sdW1uOyBjb2x1bW5JbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudENlbGxNYXAgPSBuZXh0Um93W2NvbHVtbkluZGV4XTtcbiAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgICAgLy8gQ2hlY2tpbmcgdGhlIGNlbGwgaGF2aW5nIHN0YXJ0Um93IGFzIHNhbWUgYXMgbmV4dFJvd1xuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gcm93ICsgMSkge1xuICAgICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsID0gY3VycmVudENlbGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgICBjb2x1bW5JbmRleCArPSBjdXJyZW50Q2VsbC5fX2NvbFNwYW4gLSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zZXJ0QWZ0ZXJDZWxsID09PSBudWxsKSB7XG4gICAgICAgICAgJGluc2VydEZpcnN0KG5leHRSb3dOb2RlLCBjZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnNlcnRBZnRlckNlbGwuaW5zZXJ0QWZ0ZXIoY2VsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm93Tm9kZSA9IGdyaWQuZ2V0Q2hpbGRBdEluZGV4KHJvdyk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkQXRJbmRleCgke1N0cmluZyhyb3cpfSkgdG8gYmUgUm93Tm9kZWApO1xuICAgIH1cbiAgICByb3dOb2RlLnJlbW92ZSgpO1xuICB9XG4gIGlmIChuZXh0Um93ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IG5leHRSb3dbMF07XG4gICAgJG1vdmVTZWxlY3Rpb25Ub0NlbGwoY2VsbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHJldmlvdXNSb3cgPSBncmlkTWFwW2FuY2hvclN0YXJ0Um93IC0gMV07XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBwcmV2aW91c1Jvd1swXTtcbiAgICAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHJlbmFtZWQgdG8ge0BsaW5rICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9ufVxuICovXG5jb25zdCAkZGVsZXRlVGFibGVSb3dfX0VYUEVSSU1FTlRBTCA9ICRkZWxldGVUYWJsZVJvd0F0U2VsZWN0aW9uO1xuZnVuY3Rpb24gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24oKSB7XG4gIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgaWYgKCEoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgYSBSYW5nZVNlbGVjdGlvbiBvciBUYWJsZVNlbGVjdGlvbmApO1xuICB9XG4gIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICBjb25zdCBmb2N1cyA9IHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCk7XG4gIGNvbnN0IFthbmNob3JDZWxsLCwgZ3JpZF0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgY29uc3QgW2ZvY3VzQ2VsbF0gPSAkZ2V0Tm9kZVRyaXBsZXQoZm9jdXMpO1xuICBjb25zdCBbZ3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZCwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Q29sdW1uOiBhbmNob3JTdGFydENvbHVtblxuICB9ID0gYW5jaG9yQ2VsbE1hcDtcbiAgY29uc3Qge1xuICAgIHN0YXJ0Um93OiBmb2N1c1N0YXJ0Um93LFxuICAgIHN0YXJ0Q29sdW1uOiBmb2N1c1N0YXJ0Q29sdW1uXG4gIH0gPSBmb2N1c0NlbGxNYXA7XG4gIGNvbnN0IHN0YXJ0Q29sdW1uID0gTWF0aC5taW4oYW5jaG9yU3RhcnRDb2x1bW4sIGZvY3VzU3RhcnRDb2x1bW4pO1xuICBjb25zdCBlbmRDb2x1bW4gPSBNYXRoLm1heChhbmNob3JTdGFydENvbHVtbiArIGFuY2hvckNlbGwuX19jb2xTcGFuIC0gMSwgZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgY29uc3Qgc2VsZWN0ZWRDb2x1bW5Db3VudCA9IGVuZENvbHVtbiAtIHN0YXJ0Q29sdW1uICsgMTtcbiAgY29uc3QgY29sdW1uQ291bnQgPSBncmlkTWFwWzBdLmxlbmd0aDtcbiAgaWYgKGNvbHVtbkNvdW50ID09PSBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpIHtcbiAgICAvLyBFbXB0eSBncmlkXG4gICAgZ3JpZC5zZWxlY3RQcmV2aW91cygpO1xuICAgIGdyaWQucmVtb3ZlKCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJvd0NvdW50ID0gZ3JpZE1hcC5sZW5ndGg7XG4gIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbHVtbiA9IHN0YXJ0Q29sdW1uOyBjb2x1bW4gPD0gZW5kQ29sdW1uOyBjb2x1bW4rKykge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjZWxsLFxuICAgICAgICBzdGFydENvbHVtbjogY2VsbFN0YXJ0Q29sdW1uXG4gICAgICB9ID0gZ3JpZE1hcFtyb3ddW2NvbHVtbl07XG4gICAgICBpZiAoY2VsbFN0YXJ0Q29sdW1uIDwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgaWYgKGNvbHVtbiA9PT0gc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgICBjb25zdCBvdmVyZmxvd0xlZnQgPSBzdGFydENvbHVtbiAtIGNlbGxTdGFydENvbHVtbjtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyBsZWZ0XG4gICAgICAgICAgY2VsbC5zZXRDb2xTcGFuKGNlbGwuX19jb2xTcGFuIC1cbiAgICAgICAgICAvLyBQb3NzaWJsZSBvdmVyZmxvdyByaWdodCB0b29cbiAgICAgICAgICBNYXRoLm1pbihzZWxlY3RlZENvbHVtbkNvdW50LCBjZWxsLl9fY29sU3BhbiAtIG92ZXJmbG93TGVmdCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGNlbGxTdGFydENvbHVtbiArIGNlbGwuX19jb2xTcGFuIC0gMSA+IGVuZENvbHVtbikge1xuICAgICAgICBpZiAoY29sdW1uID09PSBlbmRDb2x1bW4pIHtcbiAgICAgICAgICAvLyBPdmVyZmxvd2luZyByaWdodFxuICAgICAgICAgIGNvbnN0IGluU2VsZWN0ZWRBcmVhID0gZW5kQ29sdW1uIC0gY2VsbFN0YXJ0Q29sdW1uICsgMTtcbiAgICAgICAgICBjZWxsLnNldENvbFNwYW4oY2VsbC5fX2NvbFNwYW4gLSBpblNlbGVjdGVkQXJlYSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNlbGwucmVtb3ZlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IGZvY3VzUm93TWFwID0gZ3JpZE1hcFtmb2N1c1N0YXJ0Um93XTtcbiAgY29uc3QgbmV4dENvbHVtbiA9IGFuY2hvclN0YXJ0Q29sdW1uID4gZm9jdXNTdGFydENvbHVtbiA/IGZvY3VzUm93TWFwW2FuY2hvclN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5fX2NvbFNwYW5dIDogZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiArIGZvY3VzQ2VsbC5fX2NvbFNwYW5dO1xuICBpZiAobmV4dENvbHVtbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge1xuICAgICAgY2VsbFxuICAgIH0gPSBuZXh0Q29sdW1uO1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHByZXZpb3VzUm93ID0gZm9jdXNTdGFydENvbHVtbiA8IGFuY2hvclN0YXJ0Q29sdW1uID8gZm9jdXNSb3dNYXBbZm9jdXNTdGFydENvbHVtbiAtIDFdIDogZm9jdXNSb3dNYXBbYW5jaG9yU3RhcnRDb2x1bW4gLSAxXTtcbiAgICBjb25zdCB7XG4gICAgICBjZWxsXG4gICAgfSA9IHByZXZpb3VzUm93O1xuICAgICRtb3ZlU2VsZWN0aW9uVG9DZWxsKGNlbGwpO1xuICB9XG4gIGNvbnN0IGNvbFdpZHRocyA9IGdyaWQuZ2V0Q29sV2lkdGhzKCk7XG4gIGlmIChjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBuZXdDb2xXaWR0aHMgPSBbLi4uY29sV2lkdGhzXTtcbiAgICBuZXdDb2xXaWR0aHMuc3BsaWNlKHN0YXJ0Q29sdW1uLCBzZWxlY3RlZENvbHVtbkNvdW50KTtcbiAgICBncmlkLnNldENvbFdpZHRocyhuZXdDb2xXaWR0aHMpO1xuICB9XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgcmVuYW1lZCB0byB7QGxpbmsgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb259XG4gKi9cbmNvbnN0ICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMID0gJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb247XG5mdW5jdGlvbiAkbW92ZVNlbGVjdGlvblRvQ2VsbChjZWxsKSB7XG4gIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IGNlbGwuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmIChmaXJzdERlc2NlbmRhbnQgPT0gbnVsbCkge1xuICAgIGNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICBmaXJzdERlc2NlbmRhbnQuZ2V0UGFyZW50T3JUaHJvdygpLnNlbGVjdFN0YXJ0KCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRpbnNlcnRGaXJzdChwYXJlbnQsIG5vZGUpIHtcbiAgY29uc3QgZmlyc3RDaGlsZCA9IHBhcmVudC5nZXRGaXJzdENoaWxkKCk7XG4gIGlmIChmaXJzdENoaWxkICE9PSBudWxsKSB7XG4gICAgZmlyc3RDaGlsZC5pbnNlcnRCZWZvcmUobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcGFyZW50LmFwcGVuZChub2RlKTtcbiAgfVxufVxuZnVuY3Rpb24gJG1lcmdlQ2VsbHMoY2VsbE5vZGVzKSB7XG4gIGlmIChjZWxsTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0YWJsZSBub2RlXG4gIGNvbnN0IHRhYmxlTm9kZSA9ICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93KGNlbGxOb2Rlc1swXSk7XG4gIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgbnVsbCwgbnVsbCk7XG5cbiAgLy8gRmluZCB0aGUgYm91bmRhcmllcyBvZiB0aGUgc2VsZWN0aW9uIGluY2x1ZGluZyBtZXJnZWQgY2VsbHNcbiAgbGV0IG1pblJvdyA9IEluZmluaXR5O1xuICBsZXQgbWF4Um93ID0gLUluZmluaXR5O1xuICBsZXQgbWluQ29sID0gSW5maW5pdHk7XG4gIGxldCBtYXhDb2wgPSAtSW5maW5pdHk7XG5cbiAgLy8gRmlyc3QgcGFzczogZmluZCB0aGUgYWN0dWFsIGJvdW5kYXJpZXMgY29uc2lkZXJpbmcgbWVyZ2VkIGNlbGxzXG4gIGNvbnN0IHByb2Nlc3NlZENlbGxzID0gbmV3IFNldCgpO1xuICBmb3IgKGNvbnN0IHJvdyBvZiBncmlkTWFwKSB7XG4gICAgZm9yIChjb25zdCBtYXBDZWxsIG9mIHJvdykge1xuICAgICAgaWYgKCFtYXBDZWxsIHx8ICFtYXBDZWxsLmNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsS2V5ID0gbWFwQ2VsbC5jZWxsLmdldEtleSgpO1xuICAgICAgaWYgKHByb2Nlc3NlZENlbGxzLmhhcyhjZWxsS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChjZWxsTm9kZXMuc29tZShjZWxsID0+IGNlbGwuaXMobWFwQ2VsbC5jZWxsKSkpIHtcbiAgICAgICAgcHJvY2Vzc2VkQ2VsbHMuYWRkKGNlbGxLZXkpO1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBwb3NpdGlvbiBvZiB0aGlzIGNlbGwgaW4gdGhlIGdyaWRcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Um93ID0gbWFwQ2VsbC5zdGFydFJvdztcbiAgICAgICAgY29uc3QgY2VsbFN0YXJ0Q29sID0gbWFwQ2VsbC5zdGFydENvbHVtbjtcbiAgICAgICAgY29uc3QgY2VsbFJvd1NwYW4gPSBtYXBDZWxsLmNlbGwuX19yb3dTcGFuIHx8IDE7XG4gICAgICAgIGNvbnN0IGNlbGxDb2xTcGFuID0gbWFwQ2VsbC5jZWxsLl9fY29sU3BhbiB8fCAxO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBib3VuZGFyaWVzIGNvbnNpZGVyaW5nIHRoZSBjZWxsJ3MgYWN0dWFsIHBvc2l0aW9uIGFuZCBzcGFuXG4gICAgICAgIG1pblJvdyA9IE1hdGgubWluKG1pblJvdywgY2VsbFN0YXJ0Um93KTtcbiAgICAgICAgbWF4Um93ID0gTWF0aC5tYXgobWF4Um93LCBjZWxsU3RhcnRSb3cgKyBjZWxsUm93U3BhbiAtIDEpO1xuICAgICAgICBtaW5Db2wgPSBNYXRoLm1pbihtaW5Db2wsIGNlbGxTdGFydENvbCk7XG4gICAgICAgIG1heENvbCA9IE1hdGgubWF4KG1heENvbCwgY2VsbFN0YXJ0Q29sICsgY2VsbENvbFNwYW4gLSAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBWYWxpZGF0ZSBib3VuZGFyaWVzXG4gIGlmIChtaW5Sb3cgPT09IEluZmluaXR5IHx8IG1pbkNvbCA9PT0gSW5maW5pdHkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRoZSB0b3RhbCBzcGFuIG9mIHRoZSBtZXJnZWQgY2VsbFxuICBjb25zdCB0b3RhbFJvd1NwYW4gPSBtYXhSb3cgLSBtaW5Sb3cgKyAxO1xuICBjb25zdCB0b3RhbENvbFNwYW4gPSBtYXhDb2wgLSBtaW5Db2wgKyAxO1xuXG4gIC8vIFVzZSB0aGUgdG9wLWxlZnQgY2VsbCBhcyB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3QgdGFyZ2V0Q2VsbE1hcCA9IGdyaWRNYXBbbWluUm93XVttaW5Db2xdO1xuICBpZiAoIXRhcmdldENlbGxNYXAuY2VsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHRhcmdldENlbGwgPSB0YXJnZXRDZWxsTWFwLmNlbGw7XG5cbiAgLy8gU2V0IHRoZSBzcGFucyBmb3IgdGhlIHRhcmdldCBjZWxsXG4gIHRhcmdldENlbGwuc2V0Q29sU3Bhbih0b3RhbENvbFNwYW4pO1xuICB0YXJnZXRDZWxsLnNldFJvd1NwYW4odG90YWxSb3dTcGFuKTtcblxuICAvLyBNb3ZlIGNvbnRlbnQgZnJvbSBvdGhlciBjZWxscyB0byB0aGUgdGFyZ2V0IGNlbGxcbiAgY29uc3Qgc2VlbkNlbGxzID0gbmV3IFNldChbdGFyZ2V0Q2VsbC5nZXRLZXkoKV0pO1xuXG4gIC8vIFNlY29uZCBwYXNzOiBtZXJnZSBjb250ZW50IGFuZCByZW1vdmUgb3RoZXIgY2VsbHNcbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGZvciAobGV0IGNvbCA9IG1pbkNvbDsgY29sIDw9IG1heENvbDsgY29sKyspIHtcbiAgICAgIGNvbnN0IG1hcENlbGwgPSBncmlkTWFwW3Jvd11bY29sXTtcbiAgICAgIGlmICghbWFwQ2VsbC5jZWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgY3VycmVudENlbGwgPSBtYXBDZWxsLmNlbGw7XG4gICAgICBjb25zdCBrZXkgPSBjdXJyZW50Q2VsbC5nZXRLZXkoKTtcbiAgICAgIGlmICghc2VlbkNlbGxzLmhhcyhrZXkpKSB7XG4gICAgICAgIHNlZW5DZWxscy5hZGQoa2V5KTtcbiAgICAgICAgY29uc3QgaXNFbXB0eSA9ICRjZWxsQ29udGFpbnNFbXB0eVBhcmFncmFwaChjdXJyZW50Q2VsbCk7XG4gICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgIHRhcmdldENlbGwuYXBwZW5kKC4uLmN1cnJlbnRDZWxsLmdldENoaWxkcmVuKCkpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRDZWxsLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEVuc3VyZSB0YXJnZXQgY2VsbCBoYXMgY29udGVudFxuICBpZiAodGFyZ2V0Q2VsbC5nZXRDaGlsZHJlblNpemUoKSA9PT0gMCkge1xuICAgIHRhcmdldENlbGwuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG4gIHJldHVybiB0YXJnZXRDZWxsO1xufVxuZnVuY3Rpb24gJGNlbGxDb250YWluc0VtcHR5UGFyYWdyYXBoKGNlbGwpIHtcbiAgaWYgKGNlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgIT09IDEpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZmlyc3RDaGlsZCA9IGNlbGwuZ2V0Rmlyc3RDaGlsZE9yVGhyb3coKTtcbiAgaWYgKCEkaXNQYXJhZ3JhcGhOb2RlKGZpcnN0Q2hpbGQpIHx8ICFmaXJzdENoaWxkLmlzRW1wdHkoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICR1bm1lcmdlQ2VsbCgpIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBhIFJhbmdlU2VsZWN0aW9uIG9yIFRhYmxlU2VsZWN0aW9uYCk7XG4gIH1cbiAgY29uc3QgYW5jaG9yID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChhbmNob3IsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgfVxuICByZXR1cm4gJHVubWVyZ2VDZWxsTm9kZShjZWxsTm9kZSk7XG59XG5mdW5jdGlvbiAkdW5tZXJnZUNlbGxOb2RlKGNlbGxOb2RlKSB7XG4gIGNvbnN0IFtjZWxsLCByb3csIGdyaWRdID0gJGdldE5vZGVUcmlwbGV0KGNlbGxOb2RlKTtcbiAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuO1xuICBjb25zdCByb3dTcGFuID0gY2VsbC5fX3Jvd1NwYW47XG4gIGlmIChjb2xTcGFuID09PSAxICYmIHJvd1NwYW4gPT09IDEpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgW21hcCwgY2VsbE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKGdyaWQsIGNlbGwsIGNlbGwpO1xuICBjb25zdCB7XG4gICAgc3RhcnRDb2x1bW4sXG4gICAgc3RhcnRSb3dcbiAgfSA9IGNlbGxNYXA7XG4gIC8vIENyZWF0ZSBhIGhldXJpc3RpYyBmb3Igd2hhdCB0aGUgc3R5bGUgb2YgdGhlIHVubWVyZ2VkIGNlbGxzIHNob3VsZCBiZVxuICAvLyBiYXNlZCBvbiB3aGV0aGVyIGV2ZXJ5IHJvdyBvciBjb2x1bW4gYWxyZWFkeSBoYWQgdGhhdCBzdGF0ZSBiZWZvcmUgdGhlXG4gIC8vIHVubWVyZ2UuXG4gIGNvbnN0IGJhc2VDb2xTdHlsZSA9IGNlbGwuX19oZWFkZXJTdGF0ZSAmIFRhYmxlQ2VsbEhlYWRlclN0YXRlcy5DT0xVTU47XG4gIGNvbnN0IGNvbFN0eWxlcyA9IEFycmF5LmZyb20oe1xuICAgIGxlbmd0aDogY29sU3BhblxuICB9LCAoX3YsIGkpID0+IHtcbiAgICBsZXQgY29sU3R5bGUgPSBiYXNlQ29sU3R5bGU7XG4gICAgZm9yIChsZXQgcm93SWR4ID0gMDsgY29sU3R5bGUgIT09IDAgJiYgcm93SWR4IDwgbWFwLmxlbmd0aDsgcm93SWR4KyspIHtcbiAgICAgIGNvbFN0eWxlICY9IG1hcFtyb3dJZHhdW2kgKyBzdGFydENvbHVtbl0uY2VsbC5fX2hlYWRlclN0YXRlO1xuICAgIH1cbiAgICByZXR1cm4gY29sU3R5bGU7XG4gIH0pO1xuICBjb25zdCBiYXNlUm93U3R5bGUgPSBjZWxsLl9faGVhZGVyU3RhdGUgJiBUYWJsZUNlbGxIZWFkZXJTdGF0ZXMuUk9XO1xuICBjb25zdCByb3dTdHlsZXMgPSBBcnJheS5mcm9tKHtcbiAgICBsZW5ndGg6IHJvd1NwYW5cbiAgfSwgKF92LCBpKSA9PiB7XG4gICAgbGV0IHJvd1N0eWxlID0gYmFzZVJvd1N0eWxlO1xuICAgIGZvciAobGV0IGNvbElkeCA9IDA7IHJvd1N0eWxlICE9PSAwICYmIGNvbElkeCA8IG1hcFswXS5sZW5ndGg7IGNvbElkeCsrKSB7XG4gICAgICByb3dTdHlsZSAmPSBtYXBbaSArIHN0YXJ0Um93XVtjb2xJZHhdLmNlbGwuX19oZWFkZXJTdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJvd1N0eWxlO1xuICB9KTtcbiAgaWYgKGNvbFNwYW4gPiAxKSB7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBjb2xTcGFuOyBpKyspIHtcbiAgICAgIGNlbGwuaW5zZXJ0QWZ0ZXIoJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2ldIHwgcm93U3R5bGVzWzBdKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgIH1cbiAgICBjZWxsLnNldENvbFNwYW4oMSk7XG4gIH1cbiAgaWYgKHJvd1NwYW4gPiAxKSB7XG4gICAgbGV0IGN1cnJlbnRSb3dOb2RlO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICBjb25zdCBjdXJyZW50Um93ID0gc3RhcnRSb3cgKyBpO1xuICAgICAgY29uc3QgY3VycmVudFJvd01hcCA9IG1hcFtjdXJyZW50Um93XTtcbiAgICAgIGN1cnJlbnRSb3dOb2RlID0gKGN1cnJlbnRSb3dOb2RlIHx8IHJvdykuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKGN1cnJlbnRSb3dOb2RlKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIHJvdyBuZXh0IHNpYmxpbmcgdG8gYmUgYSByb3dgKTtcbiAgICAgIH1cbiAgICAgIGxldCBpbnNlcnRBZnRlckNlbGwgPSBudWxsO1xuICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgc3RhcnRDb2x1bW47IGNvbHVtbisrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsTWFwID0gY3VycmVudFJvd01hcFtjb2x1bW5dO1xuICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IGN1cnJlbnRDZWxsTWFwLmNlbGw7XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbE1hcC5zdGFydFJvdyA9PT0gY3VycmVudFJvdykge1xuICAgICAgICAgIGluc2VydEFmdGVyQ2VsbCA9IGN1cnJlbnRDZWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyZW50Q2VsbC5fX2NvbFNwYW4gPiAxKSB7XG4gICAgICAgICAgY29sdW1uICs9IGN1cnJlbnRDZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpbnNlcnRBZnRlckNlbGwgPT09IG51bGwpIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IGNvbFNwYW4gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgICAgICRpbnNlcnRGaXJzdChjdXJyZW50Um93Tm9kZSwgJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY29sU3R5bGVzW2pdIHwgcm93U3R5bGVzW2ldKS5hcHBlbmQoJGNyZWF0ZVBhcmFncmFwaE5vZGUoKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBqID0gY29sU3BhbiAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgaW5zZXJ0QWZ0ZXJDZWxsLmluc2VydEFmdGVyKCRjcmVhdGVUYWJsZUNlbGxOb2RlKGNvbFN0eWxlc1tqXSB8IHJvd1N0eWxlc1tpXSkuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gIH1cbn1cbmZ1bmN0aW9uICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBjZWxsQSwgY2VsbEIpIHtcbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsQVZhbHVlLCBjZWxsQlZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRhYmxlTm9kZSwgY2VsbEEsIGNlbGxCKTtcbiAgaWYgKCEoY2VsbEFWYWx1ZSAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEFuY2hvciBub3QgZm91bmQgaW4gVGFibGVgKTtcbiAgfVxuICBpZiAoIShjZWxsQlZhbHVlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRm9jdXMgbm90IGZvdW5kIGluIFRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIFt0YWJsZU1hcCwgY2VsbEFWYWx1ZSwgY2VsbEJWYWx1ZV07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayh0YWJsZU5vZGUsIGNlbGxBLCBjZWxsQikge1xuICBjb25zdCB0YWJsZU1hcCA9IFtdO1xuICBsZXQgY2VsbEFWYWx1ZSA9IG51bGw7XG4gIGxldCBjZWxsQlZhbHVlID0gbnVsbDtcbiAgZnVuY3Rpb24gZ2V0TWFwUm93KGkpIHtcbiAgICBsZXQgcm93ID0gdGFibGVNYXBbaV07XG4gICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YWJsZU1hcFtpXSA9IHJvdyA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcm93O1xuICB9XG4gIGNvbnN0IGdyaWRDaGlsZHJlbiA9IHRhYmxlTm9kZS5nZXRDaGlsZHJlbigpO1xuICBmb3IgKGxldCByb3dJZHggPSAwOyByb3dJZHggPCBncmlkQ2hpbGRyZW4ubGVuZ3RoOyByb3dJZHgrKykge1xuICAgIGNvbnN0IHJvdyA9IGdyaWRDaGlsZHJlbltyb3dJZHhdO1xuICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNoaWxkcmVuIHRvIGJlIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydE1hcFJvdyA9IGdldE1hcFJvdyhyb3dJZHgpO1xuICAgIGZvciAobGV0IGNlbGwgPSByb3cuZ2V0Rmlyc3RDaGlsZCgpLCBjb2xJZHggPSAwOyBjZWxsICE9IG51bGw7IGNlbGwgPSBjZWxsLmdldE5leHRTaWJsaW5nKCkpIHtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlUm93Tm9kZSBjaGlsZHJlbiB0byBiZSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICB9IC8vIFNraXAgcGFzdCBhbnkgY29sdW1ucyB0aGF0IHdlcmUgbWVyZ2VkIGZyb20gYSBoaWdoZXIgcm93XG4gICAgICB3aGlsZSAoc3RhcnRNYXBSb3dbY29sSWR4XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbElkeCsrO1xuICAgICAgfVxuICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgIGNlbGwsXG4gICAgICAgIHN0YXJ0Q29sdW1uOiBjb2xJZHgsXG4gICAgICAgIHN0YXJ0Um93OiByb3dJZHhcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIF9fcm93U3Bhbjogcm93U3BhbixcbiAgICAgICAgX19jb2xTcGFuOiBjb2xTcGFuXG4gICAgICB9ID0gY2VsbDtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcm93U3BhbjsgaisrKSB7XG4gICAgICAgIGlmIChyb3dJZHggKyBqID49IGdyaWRDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBUaGUgdGFibGUgaXMgbm9uLXJlY3Rhbmd1bGFyIHdpdGggYSByb3dTcGFuXG4gICAgICAgICAgLy8gYmVsb3cgdGhlIGxhc3QgPHRyPiBpbiB0aGUgdGFibGUuXG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGhhbmRsZSB0aGlzIHdpdGggYSBub2RlIHRyYW5zZm9ybVxuICAgICAgICAgIC8vIHRvIGVuc3VyZSB0aGF0IHRhYmxlcyBhcmUgYWx3YXlzIHJlY3Rhbmd1bGFyIGJ1dCB0aGlzXG4gICAgICAgICAgLy8gd2lsbCBhdm9pZCBjcmFzaGVzIHN1Y2ggYXMgIzY1ODRcbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhlcmUgYXJlIHByb2JhYmx5IHN0aWxsIGxhdGVudCBidWdzXG4gICAgICAgICAgLy8gcmVnYXJkaW5nIGNvbFNwYW4gb3IgZ2VuZXJhbCBjZWxsIGNvdW50IG1pc21hdGNoZXMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWFwUm93ID0gZ2V0TWFwUm93KHJvd0lkeCArIGopO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbFNwYW47IGkrKykge1xuICAgICAgICAgIG1hcFJvd1tjb2xJZHggKyBpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEEgIT09IG51bGwgJiYgY2VsbEFWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQS5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQVZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoY2VsbEIgIT09IG51bGwgJiYgY2VsbEJWYWx1ZSA9PT0gbnVsbCAmJiBjZWxsQi5pcyhjZWxsKSkge1xuICAgICAgICBjZWxsQlZhbHVlID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbdGFibGVNYXAsIGNlbGxBVmFsdWUsIGNlbGxCVmFsdWVdO1xufVxuZnVuY3Rpb24gJGdldE5vZGVUcmlwbGV0KHNvdXJjZSkge1xuICBsZXQgY2VsbDtcbiAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFRhYmxlQ2VsbE5vZGUpIHtcbiAgICBjZWxsID0gc291cmNlO1xuICB9IGVsc2UgaWYgKCdfX3R5cGUnIGluIHNvdXJjZSkge1xuICAgIGNvbnN0IGNlbGxfID0gJGZpbmRNYXRjaGluZ1BhcmVudChzb3VyY2UsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShjZWxsXykpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgdG8gZmluZCBhIHBhcmVudCBUYWJsZUNlbGxOb2RlYCk7XG4gICAgfVxuICAgIGNlbGwgPSBjZWxsXztcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjZWxsXyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc291cmNlLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxfKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIGEgcGFyZW50IFRhYmxlQ2VsbE5vZGVgKTtcbiAgICB9XG4gICAgY2VsbCA9IGNlbGxfO1xuICB9XG4gIGNvbnN0IHJvdyA9IGNlbGwuZ2V0UGFyZW50KCk7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlQ2VsbE5vZGUgdG8gaGF2ZSBhIHBhcmVudCBUYWJsZVJvd05vZGVgKTtcbiAgfVxuICBjb25zdCBncmlkID0gcm93LmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlTm9kZShncmlkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVSb3dOb2RlIHRvIGhhdmUgYSBwYXJlbnQgVGFibGVOb2RlYCk7XG4gIH1cbiAgcmV0dXJuIFtjZWxsLCByb3csIGdyaWRdO1xufVxuZnVuY3Rpb24gJGNvbXB1dGVUYWJsZUNlbGxSZWN0U3BhbnMobWFwLCBib3VuZGFyeSkge1xuICBjb25zdCB7XG4gICAgbWluQ29sdW1uLFxuICAgIG1heENvbHVtbixcbiAgICBtaW5Sb3csXG4gICAgbWF4Um93XG4gIH0gPSBib3VuZGFyeTtcbiAgbGV0IHRvcFNwYW4gPSAxO1xuICBsZXQgbGVmdFNwYW4gPSAxO1xuICBsZXQgcmlnaHRTcGFuID0gMTtcbiAgbGV0IGJvdHRvbVNwYW4gPSAxO1xuICBjb25zdCB0b3BSb3cgPSBtYXBbbWluUm93XTtcbiAgY29uc3QgYm90dG9tUm93ID0gbWFwW21heFJvd107XG4gIGZvciAobGV0IGNvbCA9IG1pbkNvbHVtbjsgY29sIDw9IG1heENvbHVtbjsgY29sKyspIHtcbiAgICB0b3BTcGFuID0gTWF0aC5tYXgodG9wU3BhbiwgdG9wUm93W2NvbF0uY2VsbC5fX3Jvd1NwYW4pO1xuICAgIGJvdHRvbVNwYW4gPSBNYXRoLm1heChib3R0b21TcGFuLCBib3R0b21Sb3dbY29sXS5jZWxsLl9fcm93U3Bhbik7XG4gIH1cbiAgZm9yIChsZXQgcm93ID0gbWluUm93OyByb3cgPD0gbWF4Um93OyByb3crKykge1xuICAgIGxlZnRTcGFuID0gTWF0aC5tYXgobGVmdFNwYW4sIG1hcFtyb3ddW21pbkNvbHVtbl0uY2VsbC5fX2NvbFNwYW4pO1xuICAgIHJpZ2h0U3BhbiA9IE1hdGgubWF4KHJpZ2h0U3BhbiwgbWFwW3Jvd11bbWF4Q29sdW1uXS5jZWxsLl9fY29sU3Bhbik7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBib3R0b21TcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIHJpZ2h0U3BhbixcbiAgICB0b3BTcGFuXG4gIH07XG59XG5mdW5jdGlvbiAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RCb3VuZGFyeShtYXAsIGNlbGxBTWFwLCBjZWxsQk1hcCkge1xuICAvLyBJbml0aWFsIGJvdW5kYXJpZXMgYmFzZWQgb24gdGhlIGFuY2hvciBhbmQgZm9jdXMgY2VsbHNcbiAgbGV0IG1pbkNvbHVtbiA9IE1hdGgubWluKGNlbGxBTWFwLnN0YXJ0Q29sdW1uLCBjZWxsQk1hcC5zdGFydENvbHVtbik7XG4gIGxldCBtaW5Sb3cgPSBNYXRoLm1pbihjZWxsQU1hcC5zdGFydFJvdywgY2VsbEJNYXAuc3RhcnRSb3cpO1xuICBsZXQgbWF4Q29sdW1uID0gTWF0aC5tYXgoY2VsbEFNYXAuc3RhcnRDb2x1bW4gKyBjZWxsQU1hcC5jZWxsLl9fY29sU3BhbiAtIDEsIGNlbGxCTWFwLnN0YXJ0Q29sdW1uICsgY2VsbEJNYXAuY2VsbC5fX2NvbFNwYW4gLSAxKTtcbiAgbGV0IG1heFJvdyA9IE1hdGgubWF4KGNlbGxBTWFwLnN0YXJ0Um93ICsgY2VsbEFNYXAuY2VsbC5fX3Jvd1NwYW4gLSAxLCBjZWxsQk1hcC5zdGFydFJvdyArIGNlbGxCTWFwLmNlbGwuX19yb3dTcGFuIC0gMSk7XG5cbiAgLy8gS2VlcCBleHBhbmRpbmcgdW50aWwgd2UgaGF2ZSBhIGNvbXBsZXRlIHJlY3RhbmdsZVxuICBsZXQgaGFzQ2hhbmdlcztcbiAgZG8ge1xuICAgIGhhc0NoYW5nZXMgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGFsbCBjZWxscyBpbiB0aGUgdGFibGVcbiAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBtYXAubGVuZ3RoOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgbWFwWzBdLmxlbmd0aDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IG1hcFtyb3ddW2NvbF07XG4gICAgICAgIGlmICghY2VsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNlbGxFbmRDb2wgPSBjZWxsLnN0YXJ0Q29sdW1uICsgY2VsbC5jZWxsLl9fY29sU3BhbiAtIDE7XG4gICAgICAgIGNvbnN0IGNlbGxFbmRSb3cgPSBjZWxsLnN0YXJ0Um93ICsgY2VsbC5jZWxsLl9fcm93U3BhbiAtIDE7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjZWxsIGludGVyc2VjdHMgd2l0aCBvdXIgY3VycmVudCBzZWxlY3Rpb24gcmVjdGFuZ2xlXG4gICAgICAgIGNvbnN0IGludGVyc2VjdHNIb3Jpem9udGFsbHkgPSBjZWxsLnN0YXJ0Q29sdW1uIDw9IG1heENvbHVtbiAmJiBjZWxsRW5kQ29sID49IG1pbkNvbHVtbjtcbiAgICAgICAgY29uc3QgaW50ZXJzZWN0c1ZlcnRpY2FsbHkgPSBjZWxsLnN0YXJ0Um93IDw9IG1heFJvdyAmJiBjZWxsRW5kUm93ID49IG1pblJvdztcblxuICAgICAgICAvLyBJZiB0aGUgY2VsbCBpbnRlcnNlY3RzIGVpdGhlciBob3Jpem9udGFsbHkgb3IgdmVydGljYWxseVxuICAgICAgICBpZiAoaW50ZXJzZWN0c0hvcml6b250YWxseSAmJiBpbnRlcnNlY3RzVmVydGljYWxseSkge1xuICAgICAgICAgIC8vIEV4cGFuZCBib3VuZGFyaWVzIHRvIGluY2x1ZGUgdGhpcyBjZWxsIGNvbXBsZXRlbHlcbiAgICAgICAgICBjb25zdCBuZXdNaW5Db2x1bW4gPSBNYXRoLm1pbihtaW5Db2x1bW4sIGNlbGwuc3RhcnRDb2x1bW4pO1xuICAgICAgICAgIGNvbnN0IG5ld01heENvbHVtbiA9IE1hdGgubWF4KG1heENvbHVtbiwgY2VsbEVuZENvbCk7XG4gICAgICAgICAgY29uc3QgbmV3TWluUm93ID0gTWF0aC5taW4obWluUm93LCBjZWxsLnN0YXJ0Um93KTtcbiAgICAgICAgICBjb25zdCBuZXdNYXhSb3cgPSBNYXRoLm1heChtYXhSb3csIGNlbGxFbmRSb3cpO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgaWYgYm91bmRhcmllcyBjaGFuZ2VkXG4gICAgICAgICAgaWYgKG5ld01pbkNvbHVtbiAhPT0gbWluQ29sdW1uIHx8IG5ld01heENvbHVtbiAhPT0gbWF4Q29sdW1uIHx8IG5ld01pblJvdyAhPT0gbWluUm93IHx8IG5ld01heFJvdyAhPT0gbWF4Um93KSB7XG4gICAgICAgICAgICBtaW5Db2x1bW4gPSBuZXdNaW5Db2x1bW47XG4gICAgICAgICAgICBtYXhDb2x1bW4gPSBuZXdNYXhDb2x1bW47XG4gICAgICAgICAgICBtaW5Sb3cgPSBuZXdNaW5Sb3c7XG4gICAgICAgICAgICBtYXhSb3cgPSBuZXdNYXhSb3c7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gd2hpbGUgKGhhc0NoYW5nZXMpO1xuICByZXR1cm4ge1xuICAgIG1heENvbHVtbixcbiAgICBtYXhSb3csXG4gICAgbWluQ29sdW1uLFxuICAgIG1pblJvd1xuICB9O1xufVxuZnVuY3Rpb24gJGdldFRhYmxlQ2VsbE5vZGVSZWN0KHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3QgW2NlbGxOb2RlLCwgZ3JpZE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KHRhYmxlQ2VsbE5vZGUpO1xuICBjb25zdCByb3dzID0gZ3JpZE5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgY29uc3Qgcm93Q291bnQgPSByb3dzLmxlbmd0aDtcbiAgY29uc3QgY29sdW1uQ291bnQgPSByb3dzWzBdLmdldENoaWxkcmVuKCkubGVuZ3RoO1xuXG4gIC8vIENyZWF0ZSBhIG1hdHJpeCBvZiB0aGUgc2FtZSBzaXplIGFzIHRoZSB0YWJsZSB0byB0cmFjayB0aGUgcG9zaXRpb24gb2YgZWFjaCBjZWxsXG4gIGNvbnN0IGNlbGxNYXRyaXggPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBjZWxsTWF0cml4W2ldID0gbmV3IEFycmF5KGNvbHVtbkNvdW50KTtcbiAgfVxuICBmb3IgKGxldCByb3dJbmRleCA9IDA7IHJvd0luZGV4IDwgcm93Q291bnQ7IHJvd0luZGV4KyspIHtcbiAgICBjb25zdCByb3cgPSByb3dzW3Jvd0luZGV4XTtcbiAgICBjb25zdCBjZWxscyA9IHJvdy5nZXRDaGlsZHJlbigpO1xuICAgIGxldCBjb2x1bW5JbmRleCA9IDA7XG4gICAgZm9yIChsZXQgY2VsbEluZGV4ID0gMDsgY2VsbEluZGV4IDwgY2VsbHMubGVuZ3RoOyBjZWxsSW5kZXgrKykge1xuICAgICAgLy8gRmluZCB0aGUgbmV4dCBhdmFpbGFibGUgcG9zaXRpb24gaW4gdGhlIG1hdHJpeCwgc2tpcCB0aGUgcG9zaXRpb24gb2YgbWVyZ2VkIGNlbGxzXG4gICAgICB3aGlsZSAoY2VsbE1hdHJpeFtyb3dJbmRleF1bY29sdW1uSW5kZXhdKSB7XG4gICAgICAgIGNvbHVtbkluZGV4Kys7XG4gICAgICB9XG4gICAgICBjb25zdCBjZWxsID0gY2VsbHNbY2VsbEluZGV4XTtcbiAgICAgIGNvbnN0IHJvd1NwYW4gPSBjZWxsLl9fcm93U3BhbiB8fCAxO1xuICAgICAgY29uc3QgY29sU3BhbiA9IGNlbGwuX19jb2xTcGFuIHx8IDE7XG5cbiAgICAgIC8vIFB1dCB0aGUgY2VsbCBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uIGluIHRoZSBtYXRyaXhcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93U3BhbjsgaSsrKSB7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sU3BhbjsgaisrKSB7XG4gICAgICAgICAgY2VsbE1hdHJpeFtyb3dJbmRleCArIGldW2NvbHVtbkluZGV4ICsgal0gPSBjZWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0byB0aGUgb3JpZ2luYWwgaW5kZXgsIHJvdyBzcGFuIGFuZCBjb2x1bW4gc3BhbiBvZiB0aGUgY2VsbC5cbiAgICAgIGlmIChjZWxsTm9kZSA9PT0gY2VsbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbFNwYW4sXG4gICAgICAgICAgY29sdW1uSW5kZXgsXG4gICAgICAgICAgcm93SW5kZXgsXG4gICAgICAgICAgcm93U3BhblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29sdW1uSW5kZXggKz0gY29sU3BhbjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uICRnZXRDZWxsTm9kZXModGFibGVTZWxlY3Rpb24pIHtcbiAgY29uc3QgW1thbmNob3JOb2RlLCBhbmNob3JDZWxsLCBhbmNob3JSb3csIGFuY2hvclRhYmxlXSwgW2ZvY3VzTm9kZSwgZm9jdXNDZWxsLCBmb2N1c1JvdywgZm9jdXNUYWJsZV1dID0gWydhbmNob3InLCAnZm9jdXMnXS5tYXAoayA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHRhYmxlU2VsZWN0aW9uW2tdLmdldE5vZGUoKTtcbiAgICBjb25zdCBjZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGxOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZVNlbGVjdGlvbiAke2t9IHRvIGJlIChvciBhIGNoaWxkIG9mKSBUYWJsZUNlbGxOb2RlLCBnb3Qga2V5ICR7bm9kZS5nZXRLZXkoKX0gb2YgdHlwZSAke25vZGUuZ2V0VHlwZSgpfWApO1xuICAgIH1cbiAgICBjb25zdCByb3dOb2RlID0gY2VsbE5vZGUuZ2V0UGFyZW50KCk7XG4gICAgaWYgKCEkaXNUYWJsZVJvd05vZGUocm93Tm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSBjZWxsIHBhcmVudCB0byBiZSBhIFRhYmxlUm93Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZU5vZGUgPSByb3dOb2RlLmdldFBhcmVudCgpO1xuICAgIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gJHtrfSByb3cgcGFyZW50IHRvIGJlIGEgVGFibGVOb2RlYCk7XG4gICAgfVxuICAgIHJldHVybiBbbm9kZSwgY2VsbE5vZGUsIHJvd05vZGUsIHRhYmxlTm9kZV07XG4gIH0pO1xuICAvLyBUT0RPOiBuZXN0ZWQgdGFibGVzIG1heSB2aW9sYXRlIHRoaXNcbiAgaWYgKCFhbmNob3JUYWJsZS5pcyhmb2N1c1RhYmxlKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gYW5jaG9yIGFuZCBmb2N1cyB0byBiZSBpbiB0aGUgc2FtZSB0YWJsZWApO1xuICB9XG4gIHJldHVybiB7XG4gICAgYW5jaG9yQ2VsbCxcbiAgICBhbmNob3JOb2RlLFxuICAgIGFuY2hvclJvdyxcbiAgICBhbmNob3JUYWJsZSxcbiAgICBmb2N1c0NlbGwsXG4gICAgZm9jdXNOb2RlLFxuICAgIGZvY3VzUm93LFxuICAgIGZvY3VzVGFibGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlU2VsZWN0aW9uIHtcbiAgY29uc3RydWN0b3IodGFibGVLZXksIGFuY2hvciwgZm9jdXMpIHtcbiAgICB0aGlzLmFuY2hvciA9IGFuY2hvcjtcbiAgICB0aGlzLmZvY3VzID0gZm9jdXM7XG4gICAgYW5jaG9yLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIGZvY3VzLl9zZWxlY3Rpb24gPSB0aGlzO1xuICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbnVsbDtcbiAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy50YWJsZUtleSA9IHRhYmxlS2V5O1xuICB9XG4gIGdldFN0YXJ0RW5kUG9pbnRzKCkge1xuICAgIHJldHVybiBbdGhpcy5hbmNob3IsIHRoaXMuZm9jdXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIHtAbGluayAkY3JlYXRlVGFibGVTZWxlY3Rpb259IHVuZm9ydHVuYXRlbHkgbWFrZXMgaXQgdmVyeSBlYXN5IHRvIGNyZWF0ZVxuICAgKiBub25zZW5zZSBzZWxlY3Rpb25zLCBzbyB3ZSBoYXZlIGEgbWV0aG9kIHRvIHNlZSBpZiB0aGUgc2VsZWN0aW9uIHByb2JhYmx5XG4gICAqIG1ha2VzIHNlbnNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBUYWJsZVNlbGVjdGlvbiBpcyAocHJvYmFibHkpIHZhbGlkXG4gICAqL1xuICBpc1ZhbGlkKCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlS2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3Iua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5hbmNob3IudHlwZSA9PT0gJ2VsZW1lbnQnICYmIHRoaXMuZm9jdXMua2V5ICE9PSAncm9vdCcgJiYgdGhpcy5mb2N1cy50eXBlID09PSAnZWxlbWVudCc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBTZWxlY3Rpb24gaXMgXCJiYWNrd2FyZHNcIiwgbWVhbmluZyB0aGUgZm9jdXNcbiAgICogbG9naWNhbGx5IHByZWNlZGVzIHRoZSBhbmNob3IgaW4gdGhlIEVkaXRvclN0YXRlLlxuICAgKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBTZWxlY3Rpb24gaXMgYmFja3dhcmRzLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc0JhY2t3YXJkKCkge1xuICAgIHJldHVybiB0aGlzLmZvY3VzLmlzQmVmb3JlKHRoaXMuYW5jaG9yKTtcbiAgfVxuICBnZXRDYWNoZWROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkTm9kZXM7XG4gIH1cbiAgc2V0Q2FjaGVkTm9kZXMobm9kZXMpIHtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG5vZGVzO1xuICB9XG4gIGlzKHNlbGVjdGlvbikge1xuICAgIHJldHVybiAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmIHRoaXMudGFibGVLZXkgPT09IHNlbGVjdGlvbi50YWJsZUtleSAmJiB0aGlzLmFuY2hvci5pcyhzZWxlY3Rpb24uYW5jaG9yKSAmJiB0aGlzLmZvY3VzLmlzKHNlbGVjdGlvbi5mb2N1cyk7XG4gIH1cbiAgc2V0KHRhYmxlS2V5LCBhbmNob3JDZWxsS2V5LCBmb2N1c0NlbGxLZXkpIHtcbiAgICAvLyBub3RlOiBjbG9zdXJlIGNvbXBpbGVyJ3MgYWNvcm4gZG9lcyBub3Qgc3VwcG9ydCB8fD1cbiAgICB0aGlzLmRpcnR5ID0gdGhpcy5kaXJ0eSB8fCB0YWJsZUtleSAhPT0gdGhpcy50YWJsZUtleSB8fCBhbmNob3JDZWxsS2V5ICE9PSB0aGlzLmFuY2hvci5rZXkgfHwgZm9jdXNDZWxsS2V5ICE9PSB0aGlzLmZvY3VzLmtleTtcbiAgICB0aGlzLnRhYmxlS2V5ID0gdGFibGVLZXk7XG4gICAgdGhpcy5hbmNob3Iua2V5ID0gYW5jaG9yQ2VsbEtleTtcbiAgICB0aGlzLmZvY3VzLmtleSA9IGZvY3VzQ2VsbEtleTtcbiAgICB0aGlzLl9jYWNoZWROb2RlcyA9IG51bGw7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZVNlbGVjdGlvbih0aGlzLnRhYmxlS2V5LCAkY3JlYXRlUG9pbnQodGhpcy5hbmNob3Iua2V5LCB0aGlzLmFuY2hvci5vZmZzZXQsIHRoaXMuYW5jaG9yLnR5cGUpLCAkY3JlYXRlUG9pbnQodGhpcy5mb2N1cy5rZXksIHRoaXMuZm9jdXMub2Zmc2V0LCB0aGlzLmZvY3VzLnR5cGUpKTtcbiAgfVxuICBpc0NvbGxhcHNlZCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZXh0cmFjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXROb2RlcygpO1xuICB9XG4gIGluc2VydFJhd1RleHQodGV4dCkge1xuICAgIC8vIERvIG5vdGhpbmc/XG4gIH1cbiAgaW5zZXJ0VGV4dCgpIHtcbiAgICAvLyBEbyBub3RoaW5nP1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgcHJvdmlkZWQgVGV4dEZvcm1hdFR5cGUgaXMgcHJlc2VudCBvbiB0aGUgU2VsZWN0aW9uLlxuICAgKiBUaGlzIHdpbGwgYmUgdHJ1ZSBpZiBhbnkgcGFyYWdyYXBoIGluIHRhYmxlIGNlbGxzIGhhcyB0aGUgc3BlY2lmaWVkIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHR5cGUgdGhlIFRleHRGb3JtYXRUeXBlIHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgZm9ybWF0IGlzIGN1cnJlbnRseSB0b2dnbGVkIG9uIG9uIHRoZSBTZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGhhc0Zvcm1hdCh0eXBlKSB7XG4gICAgbGV0IGZvcm1hdCA9IDA7XG4gICAgY29uc3QgY2VsbE5vZGVzID0gdGhpcy5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBjZWxsTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoJGlzUGFyYWdyYXBoTm9kZShwYXJhZ3JhcGgpKSB7XG4gICAgICAgIGZvcm1hdCB8PSBwYXJhZ3JhcGguZ2V0VGV4dEZvcm1hdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGZvcm1hdEZsYWcgPSBURVhUX1RZUEVfVE9fRk9STUFUW3R5cGVdO1xuICAgIHJldHVybiAoZm9ybWF0ICYgZm9ybWF0RmxhZykgIT09IDA7XG4gIH1cbiAgaW5zZXJ0Tm9kZXMobm9kZXMpIHtcbiAgICBjb25zdCBmb2N1c05vZGUgPSB0aGlzLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc0VsZW1lbnROb2RlKGZvY3VzTm9kZSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb24gZm9jdXMgdG8gYmUgYW4gRWxlbWVudE5vZGVgKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGZvY3VzTm9kZS5zZWxlY3QoMCwgZm9jdXNOb2RlLmdldENoaWxkcmVuU2l6ZSgpKSk7XG4gICAgc2VsZWN0aW9uLmluc2VydE5vZGVzKG5vZGVzKTtcbiAgfVxuXG4gIC8vIFRPRE8gRGVwcmVjYXRlIHRoaXMgbWV0aG9kLiBJdCdzIGNvbmZ1c2luZyB3aGVuIHVzZWQgd2l0aCBjb2xzcGFufHJvd3NwYW5cbiAgZ2V0U2hhcGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlUmVjdCA9ICRnZXRUYWJsZUNlbGxOb2RlUmVjdChhbmNob3JDZWxsKTtcbiAgICBpZiAoIShhbmNob3JDZWxsTm9kZVJlY3QgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGdldENlbGxSZWN0OiBleHBlY3RlZCB0byBmaW5kIEFuY2hvck5vZGVgKTtcbiAgICB9XG4gICAgY29uc3QgZm9jdXNDZWxsTm9kZVJlY3QgPSAkZ2V0VGFibGVDZWxsTm9kZVJlY3QoZm9jdXNDZWxsKTtcbiAgICBpZiAoIShmb2N1c0NlbGxOb2RlUmVjdCAhPT0gbnVsbCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q2VsbFJlY3Q6IGV4cGVjdGVkIHRvIGZpbmQgZm9jdXNDZWxsTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBzdGFydFggPSBNYXRoLm1pbihhbmNob3JDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXgsIGZvY3VzQ2VsbE5vZGVSZWN0LmNvbHVtbkluZGV4KTtcbiAgICBjb25zdCBzdG9wWCA9IE1hdGgubWF4KGFuY2hvckNlbGxOb2RlUmVjdC5jb2x1bW5JbmRleCArIGFuY2hvckNlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSwgZm9jdXNDZWxsTm9kZVJlY3QuY29sdW1uSW5kZXggKyBmb2N1c0NlbGxOb2RlUmVjdC5jb2xTcGFuIC0gMSk7XG4gICAgY29uc3Qgc3RhcnRZID0gTWF0aC5taW4oYW5jaG9yQ2VsbE5vZGVSZWN0LnJvd0luZGV4LCBmb2N1c0NlbGxOb2RlUmVjdC5yb3dJbmRleCk7XG4gICAgY29uc3Qgc3RvcFkgPSBNYXRoLm1heChhbmNob3JDZWxsTm9kZVJlY3Qucm93SW5kZXggKyBhbmNob3JDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEsIGZvY3VzQ2VsbE5vZGVSZWN0LnJvd0luZGV4ICsgZm9jdXNDZWxsTm9kZVJlY3Qucm93U3BhbiAtIDEpO1xuICAgIHJldHVybiB7XG4gICAgICBmcm9tWDogTWF0aC5taW4oc3RhcnRYLCBzdG9wWCksXG4gICAgICBmcm9tWTogTWF0aC5taW4oc3RhcnRZLCBzdG9wWSksXG4gICAgICB0b1g6IE1hdGgubWF4KHN0YXJ0WCwgc3RvcFgpLFxuICAgICAgdG9ZOiBNYXRoLm1heChzdGFydFksIHN0b3BZKVxuICAgIH07XG4gIH1cbiAgZ2V0Tm9kZXMoKSB7XG4gICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZWROb2RlcyA9IHRoaXMuX2NhY2hlZE5vZGVzO1xuICAgIGlmIChjYWNoZWROb2RlcyAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGNhY2hlZE5vZGVzO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbmNob3JUYWJsZTogdGFibGVOb2RlLFxuICAgICAgYW5jaG9yQ2VsbCxcbiAgICAgIGZvY3VzQ2VsbFxuICAgIH0gPSAkZ2V0Q2VsbE5vZGVzKHRoaXMpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbEdyaWQgPSBmb2N1c0NlbGwuZ2V0UGFyZW50cygpWzFdO1xuICAgIGlmIChmb2N1c0NlbGxHcmlkICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgIGlmICghdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNDZWxsKSkge1xuICAgICAgICAvLyBmb2N1cyBpcyBvbiBoaWdoZXIgR3JpZCBsZXZlbCB0aGFuIGFuY2hvclxuICAgICAgICBjb25zdCBncmlkUGFyZW50ID0gdGFibGVOb2RlLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoIShncmlkUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBncmlkUGFyZW50IHRvIGhhdmUgYSBwYXJlbnRgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldCh0aGlzLnRhYmxlS2V5LCBncmlkUGFyZW50LmdldEtleSgpLCBmb2N1c0NlbGwuZ2V0S2V5KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYW5jaG9yIGlzIG9uIGhpZ2hlciBHcmlkIGxldmVsIHRoYW4gZm9jdXNcbiAgICAgICAgY29uc3QgZm9jdXNDZWxsUGFyZW50ID0gZm9jdXNDZWxsR3JpZC5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKCEoZm9jdXNDZWxsUGFyZW50ICE9IG51bGwpKSB7XG4gICAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBmb2N1c0NlbGxQYXJlbnQgdG8gaGF2ZSBhIHBhcmVudGApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMudGFibGVLZXksIGZvY3VzQ2VsbC5nZXRLZXkoKSwgZm9jdXNDZWxsUGFyZW50LmdldEtleSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldE5vZGVzKCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBNYXBwaW5nIHRoZSB3aG9sZSBHcmlkIGV2ZXJ5IHRpbWUgbm90IGVmZmljaWVudC4gV2UgbmVlZCB0byBjb21wdXRlIHRoZSBlbnRpcmUgc3RhdGUgb25seVxuICAgIC8vIG9uY2UgKG9uIGxvYWQpIGFuZCBpdGVyYXRlIG9uIGl0IGFzIHVwZGF0ZXMgb2NjdXIuIEhvd2V2ZXIsIHRvIGRvIHRoaXMgd2UgbmVlZCB0byBoYXZlIHRoZVxuICAgIC8vIGFiaWxpdHkgdG8gc3RvcmUgYSBzdGF0ZS4gS2lsbGluZyBUYWJsZVNlbGVjdGlvbiBhbmQgbW92aW5nIHRoZSBsb2dpYyB0byB0aGUgcGx1Z2luIHdvdWxkIG1ha2VcbiAgICAvLyB0aGlzIHBvc3NpYmxlLlxuICAgIGNvbnN0IFttYXAsIGNlbGxBTWFwLCBjZWxsQk1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKTtcbiAgICBjb25zdCB7XG4gICAgICBtaW5Db2x1bW4sXG4gICAgICBtYXhDb2x1bW4sXG4gICAgICBtaW5Sb3csXG4gICAgICBtYXhSb3dcbiAgICB9ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkobWFwLCBjZWxsQU1hcCwgY2VsbEJNYXApO1xuXG4gICAgLy8gV2UgdXNlIGEgTWFwIGhlcmUgYmVjYXVzZSBtZXJnZWQgY2VsbHMgaW4gdGhlIGdyaWQgd291bGQgb3RoZXJ3aXNlXG4gICAgLy8gc2hvdyB1cCBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgbm9kZXMgYXJyYXlcbiAgICBjb25zdCBub2RlTWFwID0gbmV3IE1hcChbW3RhYmxlTm9kZS5nZXRLZXkoKSwgdGFibGVOb2RlXV0pO1xuICAgIGxldCBsYXN0Um93ID0gbnVsbDtcbiAgICBmb3IgKGxldCBpID0gbWluUm93OyBpIDw9IG1heFJvdzsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gbWluQ29sdW1uOyBqIDw9IG1heENvbHVtbjsgaisrKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjZWxsXG4gICAgICAgIH0gPSBtYXBbaV1bal07XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSb3cgPSBjZWxsLmdldFBhcmVudCgpO1xuICAgICAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShjdXJyZW50Um93KSkge1xuICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVDZWxsTm9kZSBwYXJlbnQgdG8gYmUgYSBUYWJsZVJvd05vZGVgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbGFzdFJvdykge1xuICAgICAgICAgIG5vZGVNYXAuc2V0KGN1cnJlbnRSb3cuZ2V0S2V5KCksIGN1cnJlbnRSb3cpO1xuICAgICAgICAgIGxhc3RSb3cgPSBjdXJyZW50Um93O1xuICAgICAgICB9XG4gICAgICAgIGlmICghbm9kZU1hcC5oYXMoY2VsbC5nZXRLZXkoKSkpIHtcbiAgICAgICAgICAkdmlzaXRSZWN1cnNpdmVseShjZWxsLCBjaGlsZE5vZGUgPT4ge1xuICAgICAgICAgICAgbm9kZU1hcC5zZXQoY2hpbGROb2RlLmdldEtleSgpLCBjaGlsZE5vZGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vZGVzID0gQXJyYXkuZnJvbShub2RlTWFwLnZhbHVlcygpKTtcbiAgICBpZiAoIWlzQ3VycmVudGx5UmVhZE9ubHlNb2RlKCkpIHtcbiAgICAgIHRoaXMuX2NhY2hlZE5vZGVzID0gbm9kZXM7XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBnZXRUZXh0Q29udGVudCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHRoaXMuZ2V0Tm9kZXMoKS5maWx0ZXIobm9kZSA9PiAkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKTtcbiAgICBsZXQgdGV4dENvbnRlbnQgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICBjb25zdCByb3cgPSBub2RlLl9fcGFyZW50O1xuICAgICAgY29uc3QgbmV4dFJvdyA9IChub2Rlc1tpICsgMV0gfHwge30pLl9fcGFyZW50O1xuICAgICAgdGV4dENvbnRlbnQgKz0gbm9kZS5nZXRUZXh0Q29udGVudCgpICsgKG5leHRSb3cgIT09IHJvdyA/ICdcXG4nIDogJ1xcdCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dENvbnRlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRpc1RhYmxlU2VsZWN0aW9uKHgpIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBUYWJsZVNlbGVjdGlvbjtcbn1cbmZ1bmN0aW9uICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpIHtcbiAgLy8gVE9ETyB0aGlzIGlzIGEgc3Vib3B0aW1hbCBkZXNpZ24sIGl0IGRvZXNuJ3QgbWFrZSBzZW5zZSB0byBoYXZlXG4gIC8vIGEgdGFibGUgc2VsZWN0aW9uIHRoYXQgaXNuJ3QgYXNzb2NpYXRlZCB3aXRoIGEgdGFibGUuIFRoaXNcbiAgLy8gY29uc3RydWN0b3Igc2hvdWxkIGhhdmUgcmVxdWlyZWQgYXJndW1lbnRzIGFuZCBpbiB0cnVlIHdlXG4gIC8vIHNob3VsZCBjaGVjayB0aGF0IHRoZXkgcG9pbnQgdG8gYSB0YWJsZSBhbmQgYXJlIGVsZW1lbnQgcG9pbnRzIHRvXG4gIC8vIGNlbGwgbm9kZXMgb2YgdGhhdCB0YWJsZS5cbiAgY29uc3QgYW5jaG9yID0gJGNyZWF0ZVBvaW50KCdyb290JywgMCwgJ2VsZW1lbnQnKTtcbiAgY29uc3QgZm9jdXMgPSAkY3JlYXRlUG9pbnQoJ3Jvb3QnLCAwLCAnZWxlbWVudCcpO1xuICByZXR1cm4gbmV3IFRhYmxlU2VsZWN0aW9uKCdyb290JywgYW5jaG9yLCBmb2N1cyk7XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgYW5jaG9yQ2VsbCwgZm9jdXNDZWxsKSB7XG4gIGNvbnN0IHRhYmxlTm9kZUtleSA9IHRhYmxlTm9kZS5nZXRLZXkoKTtcbiAgY29uc3QgYW5jaG9yQ2VsbEtleSA9IGFuY2hvckNlbGwuZ2V0S2V5KCk7XG4gIGNvbnN0IGZvY3VzQ2VsbEtleSA9IGZvY3VzQ2VsbC5nZXRLZXkoKTtcbiAge1xuICAgIGlmICghdGFibGVOb2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tOiB0YWJsZU5vZGUgJHt0YWJsZU5vZGVLZXl9IGlzIG5vdCBhdHRhY2hlZGApO1xuICAgIH1cbiAgICBpZiAoIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogYW5jaG9yQ2VsbCAke2FuY2hvckNlbGxLZXl9IGlzIG5vdCBpbiB0YWJsZSAke3RhYmxlTm9kZUtleX1gKTtcbiAgICB9XG4gICAgaWYgKCF0YWJsZU5vZGUuaXMoJGZpbmRUYWJsZU5vZGUoZm9jdXNDZWxsKSkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGNyZWF0ZVRhYmxlU2VsZWN0aW9uRnJvbTogZm9jdXNDZWxsICR7Zm9jdXNDZWxsS2V5fSBpcyBub3QgaW4gdGFibGUgJHt0YWJsZU5vZGVLZXl9YCk7XG4gICAgfSAvLyBUT0RPOiBDaGVjayBmb3IgcmVjdGFuZ3VsYXIgZ3JpZFxuICB9XG4gIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGNvbnN0IG5leHRTZWxlY3Rpb24gPSAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSA/IHByZXZTZWxlY3Rpb24uY2xvbmUoKSA6ICRjcmVhdGVUYWJsZVNlbGVjdGlvbigpO1xuICBuZXh0U2VsZWN0aW9uLnNldCh0YWJsZU5vZGUuZ2V0S2V5KCksIGFuY2hvckNlbGwuZ2V0S2V5KCksIGZvY3VzQ2VsbC5nZXRLZXkoKSk7XG4gIHJldHVybiBuZXh0U2VsZWN0aW9uO1xufVxuXG4vKipcbiAqIERlcHRoIGZpcnN0IHZpc2l0b3JcbiAqIEBwYXJhbSBub2RlIFRoZSBzdGFydGluZyBub2RlXG4gKiBAcGFyYW0gJHZpc2l0IFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIG5vZGUuIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIGZhbHNlLCB0aGVuIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSB3aWxsIG5vdCBiZSBleHBsb3JlZFxuICovXG5mdW5jdGlvbiAkdmlzaXRSZWN1cnNpdmVseShub2RlLCAkdmlzaXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbW25vZGVdXTtcbiAgZm9yIChsZXQgY3VycmVudEFycmF5ID0gc3RhY2suYXQoLTEpOyBjdXJyZW50QXJyYXkgIT09IHVuZGVmaW5lZCAmJiBzdGFjay5sZW5ndGggPiAwOyBjdXJyZW50QXJyYXkgPSBzdGFjay5hdCgtMSkpIHtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IGN1cnJlbnRBcnJheS5wb3AoKTtcbiAgICBpZiAoY3VycmVudE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgfSBlbHNlIGlmICgkdmlzaXQoY3VycmVudE5vZGUpICE9PSBmYWxzZSAmJiAkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIHN0YWNrLnB1c2goY3VycmVudE5vZGUuZ2V0Q2hpbGRyZW4oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uICRnZXRUYWJsZUFuZEVsZW1lbnRCeUtleSh0YWJsZU5vZGVLZXksIGVkaXRvciA9ICRnZXRFZGl0b3IoKSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZ2V0Tm9kZUJ5S2V5KHRhYmxlTm9kZUtleSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHRhYmxlTm9kZSkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXI6IEV4cGVjdGVkIHRhYmxlTm9kZUtleSAke3RhYmxlTm9kZUtleX0gdG8gYmUgYSBUYWJsZU5vZGVgKTtcbiAgfVxuICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlLCBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KHRhYmxlTm9kZUtleSkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZU9ic2VydmVyOiBFeHBlY3RlZCB0byBmaW5kIFRhYmxlRWxlbWVudCBpbiBET00gZm9yIGtleSAke3RhYmxlTm9kZUtleX1gKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRhYmxlRWxlbWVudCxcbiAgICB0YWJsZU5vZGVcbiAgfTtcbn1cbmNsYXNzIFRhYmxlT2JzZXJ2ZXIge1xuICBjb25zdHJ1Y3RvcihlZGl0b3IsIHRhYmxlTm9kZUtleSkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yWCA9IC0xO1xuICAgIHRoaXMuYW5jaG9yWSA9IC0xO1xuICAgIHRoaXMuZm9jdXNYID0gLTE7XG4gICAgdGhpcy5mb2N1c1kgPSAtMTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlID0gbmV3IFNldCgpO1xuICAgIHRoaXMudGFibGVOb2RlS2V5ID0gdGFibGVOb2RlS2V5O1xuICAgIHRoaXMuZWRpdG9yID0gZWRpdG9yO1xuICAgIHRoaXMudGFibGUgPSB7XG4gICAgICBjb2x1bW5zOiAwLFxuICAgICAgZG9tUm93czogW10sXG4gICAgICByb3dzOiAwXG4gICAgfTtcbiAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gbnVsbDtcbiAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5mb2N1c0NlbGwgPSBudWxsO1xuICAgIHRoaXMuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgPSBmYWxzZTtcbiAgICB0aGlzLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5wb2ludGVyVHlwZSA9IG51bGw7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHRoaXMubGlzdGVuZXJPcHRpb25zID0ge1xuICAgICAgc2lnbmFsOiB0aGlzLmFib3J0Q29udHJvbGxlci5zaWduYWxcbiAgICB9O1xuICAgIHRoaXMubmV4dEZvY3VzID0gbnVsbDtcbiAgICB0aGlzLnRyYWNrVGFibGUoKTtcbiAgfVxuICBnZXRUYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50YWJsZTtcbiAgfVxuICByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy5hYm9ydENvbnRyb2xsZXIuYWJvcnQoJ3JlbW92ZUxpc3RlbmVycycpO1xuICAgIEFycmF5LmZyb20odGhpcy5saXN0ZW5lcnNUb1JlbW92ZSkuZm9yRWFjaChyZW1vdmVMaXN0ZW5lciA9PiByZW1vdmVMaXN0ZW5lcigpKTtcbiAgICB0aGlzLmxpc3RlbmVyc1RvUmVtb3ZlLmNsZWFyKCk7XG4gIH1cbiAgJGxvb2t1cCgpIHtcbiAgICByZXR1cm4gJGdldFRhYmxlQW5kRWxlbWVudEJ5S2V5KHRoaXMudGFibGVOb2RlS2V5LCB0aGlzLmVkaXRvcik7XG4gIH1cbiAgdHJhY2tUYWJsZSgpIHtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKHJlY29yZHMgPT4ge1xuICAgICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgICAgbGV0IGdyaWROZWVkc1JlZHJhdyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCByZWNvcmQgPSByZWNvcmRzW2ldO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlY29yZC50YXJnZXQ7XG4gICAgICAgICAgY29uc3Qgbm9kZU5hbWUgPSB0YXJnZXQubm9kZU5hbWU7XG4gICAgICAgICAgaWYgKG5vZGVOYW1lID09PSAnVEFCTEUnIHx8IG5vZGVOYW1lID09PSAnVEJPRFknIHx8IG5vZGVOYW1lID09PSAnVEhFQUQnIHx8IG5vZGVOYW1lID09PSAnVFInKSB7XG4gICAgICAgICAgICBncmlkTmVlZHNSZWRyYXcgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZ3JpZE5lZWRzUmVkcmF3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0YWJsZU5vZGUsXG4gICAgICAgICAgdGFibGVFbGVtZW50XG4gICAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgICAgdGhpcy50YWJsZSA9IGdldFRhYmxlKHRhYmxlTm9kZSwgdGFibGVFbGVtZW50KTtcbiAgICAgIH0sIHtcbiAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvclxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5lZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdGFibGVOb2RlLFxuICAgICAgICB0YWJsZUVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICAgIHRoaXMudGFibGUgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgICBvYnNlcnZlci5vYnNlcnZlKHRhYmxlRWxlbWVudCwge1xuICAgICAgICBhdHRyaWJ1dGVzOiB0cnVlLFxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIHtcbiAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3JcbiAgICB9KTtcbiAgfVxuICAkY2xlYXJIaWdobGlnaHQoKSB7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gZmFsc2U7XG4gICAgdGhpcy5hbmNob3JYID0gLTE7XG4gICAgdGhpcy5hbmNob3JZID0gLTE7XG4gICAgdGhpcy5mb2N1c1ggPSAtMTtcbiAgICB0aGlzLmZvY3VzWSA9IC0xO1xuICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSBudWxsO1xuICAgIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPSBudWxsO1xuICAgIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA9IG51bGw7XG4gICAgdGhpcy5hbmNob3JDZWxsID0gbnVsbDtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IG51bGw7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICAgIHRoaXMuJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCk7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVOb2RlLFxuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGNvbnN0IGdyaWQgPSBnZXRUYWJsZSh0YWJsZU5vZGUsIHRhYmxlRWxlbWVudCk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIGdyaWQsIG51bGwpO1xuICAgIGlmICgkZ2V0U2VsZWN0aW9uKCkgIT09IG51bGwpIHtcbiAgICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gIH1cbiAgJGVuYWJsZUhpZ2hsaWdodFN0eWxlKCkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlRWxlbWVudFxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQodGFibGVFbGVtZW50LCBlZGl0b3IuX2NvbmZpZy50aGVtZS50YWJsZVNlbGVjdGlvbik7XG4gICAgdGFibGVFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2Rpc2FibGUtc2VsZWN0aW9uJyk7XG4gICAgdGhpcy5oYXNIaWphY2tlZFNlbGVjdGlvblN0eWxlcyA9IGZhbHNlO1xuICB9XG4gICRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGFibGVFbGVtZW50XG4gICAgfSA9IHRoaXMuJGxvb2t1cCgpO1xuICAgIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQodGFibGVFbGVtZW50LCB0aGlzLmVkaXRvci5fY29uZmlnLnRoZW1lLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB0aGlzLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzID0gdHJ1ZTtcbiAgfVxuICAkdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHtcbiAgICBpZiAoc2VsZWN0aW9uICE9PSBudWxsKSB7XG4gICAgICBpZiAoIShzZWxlY3Rpb24udGFibGVLZXkgPT09IHRoaXMudGFibGVOb2RlS2V5KSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb246IHNlbGVjdGlvbi50YWJsZUtleSAhPT0gdGhpcy50YWJsZU5vZGVLZXkgKCcke3NlbGVjdGlvbi50YWJsZUtleX0nICE9PSAnJHt0aGlzLnRhYmxlTm9kZUtleX0nKWApO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgdGhpcy5pc0hpZ2hsaWdodGluZ0NlbGxzID0gdHJ1ZTtcbiAgICAgIHRoaXMuJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAgICAgdGhpcy51cGRhdGVET01TZWxlY3Rpb24oKTtcbiAgICAgICR1cGRhdGVET01Gb3JTZWxlY3Rpb24oZWRpdG9yLCB0aGlzLnRhYmxlLCB0aGlzLnRhYmxlU2VsZWN0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4kY2xlYXJIaWdobGlnaHQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEZpcmVmb3ggaGFzIGEgc3RyYW5nZSBiZWhhdmlvciB3aGVyZSBwcmVzc2luZyB0aGUgZG93biBhcnJvdyBrZXkgZnJvbVxuICAgKiBhYm92ZSB0aGUgdGFibGUgd2lsbCBtb3ZlIHRoZSBjYXJldCBhZnRlciB0aGUgdGFibGUgYW5kIHRoZW4gbGV4aWNhbFxuICAgKiB3aWxsIHNlbGVjdCB0aGUgbGFzdCBjZWxsIGluc3RlYWQgb2YgdGhlIGZpcnN0LlxuICAgKiBXZSBkbyBzdGlsbCB3YW50IHRvIGxldCB0aGUgYnJvd3NlciBoYW5kbGUgY2FyZXQgbW92ZW1lbnQgYnV0IHdlIHdpbGxcbiAgICogdXNlIHRoaXMgcHJvcGVydHkgdG8gXCJ0YWdcIiB0aGUgdXBkYXRlIHNvIHRoYXQgd2UgY2FuIHJlY2hlY2sgdGhlXG4gICAqIHNlbGVjdGlvbiBhZnRlciB0aGUgZXZlbnQgaXMgcHJvY2Vzc2VkLlxuICAgKi9cbiAgc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKSB7XG4gICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0QW5kQ2xlYXJTaG91bGRDaGVja1NlbGVjdGlvbigpIHtcbiAgICBpZiAodGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbikge1xuICAgICAgdGhpcy5zaG91bGRDaGVja1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogV2hlbiBoYW5kbGluZyBtb3VzZW1vdmUgZXZlbnRzIHdlIHRyYWNrIHdoYXQgdGhlIGZvY3VzIGNlbGwgc2hvdWxkIGJlLCBidXRcbiAgICogdGhlIERPTSBzZWxlY3Rpb24gbWF5IGVuZCB1cCBzb21ld2hlcmUgZWxzZSBlbnRpcmVseS4gV2UgZG9uJ3QgaGF2ZSBhbiBlbGVnYW50XG4gICAqIHdheSB0byBoYW5kbGUgdGhpcyBhZnRlciB0aGUgRE9NIHNlbGVjdGlvbiBoYXMgYmVlbiByZXNvbHZlZCBpbiBhXG4gICAqIFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCBjYWxsYmFjay5cbiAgICovXG4gIHNldE5leHRGb2N1cyhuZXh0Rm9jdXMpIHtcbiAgICB0aGlzLm5leHRGb2N1cyA9IG5leHRGb2N1cztcbiAgfVxuXG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0QW5kQ2xlYXJOZXh0Rm9jdXMoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmV4dEZvY3VzXG4gICAgfSA9IHRoaXM7XG4gICAgaWYgKG5leHRGb2N1cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5uZXh0Rm9jdXMgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dEZvY3VzO1xuICB9XG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVET01TZWxlY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYW5jaG9yQ2VsbCAhPT0gbnVsbCAmJiB0aGlzLmZvY3VzQ2VsbCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZG9tU2VsZWN0aW9uID0gZ2V0RE9NU2VsZWN0aW9uKHRoaXMuZWRpdG9yLl93aW5kb3cpO1xuICAgICAgLy8gV2UgYXJlIG5vdCB1c2luZyBhIG5hdGl2ZSBzZWxlY3Rpb24gZm9yIHRhYmxlcywgYW5kIGlmIHdlXG4gICAgICAvLyBzZXQgb25lIHRoZW4gdGhlIHJlY29uY2lsZXIgd2lsbCB1bmRvIGl0LlxuICAgICAgLy8gVE9ETyAtIGl0IHdvdWxkIG1ha2Ugc2Vuc2UgdG8gaGF2ZSBvbmUgc28gdGhhdCBuYXRpdmVcbiAgICAgIC8vICAgICAgICBjb3B5L3Bhc3RlIHdvcmtlZC4gUmlnaHQgbm93IHdlIGhhdmUgdG8gZW11bGF0ZSB3aXRoXG4gICAgICAvLyAgICAgICAga2V5Ym9hcmQgZXZlbnRzIGJ1dCBpdCB3b24ndCBmaXJlIGlmIHRyaWdnZXJlZCBmcm9tIHRoZSBtZW51XG4gICAgICBpZiAoZG9tU2VsZWN0aW9uICYmIGRvbVNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICBkb21TZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oY2VsbCwgaWdub3JlU3RhcnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgIGNvbnN0IHtcbiAgICAgIHRhYmxlTm9kZVxuICAgIH0gPSB0aGlzLiRsb29rdXAoKTtcbiAgICBjb25zdCBjZWxsWCA9IGNlbGwueDtcbiAgICBjb25zdCBjZWxsWSA9IGNlbGwueTtcbiAgICB0aGlzLmZvY3VzQ2VsbCA9IGNlbGw7XG4gICAgaWYgKCF0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMgJiYgKHRoaXMuYW5jaG9yWCAhPT0gY2VsbFggfHwgdGhpcy5hbmNob3JZICE9PSBjZWxsWSB8fCBpZ25vcmVTdGFydCkpIHtcbiAgICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IHRydWU7XG4gICAgICB0aGlzLiRkaXNhYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgICB9IGVsc2UgaWYgKGNlbGxYID09PSB0aGlzLmZvY3VzWCAmJiBjZWxsWSA9PT0gdGhpcy5mb2N1c1kpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5mb2N1c1ggPSBjZWxsWDtcbiAgICB0aGlzLmZvY3VzWSA9IGNlbGxZO1xuICAgIGlmICh0aGlzLmlzSGlnaGxpZ2h0aW5nQ2VsbHMpIHtcbiAgICAgIGNvbnN0IGZvY3VzVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICAgIGlmICh0aGlzLnRhYmxlU2VsZWN0aW9uICE9IG51bGwgJiYgdGhpcy5hbmNob3JDZWxsTm9kZUtleSAhPSBudWxsICYmIGZvY3VzVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZvY3VzQ2VsbE5vZGVLZXkgPSBmb2N1c1RhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICAgIHRoaXMudGFibGVTZWxlY3Rpb24gPSAkY3JlYXRlVGFibGVTZWxlY3Rpb25Gcm9tKHRhYmxlTm9kZSwgdGhpcy4kZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpLCBmb2N1c1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgICAkc2V0U2VsZWN0aW9uKHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIHRoaXMudGFibGVTZWxlY3Rpb24pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gICRnZXRBbmNob3JUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkgPyAkZ2V0Tm9kZUJ5S2V5KHRoaXMuYW5jaG9yQ2VsbE5vZGVLZXkpIDogbnVsbDtcbiAgfVxuICAkZ2V0QW5jaG9yVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBhbmNob3JUYWJsZUNlbGwgPSB0aGlzLiRnZXRBbmNob3JUYWJsZUNlbGwoKTtcbiAgICBpZiAoIShhbmNob3JUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgYW5jaG9yVGFibGVDZWxsIGlzIG51bGxgKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2hvclRhYmxlQ2VsbDtcbiAgfVxuICAkZ2V0Rm9jdXNUYWJsZUNlbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9jdXNDZWxsTm9kZUtleSA/ICRnZXROb2RlQnlLZXkodGhpcy5mb2N1c0NlbGxOb2RlS2V5KSA6IG51bGw7XG4gIH1cbiAgJGdldEZvY3VzVGFibGVDZWxsT3JUaHJvdygpIHtcbiAgICBjb25zdCBmb2N1c1RhYmxlQ2VsbCA9IHRoaXMuJGdldEZvY3VzVGFibGVDZWxsKCk7XG4gICAgaWYgKCEoZm9jdXNUYWJsZUNlbGwgIT09IG51bGwpKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYFRhYmxlT2JzZXJ2ZXIgZm9jdXNUYWJsZUNlbGwgaXMgbnVsbGApO1xuICAgIH1cbiAgICByZXR1cm4gZm9jdXNUYWJsZUNlbGw7XG4gIH1cbiAgJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCkge1xuICAgIHRoaXMuaXNIaWdobGlnaHRpbmdDZWxscyA9IGZhbHNlO1xuICAgIHRoaXMuYW5jaG9yQ2VsbCA9IGNlbGw7XG4gICAgdGhpcy5hbmNob3JYID0gY2VsbC54O1xuICAgIHRoaXMuYW5jaG9yWSA9IGNlbGwueTtcbiAgICBjb25zdCB7XG4gICAgICB0YWJsZU5vZGVcbiAgICB9ID0gdGhpcy4kbG9va3VwKCk7XG4gICAgY29uc3QgYW5jaG9yVGFibGVDZWxsTm9kZSA9ICRnZXROZWFyZXN0VGFibGVDZWxsSW5UYWJsZUZyb21ET01Ob2RlKHRhYmxlTm9kZSwgY2VsbC5lbGVtKTtcbiAgICBpZiAoYW5jaG9yVGFibGVDZWxsTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgYW5jaG9yTm9kZUtleSA9IGFuY2hvclRhYmxlQ2VsbE5vZGUuZ2V0S2V5KCk7XG4gICAgICB0aGlzLnRhYmxlU2VsZWN0aW9uID0gdGhpcy50YWJsZVNlbGVjdGlvbiAhPSBudWxsID8gdGhpcy50YWJsZVNlbGVjdGlvbi5jbG9uZSgpIDogJGNyZWF0ZVRhYmxlU2VsZWN0aW9uKCk7XG4gICAgICB0aGlzLmFuY2hvckNlbGxOb2RlS2V5ID0gYW5jaG9yTm9kZUtleTtcbiAgICB9XG4gIH1cbiAgJGZvcm1hdENlbGxzKHR5cGUpIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYEV4cGVjdGVkIFRhYmxlIHNlbGVjdGlvbmApO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXRTZWxlY3Rpb24gPSAkY3JlYXRlUmFuZ2VTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBhbmNob3IgPSBmb3JtYXRTZWxlY3Rpb24uYW5jaG9yO1xuICAgIGNvbnN0IGZvY3VzID0gZm9ybWF0U2VsZWN0aW9uLmZvY3VzO1xuICAgIGNvbnN0IGNlbGxOb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICBpZiAoIShjZWxsTm9kZXMubGVuZ3RoID4gMCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgTm8gdGFibGUgY2VsbHMgcHJlc2VudGApO1xuICAgIH1cbiAgICBjb25zdCBwYXJhZ3JhcGggPSBjZWxsTm9kZXNbMF0uZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGFsaWduRm9ybWF0V2l0aCA9ICRpc1BhcmFncmFwaE5vZGUocGFyYWdyYXBoKSA/IHBhcmFncmFwaC5nZXRGb3JtYXRGbGFncyh0eXBlLCBudWxsKSA6IG51bGw7XG4gICAgY2VsbE5vZGVzLmZvckVhY2goY2VsbE5vZGUgPT4ge1xuICAgICAgYW5jaG9yLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgMCwgJ2VsZW1lbnQnKTtcbiAgICAgIGZvY3VzLnNldChjZWxsTm9kZS5nZXRLZXkoKSwgY2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICBmb3JtYXRTZWxlY3Rpb24uZm9ybWF0VGV4dCh0eXBlLCBhbGlnbkZvcm1hdFdpdGgpO1xuICAgIH0pO1xuICAgICRzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB0aGlzLmVkaXRvci5kaXNwYXRjaENvbW1hbmQoU0VMRUNUSU9OX0NIQU5HRV9DT01NQU5ELCB1bmRlZmluZWQpO1xuICB9XG4gICRjbGVhclRleHQoKSB7XG4gICAgY29uc3Qge1xuICAgICAgZWRpdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgdGFibGVOb2RlID0gJGdldE5vZGVCeUtleSh0aGlzLnRhYmxlTm9kZUtleSk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBUYWJsZU5vZGUuJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVTZWxlY3Rpb25gKTtcbiAgICB9XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlcyA9IHNlbGVjdGlvbi5nZXROb2RlcygpLmZpbHRlcigkaXNUYWJsZUNlbGxOb2RlKTtcblxuICAgIC8vIENoZWNrIGlmIHRoZSBlbnRpcmUgdGFibGUgaXMgc2VsZWN0ZWQgYnkgdmVyaWZ5aW5nIGZpcnN0IGFuZCBsYXN0IGNlbGxzXG4gICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGNvbnN0IGxhc3RSb3cgPSB0YWJsZU5vZGUuZ2V0TGFzdENoaWxkKCk7XG4gICAgY29uc3QgaXNFbnRpcmVUYWJsZVNlbGVjdGVkID0gc2VsZWN0ZWROb2Rlcy5sZW5ndGggPiAwICYmIGZpcnN0Um93ICE9PSBudWxsICYmIGxhc3RSb3cgIT09IG51bGwgJiYgJGlzVGFibGVSb3dOb2RlKGZpcnN0Um93KSAmJiAkaXNUYWJsZVJvd05vZGUobGFzdFJvdykgJiYgc2VsZWN0ZWROb2Rlc1swXSA9PT0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpICYmIHNlbGVjdGVkTm9kZXNbc2VsZWN0ZWROb2Rlcy5sZW5ndGggLSAxXSA9PT0gbGFzdFJvdy5nZXRMYXN0Q2hpbGQoKTtcbiAgICBpZiAoaXNFbnRpcmVUYWJsZVNlbGVjdGVkKSB7XG4gICAgICB0YWJsZU5vZGUuc2VsZWN0UHJldmlvdXMoKTtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRhYmxlTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgIC8vIERlbGV0ZSBlbnRpcmUgdGFibGVcbiAgICAgIHRhYmxlTm9kZS5yZW1vdmUoKTtcbiAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGFibGUgd2FzIHRoZSBvbmx5IG5vZGVcbiAgICAgIGlmICgkaXNSb290Tm9kZShwYXJlbnQpICYmIHBhcmVudC5pc0VtcHR5KCkpIHtcbiAgICAgICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChJTlNFUlRfUEFSQUdSQVBIX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNlbGVjdGVkTm9kZXMuZm9yRWFjaChjZWxsTm9kZSA9PiB7XG4gICAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2VsbE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICAgICAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZSgpO1xuICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZCh0ZXh0Tm9kZSk7XG4gICAgICAgIGNlbGxOb2RlLmFwcGVuZChwYXJhZ3JhcGhOb2RlKTtcbiAgICAgICAgY2VsbE5vZGUuZ2V0Q2hpbGRyZW4oKS5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgICBpZiAoY2hpbGQgIT09IHBhcmFncmFwaE5vZGUpIHtcbiAgICAgICAgICAgIGNoaWxkLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRoaXMudGFibGUsIG51bGwpO1xuICAgICRzZXRTZWxlY3Rpb24obnVsbCk7XG4gICAgZWRpdG9yLmRpc3BhdGNoQ29tbWFuZChTRUxFQ1RJT05fQ0hBTkdFX0NPTU1BTkQsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuY29uc3QgTEVYSUNBTF9FTEVNRU5UX0tFWSA9ICdfX2xleGljYWxUYWJsZVNlbGVjdGlvbic7XG5jb25zdCBpc1BvaW50ZXJEb3duT25FdmVudCA9IGV2ZW50ID0+IHtcbiAgcmV0dXJuIChldmVudC5idXR0b25zICYgMSkgPT09IDE7XG59O1xuZnVuY3Rpb24gaXNIVE1MVGFibGVFbGVtZW50KGVsKSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50KGVsKSAmJiBlbC5ub2RlTmFtZSA9PT0gJ1RBQkxFJztcbn1cbmZ1bmN0aW9uIGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSkge1xuICBpZiAoIWRvbSkge1xuICAgIHJldHVybiBkb207XG4gIH1cbiAgY29uc3QgZWxlbWVudCA9IGlzSFRNTFRhYmxlRWxlbWVudChkb20pID8gZG9tIDogdGFibGVOb2RlLmdldERPTVNsb3QoZG9tKS5lbGVtZW50O1xuICBpZiAoIShlbGVtZW50Lm5vZGVOYW1lID09PSAnVEFCTEUnKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0VGFibGVFbGVtZW50OiBFeHBlY3RpbmcgdGFibGUgaW4gYXMgRE9NIG5vZGUgZm9yIFRhYmxlTm9kZSwgbm90ICR7ZG9tLm5vZGVOYW1lfWApO1xuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0RWRpdG9yV2luZG93KGVkaXRvcikge1xuICByZXR1cm4gZWRpdG9yLl93aW5kb3c7XG59XG5mdW5jdGlvbiAkZmluZFBhcmVudFRhYmxlQ2VsbE5vZGVJblRhYmxlKHRhYmxlTm9kZSwgbm9kZSkge1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGUsIGxhc3RUYWJsZUNlbGxOb2RlID0gbnVsbDsgY3VycmVudE5vZGUgIT09IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuZ2V0UGFyZW50KCkpIHtcbiAgICBpZiAodGFibGVOb2RlLmlzKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGxhc3RUYWJsZUNlbGxOb2RlO1xuICAgIH0gZWxzZSBpZiAoJGlzVGFibGVDZWxsTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGxhc3RUYWJsZUNlbGxOb2RlID0gY3VycmVudE5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuY29uc3QgQVJST1dfS0VZX0NPTU1BTkRTX1dJVEhfRElSRUNUSU9OID0gW1tLRVlfQVJST1dfRE9XTl9DT01NQU5ELCAnZG93biddLCBbS0VZX0FSUk9XX1VQX0NPTU1BTkQsICd1cCddLCBbS0VZX0FSUk9XX0xFRlRfQ09NTUFORCwgJ2JhY2t3YXJkJ10sIFtLRVlfQVJST1dfUklHSFRfQ09NTUFORCwgJ2ZvcndhcmQnXV07XG5jb25zdCBERUxFVEVfVEVYVF9DT01NQU5EUyA9IFtERUxFVEVfV09SRF9DT01NQU5ELCBERUxFVEVfTElORV9DT01NQU5ELCBERUxFVEVfQ0hBUkFDVEVSX0NPTU1BTkRdO1xuY29uc3QgREVMRVRFX0tFWV9DT01NQU5EUyA9IFtLRVlfQkFDS1NQQUNFX0NPTU1BTkQsIEtFWV9ERUxFVEVfQ09NTUFORF07XG5mdW5jdGlvbiBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCBlbGVtZW50LCBlZGl0b3IsIGhhc1RhYkhhbmRsZXIpIHtcbiAgY29uc3Qgcm9vdEVsZW1lbnQgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgY29uc3QgZWRpdG9yV2luZG93ID0gZ2V0RWRpdG9yV2luZG93KGVkaXRvcik7XG4gIGlmICghKHJvb3RFbGVtZW50ICE9PSBudWxsICYmIGVkaXRvcldpbmRvdyAhPT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYGFwcGx5VGFibGVIYW5kbGVyczogZWRpdG9yIGhhcyBubyByb290IGVsZW1lbnQgc2V0YCk7XG4gIH1cbiAgY29uc3QgdGFibGVPYnNlcnZlciA9IG5ldyBUYWJsZU9ic2VydmVyKGVkaXRvciwgdGFibGVOb2RlLmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWxlbWVudCk7XG4gIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiBkZXRhY2hUYWJsZU9ic2VydmVyRnJvbVRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpKTtcbiAgY29uc3QgY3JlYXRlUG9pbnRlckhhbmRsZXJzID0gKCkgPT4ge1xuICAgIGlmICh0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gKCkgPT4ge1xuICAgICAgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyA9IGZhbHNlO1xuICAgICAgZWRpdG9yV2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyTW92ZSA9IG1vdmVFdmVudCA9PiB7XG4gICAgICBpZiAoIWlzUG9pbnRlckRvd25PbkV2ZW50KG1vdmVFdmVudCkgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZykge1xuICAgICAgICB0YWJsZU9ic2VydmVyLmlzU2VsZWN0aW5nID0gZmFsc2U7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRE9NTm9kZShtb3ZlRXZlbnQudGFyZ2V0KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgZm9jdXNDZWxsID0gbnVsbDtcbiAgICAgIC8vIEluIGZpcmVmb3ggdGhlIG1vdmVFdmVudC50YXJnZXQgbWF5IGJlIGNhcHR1cmVkIHNvIHdlIG11c3QgYWx3YXlzXG4gICAgICAvLyBjb25zdWx0IHRoZSBjb29yZGluYXRlcyAjNzI0NVxuICAgICAgY29uc3Qgb3ZlcnJpZGUgPSAhKElTX0ZJUkVGT1ggfHwgdGFibGVFbGVtZW50LmNvbnRhaW5zKG1vdmVFdmVudC50YXJnZXQpKTtcbiAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICBmb2N1c0NlbGwgPSBnZXRET01DZWxsSW5UYWJsZUZyb21UYXJnZXQodGFibGVFbGVtZW50LCBtb3ZlRXZlbnQudGFyZ2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgZG9jdW1lbnQuZWxlbWVudHNGcm9tUG9pbnQobW92ZUV2ZW50LmNsaWVudFgsIG1vdmVFdmVudC5jbGllbnRZKSkge1xuICAgICAgICAgIGZvY3VzQ2VsbCA9IGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZUVsZW1lbnQsIGVsKTtcbiAgICAgICAgICBpZiAoZm9jdXNDZWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c0NlbGwgJiYgKHRhYmxlT2JzZXJ2ZXIuZm9jdXNDZWxsID09PSBudWxsIHx8IGZvY3VzQ2VsbC5lbGVtICE9PSB0YWJsZU9ic2VydmVyLmZvY3VzQ2VsbC5lbGVtKSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLnNldE5leHRGb2N1cyh7XG4gICAgICAgICAgZm9jdXNDZWxsLFxuICAgICAgICAgIG92ZXJyaWRlXG4gICAgICAgIH0pO1xuICAgICAgICBlZGl0b3IuZGlzcGF0Y2hDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRhYmxlT2JzZXJ2ZXIuaXNTZWxlY3RpbmcgPSB0cnVlO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICAgIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUsIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgfTtcbiAgY29uc3Qgb25Qb2ludGVyRG93biA9IGV2ZW50ID0+IHtcbiAgICB0YWJsZU9ic2VydmVyLnBvaW50ZXJUeXBlID0gZXZlbnQucG9pbnRlclR5cGU7XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhaXNET01Ob2RlKGV2ZW50LnRhcmdldCkgfHwgIWVkaXRvcldpbmRvdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRDZWxsID0gZ2V0RE9NQ2VsbEZyb21UYXJnZXQoZXZlbnQudGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgZWRpdG9yLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZTZWxlY3Rpb24gPSAkZ2V0UHJldmlvdXNTZWxlY3Rpb24oKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgdHJ1c3QgRmlyZWZveCB0byBkbyB0aGUgcmlnaHQgdGhpbmcgd2l0aCB0aGUgc2VsZWN0aW9uIGFuZFxuICAgICAgICAvLyB3ZSBkb24ndCBoYXZlIGEgcHJvcGVyIHN0YXRlIG1hY2hpbmUgdG8gZG8gdGhpcyBcImNvcnJlY3RseVwiIGJ1dFxuICAgICAgICAvLyBpZiB3ZSBnbyBhaGVhZCBhbmQgbWFrZSB0aGUgdGFibGUgc2VsZWN0aW9uIG5vdyBpdCB3aWxsIHdvcmtcbiAgICAgICAgaWYgKElTX0ZJUkVGT1ggJiYgZXZlbnQuc2hpZnRLZXkgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShwcmV2U2VsZWN0aW9uLCB0YWJsZU5vZGUpICYmICgkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yTm9kZSA9IHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbCA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBwcmV2U2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgICAgIGlmIChwcmV2QW5jaG9yQ2VsbCkge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbigkZ2V0T2JzZXJ2ZXJDZWxsRnJvbUNlbGxOb2RlT3JUaHJvdyh0YWJsZU9ic2VydmVyLCBwcmV2QW5jaG9yQ2VsbCkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKHRhcmdldENlbGwpO1xuICAgICAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gdGFibGVOb2RlLmlzQmVmb3JlKHByZXZBbmNob3JOb2RlKSA/IHRhYmxlTm9kZS5zZWxlY3RTdGFydCgpIDogdGFibGVOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQocHJldlNlbGVjdGlvbi5hbmNob3Iua2V5LCBwcmV2U2VsZWN0aW9uLmFuY2hvci5vZmZzZXQsIHByZXZTZWxlY3Rpb24uYW5jaG9yLnR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPbmx5IHNldCBhbmNob3IgY2VsbCBmb3Igc2VsZWN0aW9uIGlmIHRoaXMgaXMgbm90IGEgc2ltcGxlIHRvdWNoIHRhcFxuICAgICAgICAgIC8vIFRvdWNoIHRhcHMgc2hvdWxkIG5vdCBpbml0aWF0ZSB0YWJsZSBzZWxlY3Rpb24gbW9kZVxuICAgICAgICAgIGlmIChldmVudC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0QW5jaG9yQ2VsbEZvclNlbGVjdGlvbih0YXJnZXRDZWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQb2ludGVySGFuZGxlcnMoKTtcbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93biwgdGFibGVPYnNlcnZlci5saXN0ZW5lck9wdGlvbnMpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZCgoKSA9PiB7XG4gICAgdGFibGVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgb25Qb2ludGVyRG93bik7XG4gIH0pO1xuICBjb25zdCBvblRyaXBsZUNsaWNrID0gZXZlbnQgPT4ge1xuICAgIGlmIChldmVudC5kZXRhaWwgPj0gMyAmJiBpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGV2ZW50LnRhcmdldCk7XG4gICAgICBpZiAodGFyZ2V0Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdGFibGVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uVHJpcGxlQ2xpY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIHRhYmxlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBvblRyaXBsZUNsaWNrKTtcbiAgfSk7XG5cbiAgLy8gQ2xlYXIgc2VsZWN0aW9uIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBkb20uXG4gIGNvbnN0IHBvaW50ZXJEb3duQ2FsbGJhY2sgPSBldmVudCA9PiB7XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgIWlzRE9NTm9kZSh0YXJnZXQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVkaXRvci51cGRhdGUoKCkgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSAmJiByb290RWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFySGlnaGxpZ2h0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGVkaXRvcldpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2ssIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJPcHRpb25zKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoKCkgPT4ge1xuICAgIGVkaXRvcldpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVyZG93bicsIHBvaW50ZXJEb3duQ2FsbGJhY2spO1xuICB9KTtcbiAgZm9yIChjb25zdCBbY29tbWFuZCwgZGlyZWN0aW9uXSBvZiBBUlJPV19LRVlfQ09NTUFORFNfV0lUSF9ESVJFQ1RJT04pIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGV2ZW50ID0+ICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlciksIENPTU1BTkRfUFJJT1JJVFlfSElHSCkpO1xuICB9XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoS0VZX0VTQ0FQRV9DT01NQU5ELCBldmVudCA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgICAgaWYgKGZvY3VzQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9jdXNDZWxsTm9kZS5zZWxlY3RFbmQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9ISUdIKSk7XG4gIGNvbnN0IGRlbGV0ZVRleHRIYW5kbGVyID0gY29tbWFuZCA9PiAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuJGNsZWFyVGV4dCgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICBjb25zdCB0YWJsZUNlbGxOb2RlID0gJGZpbmRQYXJlbnRUYWJsZUNlbGxOb2RlSW5UYWJsZSh0YWJsZU5vZGUsIHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZSh0YWJsZUNlbGxOb2RlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihmb2N1c05vZGUpO1xuICAgICAgY29uc3Qgc2VsZWN0aW9uQ29udGFpbnNQYXJ0aWFsVGFibGUgPSBpc0FuY2hvckluc2lkZSAmJiAhaXNGb2N1c0luc2lkZSB8fCBpc0ZvY3VzSW5zaWRlICYmICFpc0FuY2hvckluc2lkZTtcbiAgICAgIGlmIChzZWxlY3Rpb25Db250YWluc1BhcnRpYWxUYWJsZSkge1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRjbGVhclRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBjb25zdCBuZWFyZXN0RWxlbWVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pKTtcbiAgICAgIGNvbnN0IHRvcExldmVsQ2VsbEVsZW1lbnROb2RlID0gbmVhcmVzdEVsZW1lbnROb2RlICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQobmVhcmVzdEVsZW1lbnROb2RlLCBuID0+ICRpc0VsZW1lbnROb2RlKG4pICYmICRpc1RhYmxlQ2VsbE5vZGUobi5nZXRQYXJlbnQoKSkpO1xuICAgICAgaWYgKCEkaXNFbGVtZW50Tm9kZSh0b3BMZXZlbENlbGxFbGVtZW50Tm9kZSkgfHwgISRpc0VsZW1lbnROb2RlKG5lYXJlc3RFbGVtZW50Tm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGNvbW1hbmQgPT09IERFTEVURV9MSU5FX0NPTU1BTkQgJiYgdG9wTGV2ZWxDZWxsRWxlbWVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCkgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogRml4IERlbGV0ZSBMaW5lIGluIFRhYmxlIENlbGxzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX1RFWFRfQ09NTUFORFMpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKGNvbW1hbmQsIGRlbGV0ZVRleHRIYW5kbGVyKGNvbW1hbmQpLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgY29uc3QgJGRlbGV0ZUNlbGxIYW5kbGVyID0gZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHNlbGVjdGlvbiBpcyBpbnNpZGUgdGhlIHRhYmxlIGJ1dCBzaG91bGQgcmVtb3ZlIHRoZSB3aG9sZSB0YWJsZVxuICAgIC8vIHdlIGV4cGFuZCB0aGUgc2VsZWN0aW9uIHNvIHRoYXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBhcmUgb3V0c2lkZVxuICAgIC8vIHRoZSB0YWJsZSBhbmQgdGhlIGVkaXRvcidzIGNvbW1hbmQgbGlzdGVuZXIgd2lsbCBoYW5kbGUgdGhlIGRlbGV0ZVxuICAgIGNvbnN0IGlzQW5jaG9ySW5zaWRlID0gdGFibGVOb2RlLmlzUGFyZW50T2Yoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICBpZiAoaXNBbmNob3JJbnNpZGUgIT09IGlzRm9jdXNJbnNpZGUpIHtcbiAgICAgIGNvbnN0IHRhYmxlUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdhbmNob3InIDogJ2ZvY3VzJztcbiAgICAgIGNvbnN0IG91dGVyUG9pbnQgPSBpc0FuY2hvckluc2lkZSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICAgIC8vIFByZXNlcnZlIHRoZSBvdXRlciBwb2ludFxuICAgICAgY29uc3Qge1xuICAgICAgICBrZXksXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgdHlwZVxuICAgICAgfSA9IHNlbGVjdGlvbltvdXRlclBvaW50XTtcbiAgICAgIC8vIEV4cGFuZCB0aGUgc2VsZWN0aW9uIGFyb3VuZCB0aGUgdGFibGVcbiAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHRhYmxlTm9kZVtzZWxlY3Rpb25bdGFibGVQb2ludF0uaXNCZWZvcmUoc2VsZWN0aW9uW291dGVyUG9pbnRdKSA/ICdzZWxlY3RQcmV2aW91cycgOiAnc2VsZWN0TmV4dCddKCk7XG4gICAgICAvLyBSZXN0b3JlIHRoZSBvdXRlciBwb2ludCBvZiB0aGUgc2VsZWN0aW9uXG4gICAgICBuZXdTZWxlY3Rpb25bb3V0ZXJQb2ludF0uc2V0KGtleSwgb2Zmc2V0LCB0eXBlKTtcbiAgICAgIC8vIExldCB0aGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBoYW5kbGUgdGhlIHJlc3RcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgICAgdGFibGVPYnNlcnZlci4kY2xlYXJUZXh0KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBmb3IgKGNvbnN0IGNvbW1hbmQgb2YgREVMRVRFX0tFWV9DT01NQU5EUykge1xuICAgIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoY29tbWFuZCwgJGRlbGV0ZUNlbGxIYW5kbGVyLCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIH1cbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDVVRfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBpZiAoISgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHlpbmcgdG8gdGhlIGNsaXBib2FyZCBpcyBhc3luYyBzbyB3ZSBtdXN0IGNhcHR1cmUgdGhlIGRhdGFcbiAgICAgIC8vIGJlZm9yZSB3ZSBkZWxldGUgaXRcbiAgICAgIHZvaWQgY29weVRvQ2xpcGJvYXJkKGVkaXRvciwgb2JqZWN0S2xhc3NFcXVhbHMoZXZlbnQsIENsaXBib2FyZEV2ZW50KSA/IGV2ZW50IDogbnVsbCwgJGdldENsaXBib2FyZERhdGFGcm9tU2VsZWN0aW9uKHNlbGVjdGlvbikpO1xuICAgICAgY29uc3QgaW50ZXJjZXB0ZWQgPSAkZGVsZXRlQ2VsbEhhbmRsZXIoZXZlbnQpO1xuICAgICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZVRleHQoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW50ZXJjZXB0ZWQ7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPUk1BVF9URVhUX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRmb3JtYXRDZWxscyhwYXlsb2FkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChGT1JNQVRfRUxFTUVOVF9DT01NQU5ELCBmb3JtYXRUeXBlID0+IHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCEkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICEkaXNTZWxlY3Rpb25JblRhYmxlKHNlbGVjdGlvbiwgdGFibGVOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCk7XG4gICAgY29uc3QgZm9jdXNOb2RlID0gc2VsZWN0aW9uLmZvY3VzLmdldE5vZGUoKTtcbiAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUoYW5jaG9yTm9kZSkgfHwgISRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNOb2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIEFsaWduIHRoZSB0YWJsZSBpZiB0aGUgZW50aXJlIHRhYmxlIGlzIHNlbGVjdGVkXG4gICAgaWYgKCRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgIHRhYmxlTm9kZS5zZXRGb3JtYXQoZm9ybWF0VHlwZSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgW3RhYmxlTWFwLCBhbmNob3JDZWxsLCBmb2N1c0NlbGxdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgY29uc3QgbWF4Um93ID0gTWF0aC5tYXgoYW5jaG9yQ2VsbC5zdGFydFJvdyArIGFuY2hvckNlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxLCBmb2N1c0NlbGwuc3RhcnRSb3cgKyBmb2N1c0NlbGwuY2VsbC5fX3Jvd1NwYW4gLSAxKTtcbiAgICBjb25zdCBtYXhDb2x1bW4gPSBNYXRoLm1heChhbmNob3JDZWxsLnN0YXJ0Q29sdW1uICsgYW5jaG9yQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEsIGZvY3VzQ2VsbC5zdGFydENvbHVtbiArIGZvY3VzQ2VsbC5jZWxsLl9fY29sU3BhbiAtIDEpO1xuICAgIGNvbnN0IG1pblJvdyA9IE1hdGgubWluKGFuY2hvckNlbGwuc3RhcnRSb3csIGZvY3VzQ2VsbC5zdGFydFJvdyk7XG4gICAgY29uc3QgbWluQ29sdW1uID0gTWF0aC5taW4oYW5jaG9yQ2VsbC5zdGFydENvbHVtbiwgZm9jdXNDZWxsLnN0YXJ0Q29sdW1uKTtcbiAgICBjb25zdCB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIGZvciAobGV0IGkgPSBtaW5Sb3c7IGkgPD0gbWF4Um93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBtaW5Db2x1bW47IGogPD0gbWF4Q29sdW1uOyBqKyspIHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRhYmxlTWFwW2ldW2pdLmNlbGw7XG4gICAgICAgIGlmICh2aXNpdGVkLmhhcyhjZWxsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWQuYWRkKGNlbGwpO1xuICAgICAgICBjZWxsLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgY29uc3QgY2VsbENoaWxkcmVuID0gY2VsbC5nZXRDaGlsZHJlbigpO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGNlbGxDaGlsZHJlbi5sZW5ndGg7IGsrKykge1xuICAgICAgICAgIGNvbnN0IGNoaWxkID0gY2VsbENoaWxkcmVuW2tdO1xuICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShjaGlsZCkgJiYgIWNoaWxkLmlzSW5saW5lKCkpIHtcbiAgICAgICAgICAgIGNoaWxkLnNldEZvcm1hdChmb3JtYXRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChDT05UUk9MTEVEX1RFWFRfSU5TRVJUSU9OX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICB0YWJsZU9ic2VydmVyLiRjbGVhckhpZ2hsaWdodCgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUodGFibGVDZWxsTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSk7XG4gICAgICAgIGlmIChlZGdlUG9zaXRpb24pIHtcbiAgICAgICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIFskY3JlYXRlVGV4dE5vZGUocGF5bG9hZCldKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgaWYgKGhhc1RhYkhhbmRsZXIpIHtcbiAgICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEtFWV9UQUJfQ09NTUFORCwgZXZlbnQgPT4ge1xuICAgICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSB8fCAhJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kQ2VsbE5vZGUoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCkpO1xuICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgPT09IG51bGwgfHwgIXRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZSh0YWJsZUNlbGxOb2RlKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICRzZWxlY3RBZGphY2VudENlbGwodGFibGVDZWxsTm9kZSwgZXZlbnQuc2hpZnRLZXkgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sIENPTU1BTkRfUFJJT1JJVFlfQ1JJVElDQUwpKTtcbiAgfVxuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKEZPQ1VTX0NPTU1BTkQsIHBheWxvYWQgPT4ge1xuICAgIHJldHVybiB0YWJsZU5vZGUuaXNTZWxlY3RlZCgpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0hJR0gpKTtcbiAgdGFibGVPYnNlcnZlci5saXN0ZW5lcnNUb1JlbW92ZS5hZGQoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChTRUxFQ1RJT05fSU5TRVJUX0NMSVBCT0FSRF9OT0RFU19DT01NQU5ELCAoc2VsZWN0aW9uUGF5bG9hZCwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBub2RlcyxcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBzZWxlY3Rpb25QYXlsb2FkO1xuICAgIGNvbnN0IGFuY2hvckFuZEZvY3VzID0gc2VsZWN0aW9uLmdldFN0YXJ0RW5kUG9pbnRzKCk7XG4gICAgY29uc3QgaXNUYWJsZVNlbGVjdGlvbiA9ICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNSYW5nZVNlbGVjdGlvbiA9ICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgY29uc3QgaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgPSBpc1JhbmdlU2VsZWN0aW9uICYmICRmaW5kTWF0Y2hpbmdQYXJlbnQoc2VsZWN0aW9uLmFuY2hvci5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSkgIT09IG51bGwgJiYgJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpLCBuID0+ICRpc1RhYmxlQ2VsbE5vZGUobikpICE9PSBudWxsIHx8IGlzVGFibGVTZWxlY3Rpb247XG4gICAgaWYgKG5vZGVzLmxlbmd0aCAhPT0gMSB8fCAhJGlzVGFibGVOb2RlKG5vZGVzWzBdKSB8fCAhaXNTZWxlY3Rpb25JbnNpZGVPZkdyaWQgfHwgYW5jaG9yQW5kRm9jdXMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgW2FuY2hvciwgZm9jdXNdID0gYW5jaG9yQW5kRm9jdXM7XG4gICAgY29uc3QgW2FuY2hvckNlbGxOb2RlLCBhbmNob3JSb3dOb2RlLCBncmlkTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoYW5jaG9yKTtcbiAgICBjb25zdCBmb2N1c0NlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1cy5nZXROb2RlKCksIG4gPT4gJGlzVGFibGVDZWxsTm9kZShuKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVSb3dOb2RlKGFuY2hvclJvd05vZGUpIHx8ICEkaXNUYWJsZU5vZGUoZ3JpZE5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IHRlbXBsYXRlR3JpZCA9IG5vZGVzWzBdO1xuICAgIGNvbnN0IFtpbml0aWFsR3JpZE1hcCwgYW5jaG9yQ2VsbE1hcCwgZm9jdXNDZWxsTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIGFuY2hvckNlbGxOb2RlLCBmb2N1c0NlbGxOb2RlKTtcbiAgICBjb25zdCBbdGVtcGxhdGVHcmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRlbXBsYXRlR3JpZCwgbnVsbCwgbnVsbCk7XG4gICAgY29uc3QgaW5pdGlhbFJvd0NvdW50ID0gaW5pdGlhbEdyaWRNYXAubGVuZ3RoO1xuICAgIGNvbnN0IGluaXRpYWxDb2xDb3VudCA9IGluaXRpYWxSb3dDb3VudCA+IDAgPyBpbml0aWFsR3JpZE1hcFswXS5sZW5ndGggOiAwO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhIHJhbmdlIHNlbGVjdGlvbiwgd2UnbGwgZml0IHRoZSB0ZW1wbGF0ZSBncmlkIGludG8gdGhlXG4gICAgLy8gdGFibGUsIGdyb3dpbmcgdGhlIHRhYmxlIGlmIG5lY2Vzc2FyeS5cbiAgICBsZXQgc3RhcnRSb3cgPSBhbmNob3JDZWxsTWFwLnN0YXJ0Um93O1xuICAgIGxldCBzdGFydENvbCA9IGFuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW47XG4gICAgbGV0IGFmZmVjdGVkUm93Q291bnQgPSB0ZW1wbGF0ZUdyaWRNYXAubGVuZ3RoO1xuICAgIGxldCBhZmZlY3RlZENvbENvdW50ID0gYWZmZWN0ZWRSb3dDb3VudCA+IDAgPyB0ZW1wbGF0ZUdyaWRNYXBbMF0ubGVuZ3RoIDogMDtcbiAgICBpZiAoaXNUYWJsZVNlbGVjdGlvbikge1xuICAgICAgLy8gSWYgd2UgaGF2ZSBhIHRhYmxlIHNlbGVjdGlvbiwgd2UnbGwgb25seSBtb2RpZnkgdGhlIGNlbGxzIHdpdGhpblxuICAgICAgLy8gdGhlIHNlbGVjdGlvbiBib3VuZGFyeS5cbiAgICAgIGNvbnN0IHNlbGVjdGlvbkJvdW5kYXJ5ID0gJGNvbXB1dGVUYWJsZUNlbGxSZWN0Qm91bmRhcnkoaW5pdGlhbEdyaWRNYXAsIGFuY2hvckNlbGxNYXAsIGZvY3VzQ2VsbE1hcCk7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Sb3dDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heFJvdyAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdyArIDE7XG4gICAgICBjb25zdCBzZWxlY3Rpb25Db2xDb3VudCA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1heENvbHVtbiAtIHNlbGVjdGlvbkJvdW5kYXJ5Lm1pbkNvbHVtbiArIDE7XG4gICAgICBzdGFydFJvdyA9IHNlbGVjdGlvbkJvdW5kYXJ5Lm1pblJvdztcbiAgICAgIHN0YXJ0Q29sID0gc2VsZWN0aW9uQm91bmRhcnkubWluQ29sdW1uO1xuICAgICAgYWZmZWN0ZWRSb3dDb3VudCA9IE1hdGgubWluKGFmZmVjdGVkUm93Q291bnQsIHNlbGVjdGlvblJvd0NvdW50KTtcbiAgICAgIGFmZmVjdGVkQ29sQ291bnQgPSBNYXRoLm1pbihhZmZlY3RlZENvbENvdW50LCBzZWxlY3Rpb25Db2xDb3VudCk7XG4gICAgfVxuXG4gICAgLy8gU3RlcCAxOiBVbm1lcmdlIGFsbCBtZXJnZWQgY2VsbHMgd2l0aGluIHRoZSBhZmZlY3RlZCBhcmVhXG4gICAgbGV0IGRpZFBlcmZvcm1NZXJnZU9wZXJhdGlvbnMgPSBmYWxzZTtcbiAgICBjb25zdCBsYXN0Um93Rm9yVW5tZXJnZSA9IE1hdGgubWluKGluaXRpYWxSb3dDb3VudCwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgY29uc3QgbGFzdENvbEZvclVubWVyZ2UgPSBNYXRoLm1pbihpbml0aWFsQ29sQ291bnQsIHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudCkgLSAxO1xuICAgIGNvbnN0IHVubWVyZ2VkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDw9IGxhc3RSb3dGb3JVbm1lcmdlOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8PSBsYXN0Q29sRm9yVW5tZXJnZTsgY29sKyspIHtcbiAgICAgICAgY29uc3QgY2VsbE1hcCA9IGluaXRpYWxHcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgaWYgKHVubWVyZ2VkS2V5cy5oYXMoY2VsbE1hcC5jZWxsLmdldEtleSgpKSkge1xuICAgICAgICAgIGNvbnRpbnVlOyAvLyBjZWxsIHdhcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGlmIChjZWxsTWFwLmNlbGwuX19yb3dTcGFuID09PSAxICYmIGNlbGxNYXAuY2VsbC5fX2NvbFNwYW4gPT09IDEpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBub3QgYSBtZXJnZWQgY2VsbFxuICAgICAgICB9XG4gICAgICAgICR1bm1lcmdlQ2VsbE5vZGUoY2VsbE1hcC5jZWxsKTtcbiAgICAgICAgdW5tZXJnZWRLZXlzLmFkZChjZWxsTWFwLmNlbGwuZ2V0S2V5KCkpO1xuICAgICAgICBkaWRQZXJmb3JtTWVyZ2VPcGVyYXRpb25zID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMjogRXhwYW5kIGN1cnJlbnQgdGFibGUgKGlmIG5lZWRlZClcbiAgICBjb25zdCByb3dzVG9JbnNlcnQgPSBhZmZlY3RlZFJvd0NvdW50IC0gaW5pdGlhbFJvd0NvdW50ICsgc3RhcnRSb3c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzVG9JbnNlcnQ7IGkrKykge1xuICAgICAgY29uc3QgY2VsbE1hcCA9IGludGVyaW1HcmlkTWFwW2luaXRpYWxSb3dDb3VudCAtIDFdWzBdO1xuICAgICAgJGluc2VydFRhYmxlUm93QXROb2RlKGNlbGxNYXAuY2VsbCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbHNUb0luc2VydCA9IGFmZmVjdGVkQ29sQ291bnQgLSBpbml0aWFsQ29sQ291bnQgKyBzdGFydENvbDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHNUb0luc2VydDsgaSsrKSB7XG4gICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbMF1baW5pdGlhbENvbENvdW50IC0gMV07XG4gICAgICAkaW5zZXJ0VGFibGVDb2x1bW5BdE5vZGUoY2VsbE1hcC5jZWxsLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICAgIFtpbnRlcmltR3JpZE1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwU2tpcENlbGxDaGVjayhncmlkTm9kZS5nZXRXcml0YWJsZSgpLCBudWxsLCBudWxsKTtcblxuICAgIC8vIFN0ZXAgMzogTWVyZ2UgY2VsbHMgYW5kIHNldCBjZWxsIGNvbnRlbnQsIHRvIG1hdGNoIHRlbXBsYXRlIGdyaWRcbiAgICBmb3IgKGxldCByb3cgPSBzdGFydFJvdzsgcm93IDwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50OyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gc3RhcnRDb2w7IGNvbCA8IHN0YXJ0Q29sICsgYWZmZWN0ZWRDb2xDb3VudDsgY29sKyspIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVSb3cgPSByb3cgLSBzdGFydFJvdztcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDb2wgPSBjb2wgLSBzdGFydENvbDtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVDZWxsTWFwID0gdGVtcGxhdGVHcmlkTWFwW3RlbXBsYXRlUm93XVt0ZW1wbGF0ZUNvbF07XG4gICAgICAgIGlmICh0ZW1wbGF0ZUNlbGxNYXAuc3RhcnRSb3cgIT09IHRlbXBsYXRlUm93IHx8IHRlbXBsYXRlQ2VsbE1hcC5zdGFydENvbHVtbiAhPT0gdGVtcGxhdGVDb2wpIHtcbiAgICAgICAgICBjb250aW51ZTsgLy8gY2VsbCBpcyBhIG1lcmdlZCBjZWxsIHRoYXQgd2FzIGFscmVhZHkgaGFuZGxlZFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlQ2VsbCA9IHRlbXBsYXRlQ2VsbE1hcC5jZWxsO1xuICAgICAgICBpZiAodGVtcGxhdGVDZWxsLl9fcm93U3BhbiAhPT0gMSB8fCB0ZW1wbGF0ZUNlbGwuX19jb2xTcGFuICE9PSAxKSB7XG4gICAgICAgICAgY29uc3QgY2VsbHNUb01lcmdlID0gW107XG4gICAgICAgICAgY29uc3QgbGFzdFJvd0Zvck1lcmdlID0gTWF0aC5taW4ocm93ICsgdGVtcGxhdGVDZWxsLl9fcm93U3Bhbiwgc3RhcnRSb3cgKyBhZmZlY3RlZFJvd0NvdW50KSAtIDE7XG4gICAgICAgICAgY29uc3QgbGFzdENvbEZvck1lcmdlID0gTWF0aC5taW4oY29sICsgdGVtcGxhdGVDZWxsLl9fY29sU3Bhbiwgc3RhcnRDb2wgKyBhZmZlY3RlZENvbENvdW50KSAtIDE7XG4gICAgICAgICAgZm9yIChsZXQgciA9IHJvdzsgciA8PSBsYXN0Um93Rm9yTWVyZ2U7IHIrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbDsgYyA8PSBsYXN0Q29sRm9yTWVyZ2U7IGMrKykge1xuICAgICAgICAgICAgICBjb25zdCBjZWxsTWFwID0gaW50ZXJpbUdyaWRNYXBbcl1bY107XG4gICAgICAgICAgICAgIGNlbGxzVG9NZXJnZS5wdXNoKGNlbGxNYXAuY2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgICRtZXJnZUNlbGxzKGNlbGxzVG9NZXJnZSk7XG4gICAgICAgICAgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNlbGxcbiAgICAgICAgfSA9IGludGVyaW1HcmlkTWFwW3Jvd11bY29sXTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxDaGlsZHJlbiA9IGNlbGwuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgdGVtcGxhdGVDZWxsLmdldENoaWxkcmVuKCkuZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKCRpc1RleHROb2RlKGNoaWxkKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyYWdyYXBoTm9kZSA9ICRjcmVhdGVQYXJhZ3JhcGhOb2RlKCk7XG4gICAgICAgICAgICBwYXJhZ3JhcGhOb2RlLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgICBjZWxsLmFwcGVuZChjaGlsZCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGwuYXBwZW5kKGNoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvcmlnaW5hbENoaWxkcmVuLmZvckVhY2gobiA9PiBuLnJlbW92ZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVGFibGVTZWxlY3Rpb24gJiYgZGlkUGVyZm9ybU1lcmdlT3BlcmF0aW9ucykge1xuICAgICAgLy8gcmVzZXQgdGhlIHRhYmxlIHNlbGVjdGlvbiBpbiBjYXNlIHRoZSBhbmNob3Igb3IgZm9jdXMgY2VsbCB3YXNcbiAgICAgIC8vIHJlbW92ZWQgdmlhIG1lcmdlIG9wZXJhdGlvbnNcbiAgICAgIGNvbnN0IFtmaW5hbEdyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2soZ3JpZE5vZGUuZ2V0V3JpdGFibGUoKSwgbnVsbCwgbnVsbCk7XG4gICAgICBjb25zdCBuZXdBbmNob3JDZWxsTWFwID0gZmluYWxHcmlkTWFwW2FuY2hvckNlbGxNYXAuc3RhcnRSb3ddW2FuY2hvckNlbGxNYXAuc3RhcnRDb2x1bW5dO1xuICAgICAgbmV3QW5jaG9yQ2VsbE1hcC5jZWxsLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICB0YWJsZU9ic2VydmVyLmxpc3RlbmVyc1RvUmVtb3ZlLmFkZChlZGl0b3IucmVnaXN0ZXJDb21tYW5kKFNFTEVDVElPTl9DSEFOR0VfQ09NTUFORCwgKCkgPT4ge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBjb25zdCBwcmV2U2VsZWN0aW9uID0gJGdldFByZXZpb3VzU2VsZWN0aW9uKCk7XG4gICAgY29uc3QgbmV4dEZvY3VzID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhck5leHRGb2N1cygpO1xuICAgIGlmIChuZXh0Rm9jdXMgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZm9jdXNDZWxsXG4gICAgICB9ID0gbmV4dEZvY3VzO1xuICAgICAgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLnRhYmxlS2V5ID09PSB0YWJsZU9ic2VydmVyLnRhYmxlTm9kZUtleSkge1xuICAgICAgICBpZiAoZm9jdXNDZWxsLnggPT09IHRhYmxlT2JzZXJ2ZXIuZm9jdXNYICYmIGZvY3VzQ2VsbC55ID09PSB0YWJsZU9ic2VydmVyLmZvY3VzWSkge1xuICAgICAgICAgIC8vIFRoZSBzZWxlY3Rpb24gaXMgYWxyZWFkeSB0aGUgY29ycmVjdCB0YWJsZSBzZWxlY3Rpb25cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGZvY3VzQ2VsbCk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZm9jdXNDZWxsICE9PSB0YWJsZU9ic2VydmVyLmFuY2hvckNlbGwgJiYgJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkpIHtcbiAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBoYXMgY3Jvc3NlZCBjZWxsc1xuICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRGb2N1c0NlbGxGb3JTZWxlY3Rpb24oZm9jdXNDZWxsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZENoZWNrU2VsZWN0aW9uID0gdGFibGVPYnNlcnZlci5nZXRBbmRDbGVhclNob3VsZENoZWNrU2VsZWN0aW9uKCk7XG4gICAgLy8gSWYgdGhleSBwcmVzc2VkIHRoZSBkb3duIGFycm93IHdpdGggdGhlIHNlbGVjdGlvbiBvdXRzaWRlIG9mIHRoZVxuICAgIC8vIHRhYmxlLCBhbmQgdGhlbiB0aGUgc2VsZWN0aW9uIGVuZHMgdXAgaW4gdGhlIHRhYmxlIGJ1dCBub3QgaW4gdGhlXG4gICAgLy8gZmlyc3QgY2VsbCwgdGhlbiBtb3ZlIHRoZSBzZWxlY3Rpb24gdG8gdGhlIGZpcnN0IGNlbGwuXG4gICAgaWYgKHNob3VsZENoZWNrU2VsZWN0aW9uICYmICRpc1JhbmdlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pICYmICRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgIGNvbnN0IGFuY2hvciA9IHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpO1xuICAgICAgY29uc3QgZmlyc3RSb3cgPSB0YWJsZU5vZGUuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbCA9ICRmaW5kQ2VsbE5vZGUoYW5jaG9yKTtcbiAgICAgIGlmIChhbmNob3JDZWxsICE9PSBudWxsICYmICRpc1RhYmxlUm93Tm9kZShmaXJzdFJvdykpIHtcbiAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gZmlyc3RSb3cuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgICAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShmaXJzdENlbGwpICYmIHRhYmxlTm9kZS5pcygkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsIG5vZGUgPT4gbm9kZS5pcyh0YWJsZU5vZGUpIHx8IG5vZGUuaXMoZmlyc3RDZWxsKSkpKSB7XG4gICAgICAgICAgLy8gVGhlIHNlbGVjdGlvbiBtb3ZlZCB0byB0aGUgdGFibGUsIGJ1dCBub3QgaW4gdGhlIGZpcnN0IGNlbGxcbiAgICAgICAgICBmaXJzdENlbGwuc2VsZWN0U3RhcnQoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yTm9kZSA9IGFuY2hvci5nZXROb2RlKCk7XG4gICAgICBjb25zdCBmb2N1c05vZGUgPSBmb2N1cy5nZXROb2RlKCk7XG4gICAgICAvLyBVc2luZyBleHBsaWNpdCBjb21wYXJpc29uIHdpdGggdGFibGUgbm9kZSB0byBlbnN1cmUgaXQncyBub3QgYSBuZXN0ZWQgdGFibGVcbiAgICAgIC8vIGFzIGluIHRoYXQgY2FzZSB3ZSdsbCBsZWF2ZSBzZWxlY3Rpb24gcmVzb2x2aW5nIHRvIHRoYXQgdGFibGVcbiAgICAgIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRDZWxsTm9kZShhbmNob3JOb2RlKTtcbiAgICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKGZvY3VzTm9kZSk7XG4gICAgICBjb25zdCBpc0FuY2hvckluc2lkZSA9ICEhKGFuY2hvckNlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShhbmNob3JDZWxsTm9kZSkpKTtcbiAgICAgIGNvbnN0IGlzRm9jdXNJbnNpZGUgPSAhIShmb2N1c0NlbGxOb2RlICYmIHRhYmxlTm9kZS5pcygkZmluZFRhYmxlTm9kZShmb2N1c0NlbGxOb2RlKSkpO1xuICAgICAgY29uc3QgaXNQYXJ0aWFsbHlXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICE9PSBpc0ZvY3VzSW5zaWRlO1xuICAgICAgY29uc3QgaXNXaXRoaW5UYWJsZSA9IGlzQW5jaG9ySW5zaWRlICYmIGlzRm9jdXNJbnNpZGU7XG4gICAgICBjb25zdCBpc0JhY2t3YXJkID0gc2VsZWN0aW9uLmlzQmFja3dhcmQoKTtcbiAgICAgIGlmIChpc1BhcnRpYWxseVdpdGhpblRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICBpZiAoaXNGb2N1c0luc2lkZSkge1xuICAgICAgICAgIGNvbnN0IFt0YWJsZU1hcF0gPSAkY29tcHV0ZVRhYmxlTWFwKHRhYmxlTm9kZSwgZm9jdXNDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQoaXNCYWNrd2FyZCA/IGZpcnN0Q2VsbC5nZXRLZXkoKSA6IGxhc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gZmlyc3RDZWxsLmdldENoaWxkcmVuU2l6ZSgpIDogbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBbmNob3JJbnNpZGUpIHtcbiAgICAgICAgICBjb25zdCBbdGFibGVNYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gICAgICAgICAgY29uc3QgZmlyc3RDZWxsID0gdGFibGVNYXBbMF1bMF0uY2VsbDtcbiAgICAgICAgICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsO1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIElmIGlzQmFja3dhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBlbmQgb2YgdGhlIHRhYmxlIHNvIHRoYXQgd2hlbiB0aGUgY3Vyc29yIG1vdmVzIG91dHNpZGUgb2ZcbiAgICAgICAgICAgKiB0aGUgdGFibGUgaW4gdGhlIGJhY2t3YXJkIGRpcmVjdGlvbiwgdGhlIGVudGlyZSB0YWJsZSB3aWxsIGJlIHNlbGVjdGVkIGZyb20gaXRzIGVuZC5cbiAgICAgICAgICAgKiBPdGhlcndpc2UsIGlmIGZvcndhcmQsIHNldCB0aGUgYW5jaG9yIHRvIGJlIGF0IHRoZSBzdGFydCBvZiB0aGUgdGFibGUgc28gdGhhdCB3aGVuIHRoZSBmb2N1cyBpcyBkcmFnZ2VkXG4gICAgICAgICAgICogb3V0c2lkZSB0aCBlbmQgb2YgdGhlIHRhYmxlLCBpdCB3aWxsIHN0YXJ0IGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgdGFibGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQoaXNCYWNrd2FyZCA/IGxhc3RDZWxsLmdldEtleSgpIDogZmlyc3RDZWxsLmdldEtleSgpLCBpc0JhY2t3YXJkID8gbGFzdENlbGwuZ2V0Q2hpbGRyZW5TaXplKCkgOiAwLCAnZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgJGFkZEhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgfSBlbHNlIGlmIChpc1dpdGhpblRhYmxlKSB7XG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gc2VsZWN0aW9uIHNwYW5zIGFjcm9zcyBtdWx0aXBsZSBjZWxscyBidXQgc3RpbGxcbiAgICAgICAgLy8gaGFzIHJhbmdlIHNlbGVjdGlvbiwgdGhlbiB3ZSBjb252ZXJ0IGl0IGludG8gdGFibGUgc2VsZWN0aW9uXG4gICAgICAgIGlmICghYW5jaG9yQ2VsbE5vZGUuaXMoZm9jdXNDZWxsTm9kZSkpIHtcbiAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGFuY2hvckNlbGxOb2RlKSk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEhhbmRsZSBjYXNlIHdoZW4gdGhlIHBvaW50ZXIgdHlwZSBpcyB0b3VjaCBhbmQgdGhlIGN1cnJlbnQgYW5kXG4gICAgICAgIC8vIHByZXZpb3VzIHNlbGVjdGlvbiBhcmUgY29sbGFwc2VkLCBhbmQgdGhlIHByZXZpb3VzIGFuY2hvciBhbmQgY3VycmVudFxuICAgICAgICAvLyBmb2N1cyBjZWxsIG5vZGVzIGFyZSBkaWZmZXJlbnQsIHRoZW4gd2UgY29udmVydCBpdCBpbnRvIHRhYmxlIHNlbGVjdGlvblxuICAgICAgICAvLyBIb3dldmVyLCBvbmx5IGRvIHRoaXMgaWYgdGhlIHRhYmxlIG9ic2VydmVyIGlzIGFjdGl2ZWx5IHNlbGVjdGluZyAodXNlciBkcmFnZ2luZylcbiAgICAgICAgLy8gdG8gcHJldmVudCB1bndhbnRlZCBzZWxlY3Rpb25zIHdoZW4gc2ltcGx5IHRhcHBpbmcgYmV0d2VlbiBjZWxscyBvbiBtb2JpbGVcbiAgICAgICAgaWYgKHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgdGFibGVPYnNlcnZlci5pc1NlbGVjdGluZyAmJiBzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSAmJiAkaXNSYW5nZVNlbGVjdGlvbihwcmV2U2VsZWN0aW9uKSAmJiBwcmV2U2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkpIHtcbiAgICAgICAgICBjb25zdCBwcmV2QW5jaG9yQ2VsbE5vZGUgPSAkZmluZENlbGxOb2RlKHByZXZTZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgICAgICAgaWYgKHByZXZBbmNob3JDZWxsTm9kZSAmJiAhcHJldkFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHByZXZBbmNob3JDZWxsTm9kZSkpO1xuICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKCRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZvY3VzQ2VsbE5vZGUpLCB0cnVlKTtcbiAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIucG9pbnRlclR5cGUgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2VsZWN0aW9uICYmICRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmIHNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVOb2RlLmdldEtleSgpKSB7XG4gICAgICAvLyBpZiBzZWxlY3Rpb24gZ29lcyBvdXRzaWRlIG9mIHRoZSB0YWJsZSB3ZSBuZWVkIHRvIGNoYW5nZSBpdCB0byBSYW5nZSBzZWxlY3Rpb25cbiAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihlZGl0b3JXaW5kb3cpO1xuICAgICAgaWYgKGRvbVNlbGVjdGlvbiAmJiBkb21TZWxlY3Rpb24uYW5jaG9yTm9kZSAmJiBkb21TZWxlY3Rpb24uZm9jdXNOb2RlKSB7XG4gICAgICAgIGNvbnN0IGZvY3VzTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5mb2N1c05vZGUpO1xuICAgICAgICBjb25zdCBpc0ZvY3VzT3V0c2lkZSA9IGZvY3VzTm9kZSAmJiAhdGFibGVOb2RlLmlzUGFyZW50T2YoZm9jdXNOb2RlKTtcbiAgICAgICAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGRvbVNlbGVjdGlvbi5hbmNob3JOb2RlKTtcbiAgICAgICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSBhbmNob3JOb2RlICYmIHRhYmxlTm9kZS5pc1BhcmVudE9mKGFuY2hvck5vZGUpO1xuICAgICAgICBpZiAoaXNGb2N1c091dHNpZGUgJiYgaXNBbmNob3JJbnNpZGUgJiYgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPiAwKSB7XG4gICAgICAgICAgY29uc3QgbmV3U2VsZWN0aW9uID0gJGNyZWF0ZVJhbmdlU2VsZWN0aW9uRnJvbURvbShkb21TZWxlY3Rpb24sIGVkaXRvcik7XG4gICAgICAgICAgaWYgKG5ld1NlbGVjdGlvbikge1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmFuY2hvci5zZXQodGFibGVOb2RlLmdldEtleSgpLCBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpID8gdGFibGVOb2RlLmdldENoaWxkcmVuU2l6ZSgpIDogMCwgJ2VsZW1lbnQnKTtcbiAgICAgICAgICAgIGRvbVNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNlbGVjdGlvbiAmJiAhc2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pICYmICgkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pIHx8ICRpc1RhYmxlU2VsZWN0aW9uKHByZXZTZWxlY3Rpb24pKSAmJiB0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uICYmICF0YWJsZU9ic2VydmVyLnRhYmxlU2VsZWN0aW9uLmlzKHByZXZTZWxlY3Rpb24pKSB7XG4gICAgICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSAmJiBzZWxlY3Rpb24udGFibGVLZXkgPT09IHRhYmxlT2JzZXJ2ZXIudGFibGVOb2RlS2V5KSB7XG4gICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgIH0gZWxzZSBpZiAoISRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikgJiYgJGlzVGFibGVTZWxlY3Rpb24ocHJldlNlbGVjdGlvbikgJiYgcHJldlNlbGVjdGlvbi50YWJsZUtleSA9PT0gdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkpIHtcbiAgICAgICAgdGFibGVPYnNlcnZlci4kdXBkYXRlVGFibGVUYWJsZVNlbGVjdGlvbihudWxsKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhYmxlT2JzZXJ2ZXIuaGFzSGlqYWNrZWRTZWxlY3Rpb25TdHlsZXMgJiYgIXRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRyZW1vdmVIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9IGVsc2UgaWYgKCF0YWJsZU9ic2VydmVyLmhhc0hpamFja2VkU2VsZWN0aW9uU3R5bGVzICYmIHRhYmxlTm9kZS5pc1NlbGVjdGVkKCkpIHtcbiAgICAgICRhZGRIaWdobGlnaHRTdHlsZVRvVGFibGUoZWRpdG9yLCB0YWJsZU9ic2VydmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0NSSVRJQ0FMKSk7XG4gIHRhYmxlT2JzZXJ2ZXIubGlzdGVuZXJzVG9SZW1vdmUuYWRkKGVkaXRvci5yZWdpc3RlckNvbW1hbmQoSU5TRVJUX1BBUkFHUkFQSF9DT01NQU5ELCAoKSA9PiB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICAgIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgfHwgISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGVkZ2VQb3NpdGlvbiA9ICRnZXRUYWJsZUVkZ2VDdXJzb3JQb3NpdGlvbihlZGl0b3IsIHNlbGVjdGlvbiwgdGFibGVOb2RlKTtcbiAgICBpZiAoZWRnZVBvc2l0aW9uKSB7XG4gICAgICAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgQ09NTUFORF9QUklPUklUWV9DUklUSUNBTCkpO1xuICByZXR1cm4gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGRldGFjaFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gdGFibGVPYnNlcnZlcikge1xuICAgIGRlbGV0ZSB0YWJsZUVsZW1lbnRbTEVYSUNBTF9FTEVNRU5UX0tFWV07XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFRhYmxlT2JzZXJ2ZXJUb1RhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgaWYgKCEoZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSA9PT0gbnVsbCkpIHtcbiAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYHRhYmxlRWxlbWVudCBhbHJlYWR5IGhhcyBhbiBhdHRhY2hlZCBUYWJsZU9ic2VydmVyYCk7XG4gIH1cbiAgdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldID0gdGFibGVPYnNlcnZlcjtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlT2JzZXJ2ZXJGcm9tVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkge1xuICByZXR1cm4gdGFibGVFbGVtZW50W0xFWElDQUxfRUxFTUVOVF9LRVldIHx8IG51bGw7XG59XG5mdW5jdGlvbiBnZXRET01DZWxsRnJvbVRhcmdldChub2RlKSB7XG4gIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50Tm9kZSAhPSBudWxsKSB7XG4gICAgY29uc3Qgbm9kZU5hbWUgPSBjdXJyZW50Tm9kZS5ub2RlTmFtZTtcbiAgICBpZiAobm9kZU5hbWUgPT09ICdURCcgfHwgbm9kZU5hbWUgPT09ICdUSCcpIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3I6IGludGVybmFsIGZpZWxkXG4gICAgICBjb25zdCBjZWxsID0gY3VycmVudE5vZGUuX2NlbGw7XG4gICAgICBpZiAoY2VsbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldERPTUNlbGxJblRhYmxlRnJvbVRhcmdldCh0YWJsZSwgbm9kZSkge1xuICBpZiAoIXRhYmxlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGNlbGwgPSBudWxsO1xuICBmb3IgKGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7IGN1cnJlbnROb2RlICE9IG51bGw7IGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZSkge1xuICAgIGlmIChjdXJyZW50Tm9kZSA9PT0gdGFibGUpIHtcbiAgICAgIHJldHVybiBjZWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlTmFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTmFtZSA9PT0gJ1REJyB8fCBub2RlTmFtZSA9PT0gJ1RIJykge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGNlbGwgPSBjdXJyZW50Tm9kZS5fY2VsbCB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldFRhYmxlKHRhYmxlTm9kZSwgZG9tKSB7XG4gIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gIGNvbnN0IGRvbVJvd3MgPSBbXTtcbiAgY29uc3QgZ3JpZCA9IHtcbiAgICBjb2x1bW5zOiAwLFxuICAgIGRvbVJvd3MsXG4gICAgcm93czogMFxuICB9O1xuICBsZXQgY3VycmVudE5vZGUgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvcigndHInKTtcbiAgbGV0IHggPSAwO1xuICBsZXQgeSA9IDA7XG4gIGRvbVJvd3MubGVuZ3RoID0gMDtcbiAgd2hpbGUgKGN1cnJlbnROb2RlICE9IG51bGwpIHtcbiAgICBjb25zdCBub2RlTWFtZSA9IGN1cnJlbnROb2RlLm5vZGVOYW1lO1xuICAgIGlmIChub2RlTWFtZSA9PT0gJ1REJyB8fCBub2RlTWFtZSA9PT0gJ1RIJykge1xuICAgICAgY29uc3QgZWxlbSA9IGN1cnJlbnROb2RlO1xuICAgICAgY29uc3QgY2VsbCA9IHtcbiAgICAgICAgZWxlbSxcbiAgICAgICAgaGFzQmFja2dyb3VuZENvbG9yOiBlbGVtLnN0eWxlLmJhY2tncm91bmRDb2xvciAhPT0gJycsXG4gICAgICAgIGhpZ2hsaWdodGVkOiBmYWxzZSxcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfTtcblxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvcjogaW50ZXJuYWwgZmllbGRcbiAgICAgIGN1cnJlbnROb2RlLl9jZWxsID0gY2VsbDtcbiAgICAgIGxldCByb3cgPSBkb21Sb3dzW3ldO1xuICAgICAgaWYgKHJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJvdyA9IGRvbVJvd3NbeV0gPSBbXTtcbiAgICAgIH1cbiAgICAgIHJvd1t4XSA9IGNlbGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gY3VycmVudE5vZGUuZmlyc3RDaGlsZDtcbiAgICAgIGlmIChjaGlsZCAhPSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnROb2RlID0gY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBzaWJsaW5nID0gY3VycmVudE5vZGUubmV4dFNpYmxpbmc7XG4gICAgaWYgKHNpYmxpbmcgIT0gbnVsbCkge1xuICAgICAgeCsrO1xuICAgICAgY3VycmVudE5vZGUgPSBzaWJsaW5nO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHBhcmVudCA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgaWYgKHBhcmVudCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBwYXJlbnRTaWJsaW5nID0gcGFyZW50Lm5leHRTaWJsaW5nO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHkrKztcbiAgICAgIHggPSAwO1xuICAgICAgY3VycmVudE5vZGUgPSBwYXJlbnRTaWJsaW5nO1xuICAgIH1cbiAgfVxuICBncmlkLmNvbHVtbnMgPSB4ICsgMTtcbiAgZ3JpZC5yb3dzID0geSArIDE7XG4gIHJldHVybiBncmlkO1xufVxuZnVuY3Rpb24gJHVwZGF0ZURPTUZvclNlbGVjdGlvbihlZGl0b3IsIHRhYmxlLCBzZWxlY3Rpb24pIHtcbiAgY29uc3Qgc2VsZWN0ZWRDZWxsTm9kZXMgPSBuZXcgU2V0KHNlbGVjdGlvbiA/IHNlbGVjdGlvbi5nZXROb2RlcygpIDogW10pO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZSwgKGNlbGwsIGxleGljYWxOb2RlKSA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBpZiAoc2VsZWN0ZWRDZWxsTm9kZXMuaGFzKGxleGljYWxOb2RlKSkge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgICAkYWRkSGlnaGxpZ2h0VG9ET00oZWRpdG9yLCBjZWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbC5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICAgICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICAgIGlmICghZWxlbS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgZWxlbS5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uICRmb3JFYWNoVGFibGVDZWxsKGdyaWQsIGNiKSB7XG4gIGNvbnN0IHtcbiAgICBkb21Sb3dzXG4gIH0gPSBncmlkO1xuICBmb3IgKGxldCB5ID0gMDsgeSA8IGRvbVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmICghcm93KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgeCA9IDA7IHggPCByb3cubGVuZ3RoOyB4KyspIHtcbiAgICAgIGNvbnN0IGNlbGwgPSByb3dbeF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBsZXhpY2FsTm9kZSA9ICRnZXROZWFyZXN0Tm9kZUZyb21ET01Ob2RlKGNlbGwuZWxlbSk7XG4gICAgICBpZiAobGV4aWNhbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgY2IoY2VsbCwgbGV4aWNhbE5vZGUsIHtcbiAgICAgICAgICB4LFxuICAgICAgICAgIHlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiAkYWRkSGlnaGxpZ2h0U3R5bGVUb1RhYmxlKGVkaXRvciwgdGFibGVTZWxlY3Rpb24pIHtcbiAgdGFibGVTZWxlY3Rpb24uJGRpc2FibGVIaWdobGlnaHRTdHlsZSgpO1xuICAkZm9yRWFjaFRhYmxlQ2VsbCh0YWJsZVNlbGVjdGlvbi50YWJsZSwgY2VsbCA9PiB7XG4gICAgY2VsbC5oaWdobGlnaHRlZCA9IHRydWU7XG4gICAgJGFkZEhpZ2hsaWdodFRvRE9NKGVkaXRvciwgY2VsbCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodFN0eWxlVG9UYWJsZShlZGl0b3IsIHRhYmxlT2JzZXJ2ZXIpIHtcbiAgdGFibGVPYnNlcnZlci4kZW5hYmxlSGlnaGxpZ2h0U3R5bGUoKTtcbiAgJGZvckVhY2hUYWJsZUNlbGwodGFibGVPYnNlcnZlci50YWJsZSwgY2VsbCA9PiB7XG4gICAgY29uc3QgZWxlbSA9IGNlbGwuZWxlbTtcbiAgICBjZWxsLmhpZ2hsaWdodGVkID0gZmFsc2U7XG4gICAgJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKTtcbiAgICBpZiAoIWVsZW0uZ2V0QXR0cmlidXRlKCdzdHlsZScpKSB7XG4gICAgICBlbGVtLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gJHNlbGVjdEFkamFjZW50Q2VsbCh0YWJsZUNlbGxOb2RlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3Qgc2libGluZ01ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldE5leHRTaWJsaW5nJyA6ICdnZXRQcmV2aW91c1NpYmxpbmcnO1xuICBjb25zdCBjaGlsZE1ldGhvZCA9IGRpcmVjdGlvbiA9PT0gJ25leHQnID8gJ2dldEZpcnN0Q2hpbGQnIDogJ2dldExhc3RDaGlsZCc7XG4gIGNvbnN0IHNpYmxpbmcgPSB0YWJsZUNlbGxOb2RlW3NpYmxpbmdNZXRob2RdKCk7XG4gIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgIHJldHVybiBzaWJsaW5nLnNlbGVjdEVuZCgpO1xuICB9XG4gIGNvbnN0IHBhcmVudFJvdyA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQodGFibGVDZWxsTm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgaWYgKCEocGFyZW50Um93ICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBDZWxsIG5vdCBpbiB0YWJsZSByb3dgKTtcbiAgfVxuICBmb3IgKGxldCBuZXh0Um93ID0gcGFyZW50Um93W3NpYmxpbmdNZXRob2RdKCk7ICRpc1RhYmxlUm93Tm9kZShuZXh0Um93KTsgbmV4dFJvdyA9IG5leHRSb3dbc2libGluZ01ldGhvZF0oKSkge1xuICAgIGNvbnN0IGNoaWxkID0gbmV4dFJvd1tjaGlsZE1ldGhvZF0oKTtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUoY2hpbGQpKSB7XG4gICAgICByZXR1cm4gY2hpbGQuc2VsZWN0RW5kKCk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFRhYmxlID0gJGZpbmRNYXRjaGluZ1BhcmVudChwYXJlbnRSb3csICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKHBhcmVudFRhYmxlICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgc2VsZWN0QWRqYWNlbnRDZWxsOiBSb3cgbm90IGluIHRhYmxlYCk7XG4gIH1cbiAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gJ25leHQnID8gcGFyZW50VGFibGUuc2VsZWN0TmV4dCgpIDogcGFyZW50VGFibGUuc2VsZWN0UHJldmlvdXMoKTtcbn1cbmNvbnN0IHNlbGVjdFRhYmxlTm9kZUluRGlyZWN0aW9uID0gKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTm9kZSwgeCwgeSwgZGlyZWN0aW9uKSA9PiB7XG4gIGNvbnN0IGlzRm9yd2FyZCA9IGRpcmVjdGlvbiA9PT0gJ2ZvcndhcmQnO1xuICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgIGlmICh4ICE9PSAoaXNGb3J3YXJkID8gdGFibGVPYnNlcnZlci50YWJsZS5jb2x1bW5zIC0gMSA6IDApKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4ICsgKGlzRm9yd2FyZCA/IDEgOiAtMSksIHksIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCBpc0ZvcndhcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHkgIT09IChpc0ZvcndhcmQgPyB0YWJsZU9ic2VydmVyLnRhYmxlLnJvd3MgLSAxIDogMCkpIHtcbiAgICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coaXNGb3J3YXJkID8gMCA6IHRhYmxlT2JzZXJ2ZXIudGFibGUuY29sdW1ucyAtIDEsIHkgKyAoaXNGb3J3YXJkID8gMSA6IC0xKSwgdGFibGVPYnNlcnZlci50YWJsZSksIGlzRm9yd2FyZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzRm9yd2FyZCkge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ3VwJzpcbiAgICAgIGlmICh5ICE9PSAwKSB7XG4gICAgICAgIHNlbGVjdFRhYmxlQ2VsbE5vZGUodGFibGVOb2RlLmdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5IC0gMSwgdGFibGVPYnNlcnZlci50YWJsZSksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3RQcmV2aW91cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnZG93bic6XG4gICAgICBpZiAoeSAhPT0gdGFibGVPYnNlcnZlci50YWJsZS5yb3dzIC0gMSkge1xuICAgICAgICBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlTm9kZS5nZXRDZWxsTm9kZUZyb21Db3Jkc09yVGhyb3coeCwgeSArIDEsIHRhYmxlT2JzZXJ2ZXIudGFibGUpLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhYmxlTm9kZS5zZWxlY3ROZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuZnVuY3Rpb24gZ2V0Q29ybmVyKHJlY3QsIGNlbGxWYWx1ZSkge1xuICBsZXQgY29sTmFtZTtcbiAgbGV0IHJvd05hbWU7XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRDb2x1bW4gPT09IHJlY3QubWluQ29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtaW5Db2x1bW4nO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydENvbHVtbiArIGNlbGxWYWx1ZS5jZWxsLl9fY29sU3BhbiAtIDEgPT09IHJlY3QubWF4Q29sdW1uKSB7XG4gICAgY29sTmFtZSA9ICdtYXhDb2x1bW4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChjZWxsVmFsdWUuc3RhcnRSb3cgPT09IHJlY3QubWluUm93KSB7XG4gICAgcm93TmFtZSA9ICdtaW5Sb3cnO1xuICB9IGVsc2UgaWYgKGNlbGxWYWx1ZS5zdGFydFJvdyArIGNlbGxWYWx1ZS5jZWxsLl9fcm93U3BhbiAtIDEgPT09IHJlY3QubWF4Um93KSB7XG4gICAgcm93TmFtZSA9ICdtYXhSb3cnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBbY29sTmFtZSwgcm93TmFtZV07XG59XG5mdW5jdGlvbiBnZXRDb3JuZXJPclRocm93KHJlY3QsIGNlbGxWYWx1ZSkge1xuICBjb25zdCBjb3JuZXIgPSBnZXRDb3JuZXIocmVjdCwgY2VsbFZhbHVlKTtcbiAgaWYgKCEoY29ybmVyICE9PSBudWxsKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgZ2V0Q29ybmVyT3JUaHJvdzogY2VsbCAke2NlbGxWYWx1ZS5jZWxsLmdldEtleSgpfSBpcyBub3QgYXQgYSBjb3JuZXIgb2YgcmVjdGApO1xuICB9XG4gIHJldHVybiBjb3JuZXI7XG59XG5mdW5jdGlvbiBvcHBvc2l0ZUNvcm5lcihbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgcmV0dXJuIFtjb2xOYW1lID09PSAnbWluQ29sdW1uJyA/ICdtYXhDb2x1bW4nIDogJ21pbkNvbHVtbicsIHJvd05hbWUgPT09ICdtaW5Sb3cnID8gJ21heFJvdycgOiAnbWluUm93J107XG59XG5mdW5jdGlvbiBjZWxsQXRDb3JuZXJPclRocm93KHRhYmxlTWFwLCByZWN0LCBbY29sTmFtZSwgcm93TmFtZV0pIHtcbiAgY29uc3Qgcm93TnVtID0gcmVjdFtyb3dOYW1lXTtcbiAgY29uc3Qgcm93TWFwID0gdGFibGVNYXBbcm93TnVtXTtcbiAgaWYgKCEocm93TWFwICE9PSB1bmRlZmluZWQpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBjZWxsQXRDb3JuZXJPclRocm93OiAke3Jvd05hbWV9ID0gJHtTdHJpbmcocm93TnVtKX0gbWlzc2luZyBpbiB0YWJsZU1hcGApO1xuICB9XG4gIGNvbnN0IGNvbE51bSA9IHJlY3RbY29sTmFtZV07XG4gIGNvbnN0IGNlbGwgPSByb3dNYXBbY29sTnVtXTtcbiAgaWYgKCEoY2VsbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgY2VsbEF0Q29ybmVyT3JUaHJvdzogJHtjb2xOYW1lfSA9ICR7U3RyaW5nKGNvbE51bSl9IG1pc3NpbmcgaW4gdGFibGVNYXBgKTtcbiAgfVxuICByZXR1cm4gY2VsbDtcbn1cbmZ1bmN0aW9uICRleHRyYWN0UmVjdENvcm5lcnModGFibGVNYXAsIGFuY2hvckNlbGxWYWx1ZSwgbmV3Rm9jdXNDZWxsVmFsdWUpIHtcbiAgLy8gV2UgYXJlIHN1cmUgdGhhdCB0aGUgZm9jdXMgbm93IGVpdGhlciBjb250cmFjdHMgb3IgZXhwYW5kcyB0aGUgcmVjdFxuICAvLyBidXQgYm90aCB0aGUgYW5jaG9yIGFuZCBmb2N1cyBtaWdodCBiZSBtb3ZlZCB0byBlbnN1cmUgYSByZWN0YW5nbGVcbiAgLy8gZ2l2ZW4gYSBwb3RlbnRpYWxseSByYWdnZWQgbWVyZ2Ugc2hhcGVcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyKHJlY3QsIGFuY2hvckNlbGxWYWx1ZSk7XG4gIGlmIChhbmNob3JDb3JuZXIpIHtcbiAgICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIGFuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcikpXTtcbiAgfVxuICBjb25zdCBuZXdGb2N1c0Nvcm5lciA9IGdldENvcm5lcihyZWN0LCBuZXdGb2N1c0NlbGxWYWx1ZSk7XG4gIGlmIChuZXdGb2N1c0Nvcm5lcikge1xuICAgIHJldHVybiBbY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgb3Bwb3NpdGVDb3JuZXIobmV3Rm9jdXNDb3JuZXIpKSwgY2VsbEF0Q29ybmVyT3JUaHJvdyh0YWJsZU1hcCwgcmVjdCwgbmV3Rm9jdXNDb3JuZXIpXTtcbiAgfVxuICAvLyBUT0RPIHRoaXMgZG9lc24ndCBoYXZlIHRvIGJlIGFyYml0cmFyeSwgdXNlIHRoZSBjbG9zZXN0IGNvcm5lciBpbnN0ZWFkXG4gIGNvbnN0IG5ld0FuY2hvckNvcm5lciA9IFsnbWluQ29sdW1uJywgJ21pblJvdyddO1xuICByZXR1cm4gW2NlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG5ld0FuY2hvckNvcm5lciksIGNlbGxBdENvcm5lck9yVGhyb3codGFibGVNYXAsIHJlY3QsIG9wcG9zaXRlQ29ybmVyKG5ld0FuY2hvckNvcm5lcikpXTtcbn1cbmZ1bmN0aW9uICRhZGp1c3RGb2N1c0luRGlyZWN0aW9uKHRhYmxlT2JzZXJ2ZXIsIHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgY29uc3QgcmVjdCA9ICRjb21wdXRlVGFibGVDZWxsUmVjdEJvdW5kYXJ5KHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIGZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3Qgc3BhbnMgPSAkY29tcHV0ZVRhYmxlQ2VsbFJlY3RTcGFucyh0YWJsZU1hcCwgcmVjdCk7XG4gIGNvbnN0IHtcbiAgICB0b3BTcGFuLFxuICAgIGxlZnRTcGFuLFxuICAgIGJvdHRvbVNwYW4sXG4gICAgcmlnaHRTcGFuXG4gIH0gPSBzcGFucztcbiAgY29uc3QgYW5jaG9yQ29ybmVyID0gZ2V0Q29ybmVyT3JUaHJvdyhyZWN0LCBhbmNob3JDZWxsVmFsdWUpO1xuICBjb25zdCBbZm9jdXNDb2x1bW4sIGZvY3VzUm93XSA9IG9wcG9zaXRlQ29ybmVyKGFuY2hvckNvcm5lcik7XG4gIGxldCBmQ29sID0gcmVjdFtmb2N1c0NvbHVtbl07XG4gIGxldCBmUm93ID0gcmVjdFtmb2N1c1Jvd107XG4gIGlmIChkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgIGZDb2wgKz0gZm9jdXNDb2x1bW4gPT09ICdtYXhDb2x1bW4nID8gMSA6IGxlZnRTcGFuO1xuICB9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJykge1xuICAgIGZDb2wgLT0gZm9jdXNDb2x1bW4gPT09ICdtaW5Db2x1bW4nID8gMSA6IHJpZ2h0U3BhbjtcbiAgfSBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJykge1xuICAgIGZSb3cgKz0gZm9jdXNSb3cgPT09ICdtYXhSb3cnID8gMSA6IHRvcFNwYW47XG4gIH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgZlJvdyAtPSBmb2N1c1JvdyA9PT0gJ21pblJvdycgPyAxIDogYm90dG9tU3BhbjtcbiAgfVxuICBjb25zdCB0YXJnZXRSb3dNYXAgPSB0YWJsZU1hcFtmUm93XTtcbiAgaWYgKHRhcmdldFJvd01hcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IG5ld0ZvY3VzQ2VsbFZhbHVlID0gdGFyZ2V0Um93TWFwW2ZDb2xdO1xuICBpZiAobmV3Rm9jdXNDZWxsVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBXZSBjYW4gYmUgY2VydGFpbiB0aGF0IGFuY2hvckNlbGxWYWx1ZSBhbmQgbmV3Rm9jdXNDZWxsVmFsdWUgYXJlXG4gIC8vIGNvbnRhaW5lZCB3aXRoaW4gdGhlIGRlc2lyZWQgc2VsZWN0aW9uLCBidXQgd2UgYXJlIG5vdCBjZXJ0YWluIGlmXG4gIC8vIHRoZXkgbmVlZCB0byBiZSBleHBhbmRlZCBvciBub3QgdG8gbWFpbnRhaW4gYSByZWN0YW5ndWxhciBzaGFwZVxuICBjb25zdCBbZmluYWxBbmNob3JDZWxsLCBmaW5hbEZvY3VzQ2VsbF0gPSAkZXh0cmFjdFJlY3RDb3JuZXJzKHRhYmxlTWFwLCBhbmNob3JDZWxsVmFsdWUsIG5ld0ZvY3VzQ2VsbFZhbHVlKTtcbiAgY29uc3QgYW5jaG9yRE9NID0gJGdldE9ic2VydmVyQ2VsbEZyb21DZWxsTm9kZU9yVGhyb3codGFibGVPYnNlcnZlciwgZmluYWxBbmNob3JDZWxsLmNlbGwpO1xuICBjb25zdCBmb2N1c0RPTSA9ICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIGZpbmFsRm9jdXNDZWxsLmNlbGwpO1xuICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTSk7XG4gIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTSwgdHJ1ZSk7XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJGlzU2VsZWN0aW9uSW5UYWJsZShzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSB8fCAkaXNUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgLy8gVE9ETyB0aGlzIHNob3VsZCBwcm9iYWJseSByZXR1cm4gZmFsc2UgaWYgdGhlcmUncyBhbiB1bnJlbGF0ZWRcbiAgICAvLyAgICAgIHNoYWRvdyByb290IGJldHdlZW4gdGhlIG5vZGUgYW5kIHRoZSB0YWJsZSAoZS5nLiBhbm90aGVyIHRhYmxlLFxuICAgIC8vICAgICAgY29sbGFwc2libGUsIGV0Yy4pXG4gICAgY29uc3QgaXNBbmNob3JJbnNpZGUgPSB0YWJsZU5vZGUuaXNQYXJlbnRPZihzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSk7XG4gICAgY29uc3QgaXNGb2N1c0luc2lkZSA9IHRhYmxlTm9kZS5pc1BhcmVudE9mKHNlbGVjdGlvbi5mb2N1cy5nZXROb2RlKCkpO1xuICAgIHJldHVybiBpc0FuY2hvckluc2lkZSAmJiBpc0ZvY3VzSW5zaWRlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uICRpc0Z1bGxUYWJsZVNlbGVjdGlvbihzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBpZiAoJGlzVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIGlmICh0YWJsZU5vZGUgJiYgYW5jaG9yTm9kZSAmJiBmb2N1c05vZGUpIHtcbiAgICAgIGNvbnN0IFttYXBdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvck5vZGUsIGZvY3VzTm9kZSk7XG4gICAgICByZXR1cm4gYW5jaG9yTm9kZS5nZXRLZXkoKSA9PT0gbWFwWzBdWzBdLmNlbGwuZ2V0S2V5KCkgJiYgZm9jdXNOb2RlLmdldEtleSgpID09PSBtYXBbbWFwLmxlbmd0aCAtIDFdLmF0KC0xKS5jZWxsLmdldEtleSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RUYWJsZUNlbGxOb2RlKHRhYmxlQ2VsbCwgZnJvbVN0YXJ0KSB7XG4gIGlmIChmcm9tU3RhcnQpIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0U3RhcnQoKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZUNlbGwuc2VsZWN0RW5kKCk7XG4gIH1cbn1cbmZ1bmN0aW9uICRhZGRIaWdobGlnaHRUb0RPTShlZGl0b3IsIGNlbGwpIHtcbiAgY29uc3QgZWxlbWVudCA9IGNlbGwuZWxlbTtcbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJHJlbW92ZUhpZ2hsaWdodEZyb21ET00oZWRpdG9yLCBjZWxsKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBjZWxsLmVsZW07XG4gIGNvbnN0IG5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShlbGVtZW50KTtcbiAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKG5vZGUpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCB0byBmaW5kIExleGljYWxOb2RlIGZyb20gVGFibGUgQ2VsbCBET01Ob2RlYCk7XG4gIH1cbiAgY29uc3QgZWRpdG9yVGhlbWVDbGFzc2VzID0gZWRpdG9yLl9jb25maWcudGhlbWU7XG4gIHJlbW92ZUNsYXNzTmFtZXNGcm9tRWxlbWVudChlbGVtZW50LCBlZGl0b3JUaGVtZUNsYXNzZXMudGFibGVDZWxsU2VsZWN0ZWQpO1xufVxuZnVuY3Rpb24gJGZpbmRDZWxsTm9kZShub2RlKSB7XG4gIGNvbnN0IGNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgcmV0dXJuICRpc1RhYmxlQ2VsbE5vZGUoY2VsbE5vZGUpID8gY2VsbE5vZGUgOiBudWxsO1xufVxuZnVuY3Rpb24gJGZpbmRUYWJsZU5vZGUobm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsICRpc1RhYmxlTm9kZSk7XG4gIHJldHVybiAkaXNUYWJsZU5vZGUodGFibGVOb2RlKSA/IHRhYmxlTm9kZSA6IG51bGw7XG59XG5mdW5jdGlvbiAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShub2RlKSB7XG4gIGZvciAobGV0IHByZXZOb2RlID0gbm9kZSwgY3VycmVudE5vZGUgPSBub2RlOyBjdXJyZW50Tm9kZSAhPT0gbnVsbDsgcHJldk5vZGUgPSBjdXJyZW50Tm9kZSwgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5nZXRQYXJlbnQoKSkge1xuICAgIGlmICgkaXNFbGVtZW50Tm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGlmIChjdXJyZW50Tm9kZSAhPT0gcHJldk5vZGUgJiYgY3VycmVudE5vZGUuZ2V0Rmlyc3RDaGlsZCgpICE9PSBwcmV2Tm9kZSkge1xuICAgICAgICAvLyBOb3QgdGhlIGZpcnN0IGNoaWxkIG9yIHRoZSBpbml0aWFsIG5vZGVcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCFjdXJyZW50Tm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiAkaGFuZGxlSG9yaXpvbnRhbEFycm93S2V5UmFuZ2VTZWxlY3Rpb24oZWRpdG9yLCBldmVudCwgc2VsZWN0aW9uLCBhbHRlciwgaXNCYWNrd2FyZCwgdGFibGVOb2RlLCB0YWJsZU9ic2VydmVyKSB7XG4gIGNvbnN0IGluaXRpYWxGb2N1cyA9ICRjYXJldEZyb21Qb2ludChzZWxlY3Rpb24uZm9jdXMsIGlzQmFja3dhcmQgPyAncHJldmlvdXMnIDogJ25leHQnKTtcbiAgaWYgKCRpc0V4dGVuZGFibGVUZXh0UG9pbnRDYXJldChpbml0aWFsRm9jdXMpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxldCBsYXN0Q2FyZXQgPSBpbml0aWFsRm9jdXM7XG4gIC8vIFRhYmxlQ2VsbE5vZGUgaXMgdGhlIG9ubHkgc2hhZG93IHJvb3Qgd2UgYXJlIGludGVyZXN0ZWQgaW4gcGllcmNpbmcgc29cbiAgLy8gd2UgZmluZCB0aGUgbGFzdCBpbnRlcm5hbCBjYXJldCBhbmQgdGhlbiBjaGVjayBpdHMgcGFyZW50XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbEZvY3VzKS5pdGVyTm9kZUNhcmV0cygnc2hhZG93Um9vdCcpKSB7XG4gICAgaWYgKCEoJGlzU2libGluZ0NhcmV0KG5leHRDYXJldCkgJiYgJGlzRWxlbWVudE5vZGUobmV4dENhcmV0Lm9yaWdpbikpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxhc3RDYXJldCA9IG5leHRDYXJldDtcbiAgfVxuICBjb25zdCBsYXN0Q2FyZXRQYXJlbnQgPSBsYXN0Q2FyZXQuZ2V0UGFyZW50QXRDYXJldCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUobGFzdENhcmV0UGFyZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBhbmNob3JDZWxsID0gbGFzdENhcmV0UGFyZW50O1xuICBjb25zdCBmb2N1c0NhcmV0ID0gJGZpbmROZXh0VGFibGVDZWxsKCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbCwgbGFzdENhcmV0LmRpcmVjdGlvbikpO1xuICBjb25zdCBhbmNob3JDZWxsVGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGwsICRpc1RhYmxlTm9kZSk7XG4gIGlmICghKGFuY2hvckNlbGxUYWJsZSAmJiBhbmNob3JDZWxsVGFibGUuaXModGFibGVOb2RlKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYW5jaG9yQ2VsbERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoYW5jaG9yQ2VsbC5nZXRLZXkoKSk7XG4gIGNvbnN0IGFuY2hvckRPTUNlbGwgPSBnZXRET01DZWxsRnJvbVRhcmdldChhbmNob3JDZWxsRE9NKTtcbiAgaWYgKCFhbmNob3JDZWxsRE9NIHx8ICFhbmNob3JET01DZWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgPSAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZShlZGl0b3IsIGFuY2hvckNlbGxUYWJsZSk7XG4gIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBhbmNob3JDZWxsVGFibGVFbGVtZW50O1xuICBpZiAoIWZvY3VzQ2FyZXQpIHtcbiAgICBpZiAoYWx0ZXIgPT09ICdleHRlbmQnKSB7XG4gICAgICAvLyBleHRlbmQgdGhlIHNlbGVjdGlvbiBmcm9tIGEgcmFuZ2UgaW5zaWRlIHRoZSBjZWxsIHRvIGEgdGFibGUgc2VsZWN0aW9uIG9mIHRoZSBjZWxsXG4gICAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGl0IHRoZSB0YWJsZVxuICAgICAgY29uc3Qgb3V0ZXJGb2N1c0NhcmV0ID0gJGdldFRhYmxlRXhpdENhcmV0KCRnZXRTaWJsaW5nQ2FyZXQoYW5jaG9yQ2VsbFRhYmxlLCBpbml0aWFsRm9jdXMuZGlyZWN0aW9uKSk7XG4gICAgICAkc2V0UG9pbnRGcm9tQ2FyZXQoc2VsZWN0aW9uLmFuY2hvciwgb3V0ZXJGb2N1c0NhcmV0KTtcbiAgICAgICRzZXRQb2ludEZyb21DYXJldChzZWxlY3Rpb24uZm9jdXMsIG91dGVyRm9jdXNDYXJldCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGFsdGVyID09PSAnZXh0ZW5kJykge1xuICAgIGNvbnN0IGZvY3VzRE9NQ2VsbCA9IGdldERPTUNlbGxGcm9tVGFyZ2V0KGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZm9jdXNDYXJldC5vcmlnaW4uZ2V0S2V5KCkpKTtcbiAgICBpZiAoIWZvY3VzRE9NQ2VsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckRPTUNlbGwpO1xuICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEZvY3VzQ2VsbEZvclNlbGVjdGlvbihmb2N1c0RPTUNlbGwsIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsdGVyID09PSAnbW92ZSdcbiAgICBjb25zdCBpbm5lckZvY3VzQ2FyZXQgPSAkbm9ybWFsaXplQ2FyZXQoZm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5hbmNob3IsIGlubmVyRm9jdXNDYXJldCk7XG4gICAgJHNldFBvaW50RnJvbUNhcmV0KHNlbGVjdGlvbi5mb2N1cywgaW5uZXJGb2N1c0NhcmV0KTtcbiAgfVxuICBzdG9wRXZlbnQoZXZlbnQpO1xuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uICRnZXRUYWJsZUV4aXRDYXJldChpbml0aWFsQ2FyZXQpIHtcbiAgY29uc3QgYWRqYWNlbnQgPSAkZ2V0QWRqYWNlbnRDaGlsZENhcmV0KGluaXRpYWxDYXJldCk7XG4gIHJldHVybiAkaXNDaGlsZENhcmV0KGFkamFjZW50KSA/ICRub3JtYWxpemVDYXJldChhZGphY2VudCkgOiBpbml0aWFsQ2FyZXQ7XG59XG5mdW5jdGlvbiAkZmluZE5leHRUYWJsZUNlbGwoaW5pdGlhbENhcmV0KSB7XG4gIGZvciAoY29uc3QgbmV4dENhcmV0IG9mICRleHRlbmRDYXJldFRvUmFuZ2UoaW5pdGlhbENhcmV0KS5pdGVyTm9kZUNhcmV0cygncm9vdCcpKSB7XG4gICAgY29uc3Qge1xuICAgICAgb3JpZ2luXG4gICAgfSA9IG5leHRDYXJldDtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShvcmlnaW4pKSB7XG4gICAgICAvLyBub3Qgc3VyZSB3aHkgdHMgaXNuJ3QgbmFycm93aW5nIGhlcmUgKGV2ZW4gaWYgdGhlIGd1YXJkIGlzIG9uIG5leHRDYXJldC5vcmlnaW4pXG4gICAgICAvLyBidXQgcmV0dXJuaW5nIGEgbmV3IGNhcmV0IGlzIGZpbmVcbiAgICAgIGlmICgkaXNDaGlsZENhcmV0KG5leHRDYXJldCkpIHtcbiAgICAgICAgcmV0dXJuICRnZXRDaGlsZENhcmV0KG9yaWdpbiwgaW5pdGlhbENhcmV0LmRpcmVjdGlvbik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghJGlzVGFibGVSb3dOb2RlKG9yaWdpbikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uICRoYW5kbGVBcnJvd0tleShlZGl0b3IsIGV2ZW50LCBkaXJlY3Rpb24sIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcikge1xuICBpZiAoKGRpcmVjdGlvbiA9PT0gJ3VwJyB8fCBkaXJlY3Rpb24gPT09ICdkb3duJykgJiYgaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoISRpc1NlbGVjdGlvbkluVGFibGUoc2VsZWN0aW9uLCB0YWJsZU5vZGUpKSB7XG4gICAgaWYgKCRpc1JhbmdlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcpIHtcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5mb2N1cy5vZmZzZXQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudE5vZGUgPSAkZ2V0QmxvY2tQYXJlbnRJZkZpcnN0Tm9kZShzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpKTtcbiAgICAgICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpYmxpbmdOb2RlID0gcGFyZW50Tm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICAgICAgaWYgKCEkaXNUYWJsZU5vZGUoc2libGluZ05vZGUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgICAgIHNlbGVjdGlvbi5mb2N1cy5zZXQoc2libGluZ05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmdldEtleSgpLCBzaWJsaW5nTm9kZS5nZXRJbmRleFdpdGhpblBhcmVudCgpLCAnZWxlbWVudCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpYmxpbmdOb2RlLnNlbGVjdEVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChldmVudC5zaGlmdEtleSAmJiAoZGlyZWN0aW9uID09PSAndXAnIHx8IGRpcmVjdGlvbiA9PT0gJ2Rvd24nKSkge1xuICAgICAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgICAgICBjb25zdCBpc1RhYmxlVW5zZWxlY3QgPSAhc2VsZWN0aW9uLmlzQ29sbGFwc2VkKCkgJiYgKGRpcmVjdGlvbiA9PT0gJ3VwJyAmJiAhc2VsZWN0aW9uLmlzQmFja3dhcmQoKSB8fCBkaXJlY3Rpb24gPT09ICdkb3duJyAmJiBzZWxlY3Rpb24uaXNCYWNrd2FyZCgpKTtcbiAgICAgICAgaWYgKGlzVGFibGVVbnNlbGVjdCkge1xuICAgICAgICAgIGxldCBmb2N1c1BhcmVudE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzTm9kZSwgbiA9PiAkaXNUYWJsZU5vZGUobikpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGZvY3VzUGFyZW50Tm9kZSkpIHtcbiAgICAgICAgICAgIGZvY3VzUGFyZW50Tm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXNQYXJlbnROb2RlLCAkaXNUYWJsZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZm9jdXNQYXJlbnROb2RlICE9PSB0YWJsZU5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmb2N1c1BhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qgc2libGluZyA9IGRpcmVjdGlvbiA9PT0gJ2Rvd24nID8gZm9jdXNQYXJlbnROb2RlLmdldE5leHRTaWJsaW5nKCkgOiBmb2N1c1BhcmVudE5vZGUuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG4gICAgICAgICAgaWYgKCFzaWJsaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBuZXdPZmZzZXQgPSAwO1xuICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICd1cCcpIHtcbiAgICAgICAgICAgIGlmICgkaXNFbGVtZW50Tm9kZShzaWJsaW5nKSkge1xuICAgICAgICAgICAgICBuZXdPZmZzZXQgPSBzaWJsaW5nLmdldENoaWxkcmVuU2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgbmV3Rm9jdXNOb2RlID0gc2libGluZztcbiAgICAgICAgICBpZiAoZGlyZWN0aW9uID09PSAndXAnKSB7XG4gICAgICAgICAgICBpZiAoJGlzRWxlbWVudE5vZGUoc2libGluZykpIHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGwgPSBzaWJsaW5nLmdldExhc3RDaGlsZCgpO1xuICAgICAgICAgICAgICBuZXdGb2N1c05vZGUgPSBsYXN0Q2VsbCA/IGxhc3RDZWxsIDogc2libGluZztcbiAgICAgICAgICAgICAgbmV3T2Zmc2V0ID0gJGlzVGV4dE5vZGUobmV3Rm9jdXNOb2RlKSA/IG5ld0ZvY3VzTm9kZS5nZXRUZXh0Q29udGVudFNpemUoKSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgIG5ld1NlbGVjdGlvbi5mb2N1cy5zZXQobmV3Rm9jdXNOb2RlLmdldEtleSgpLCBuZXdPZmZzZXQsICRpc1RleHROb2RlKG5ld0ZvY3VzTm9kZSkgPyAndGV4dCcgOiAnZWxlbWVudCcpO1xuICAgICAgICAgICRzZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCRpc1Jvb3RPclNoYWRvd1Jvb3QoZm9jdXNOb2RlKSkge1xuICAgICAgICAgIGNvbnN0IHNlbGVjdGVkTm9kZSA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IHNlbGVjdGlvbi5nZXROb2RlcygpW3NlbGVjdGlvbi5nZXROb2RlcygpLmxlbmd0aCAtIDFdIDogc2VsZWN0aW9uLmdldE5vZGVzKClbMF07XG4gICAgICAgICAgaWYgKHNlbGVjdGVkTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGFibGVDZWxsTm9kZSA9ICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCBzZWxlY3RlZE5vZGUpO1xuICAgICAgICAgICAgaWYgKHRhYmxlQ2VsbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3REZXNjZW5kYW50ID0gdGFibGVOb2RlLmdldEZpcnN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHRhYmxlTm9kZS5nZXRMYXN0RGVzY2VuZGFudCgpO1xuICAgICAgICAgICAgICBpZiAoIWZpcnN0RGVzY2VuZGFudCB8fCAhbGFzdERlc2NlbmRhbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgW2ZpcnN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGZpcnN0RGVzY2VuZGFudCk7XG4gICAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RDZWxsQ29vcmRzID0gdGFibGVOb2RlLmdldENvcmRzRnJvbUNlbGxOb2RlKGZpcnN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBsYXN0Q2VsbENvb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShsYXN0Q2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgICAgICBjb25zdCBmaXJzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3coZmlyc3RDZWxsQ29vcmRzLngsIGZpcnN0Q2VsbENvb3Jkcy55LCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdENlbGxET00gPSB0YWJsZU5vZGUuZ2V0RE9NQ2VsbEZyb21Db3Jkc09yVGhyb3cobGFzdENlbGxDb29yZHMueCwgbGFzdENlbGxDb29yZHMueSwgdGFibGVPYnNlcnZlci50YWJsZSk7XG4gICAgICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oZmlyc3RDZWxsRE9NKTtcbiAgICAgICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGxhc3RDZWxsRE9NLCB0cnVlKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXQgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c05vZGUsIG4gPT4gJGlzRWxlbWVudE5vZGUobikgJiYgIW4uaXNJbmxpbmUoKSk7XG4gICAgICAgICAgaWYgKCRpc1RhYmxlQ2VsbE5vZGUoZm9jdXNQYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgZm9jdXNQYXJlbnROb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChmb2N1c1BhcmVudE5vZGUsICRpc1RhYmxlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm9jdXNQYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHNpYmxpbmcgPSBkaXJlY3Rpb24gPT09ICdkb3duJyA/IGZvY3VzUGFyZW50Tm9kZS5nZXROZXh0U2libGluZygpIDogZm9jdXNQYXJlbnROb2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgICAgIGlmICgkaXNUYWJsZU5vZGUoc2libGluZykgJiYgdGFibGVPYnNlcnZlci50YWJsZU5vZGVLZXkgPT09IHNpYmxpbmcuZ2V0S2V5KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RGVzY2VuZGFudCA9IHNpYmxpbmcuZ2V0TGFzdERlc2NlbmRhbnQoKTtcbiAgICAgICAgICAgIGlmICghZmlyc3REZXNjZW5kYW50IHx8ICFsYXN0RGVzY2VuZGFudCkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbZmlyc3RDZWxsTm9kZV0gPSAkZ2V0Tm9kZVRyaXBsZXQoZmlyc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IFtsYXN0Q2VsbE5vZGVdID0gJGdldE5vZGVUcmlwbGV0KGxhc3REZXNjZW5kYW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICAgICAgbmV3U2VsZWN0aW9uLmZvY3VzLnNldCgoZGlyZWN0aW9uID09PSAndXAnID8gZmlyc3RDZWxsTm9kZSA6IGxhc3RDZWxsTm9kZSkuZ2V0S2V5KCksIGRpcmVjdGlvbiA9PT0gJ3VwJyA/IDAgOiBsYXN0Q2VsbE5vZGUuZ2V0Q2hpbGRyZW5TaXplKCksICdlbGVtZW50Jyk7XG4gICAgICAgICAgICBzdG9wRXZlbnQoZXZlbnQpO1xuICAgICAgICAgICAgJHNldFNlbGVjdGlvbihuZXdTZWxlY3Rpb24pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gPT09ICdkb3duJyAmJiAkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIC8vIEVuYWJsZSBGaXJlZm94IHdvcmthcm91bmRcbiAgICAgIHRhYmxlT2JzZXJ2ZXIuc2V0U2hvdWxkQ2hlY2tTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJyB8fCBkaXJlY3Rpb24gPT09ICdmb3J3YXJkJykge1xuICAgICAgY29uc3QgYWx0ZXIgPSBldmVudC5zaGlmdEtleSA/ICdleHRlbmQnIDogJ21vdmUnO1xuICAgICAgcmV0dXJuICRoYW5kbGVIb3Jpem9udGFsQXJyb3dLZXlSYW5nZVNlbGVjdGlvbihlZGl0b3IsIGV2ZW50LCBzZWxlY3Rpb24sIGFsdGVyLCBkaXJlY3Rpb24gPT09ICdiYWNrd2FyZCcsIHRhYmxlTm9kZSwgdGFibGVPYnNlcnZlcik7XG4gICAgfVxuICAgIGlmIChzZWxlY3Rpb24uaXNDb2xsYXBzZWQoKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbmNob3IsXG4gICAgICAgIGZvY3VzXG4gICAgICB9ID0gc2VsZWN0aW9uO1xuICAgICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgICAgY29uc3QgZm9jdXNDZWxsTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoZm9jdXMuZ2V0Tm9kZSgpLCAkaXNUYWJsZUNlbGxOb2RlKTtcbiAgICAgIGlmICghJGlzVGFibGVDZWxsTm9kZShhbmNob3JDZWxsTm9kZSkgfHwgIWFuY2hvckNlbGxOb2RlLmlzKGZvY3VzQ2VsbE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFuY2hvckNlbGxUYWJsZSA9ICRmaW5kVGFibGVOb2RlKGFuY2hvckNlbGxOb2RlKTtcbiAgICAgIGlmIChhbmNob3JDZWxsVGFibGUgIT09IHRhYmxlTm9kZSAmJiBhbmNob3JDZWxsVGFibGUgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCBhbmNob3JDZWxsVGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KGFuY2hvckNlbGxUYWJsZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsVGFibGUuZ2V0S2V5KCkpKTtcbiAgICAgICAgaWYgKGFuY2hvckNlbGxUYWJsZUVsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIudGFibGUgPSBnZXRUYWJsZShhbmNob3JDZWxsVGFibGUsIGFuY2hvckNlbGxUYWJsZUVsZW1lbnQpO1xuICAgICAgICAgIHJldHVybiAkaGFuZGxlQXJyb3dLZXkoZWRpdG9yLCBldmVudCwgZGlyZWN0aW9uLCBhbmNob3JDZWxsVGFibGUsIHRhYmxlT2JzZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBhbmNob3JDZWxsRG9tID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleShhbmNob3JDZWxsTm9kZS5fX2tleSk7XG4gICAgICBjb25zdCBhbmNob3JET00gPSBlZGl0b3IuZ2V0RWxlbWVudEJ5S2V5KGFuY2hvci5rZXkpO1xuICAgICAgaWYgKGFuY2hvckRPTSA9PSBudWxsIHx8IGFuY2hvckNlbGxEb20gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBsZXQgZWRnZVNlbGVjdGlvblJlY3Q7XG4gICAgICBpZiAoYW5jaG9yLnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgICAgICBlZGdlU2VsZWN0aW9uUmVjdCA9IGFuY2hvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gICAgICAgIGlmIChkb21TZWxlY3Rpb24gPT09IG51bGwgfHwgZG9tU2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBkb21TZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgZWRnZVNlbGVjdGlvblJlY3QgPSByYW5nZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZCA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGFuY2hvckNlbGxOb2RlLmdldEZpcnN0Q2hpbGQoKSA6IGFuY2hvckNlbGxOb2RlLmdldExhc3RDaGlsZCgpO1xuICAgICAgaWYgKGVkZ2VDaGlsZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVkZ2VDaGlsZERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkoZWRnZUNoaWxkLl9fa2V5KTtcbiAgICAgIGlmIChlZGdlQ2hpbGRET00gPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCBlZGdlUmVjdCA9IGVkZ2VDaGlsZERPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGNvbnN0IGlzRXhpdGluZyA9IGRpcmVjdGlvbiA9PT0gJ3VwJyA/IGVkZ2VSZWN0LnRvcCA+IGVkZ2VTZWxlY3Rpb25SZWN0LnRvcCAtIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA6IGVkZ2VTZWxlY3Rpb25SZWN0LmJvdHRvbSArIGVkZ2VTZWxlY3Rpb25SZWN0LmhlaWdodCA+IGVkZ2VSZWN0LmJvdHRvbTtcbiAgICAgIGlmIChpc0V4aXRpbmcpIHtcbiAgICAgICAgc3RvcEV2ZW50KGV2ZW50KTtcbiAgICAgICAgY29uc3QgY29yZHMgPSB0YWJsZU5vZGUuZ2V0Q29yZHNGcm9tQ2VsbE5vZGUoYW5jaG9yQ2VsbE5vZGUsIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICBjb25zdCBjZWxsID0gdGFibGVOb2RlLmdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KGNvcmRzLngsIGNvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xuICAgICAgICAgIHRhYmxlT2JzZXJ2ZXIuJHNldEFuY2hvckNlbGxGb3JTZWxlY3Rpb24oY2VsbCk7XG4gICAgICAgICAgdGFibGVPYnNlcnZlci4kc2V0Rm9jdXNDZWxsRm9yU2VsZWN0aW9uKGNlbGwsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzZWxlY3RUYWJsZU5vZGVJbkRpcmVjdGlvbih0YWJsZU9ic2VydmVyLCB0YWJsZU5vZGUsIGNvcmRzLngsIGNvcmRzLnksIGRpcmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKCRpc1RhYmxlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICBjb25zdCB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgYW5jaG9yQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvci5nZXROb2RlKCksICRpc1RhYmxlQ2VsbE5vZGUpO1xuICAgIGNvbnN0IGZvY3VzQ2VsbE5vZGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGZvY3VzLmdldE5vZGUoKSwgJGlzVGFibGVDZWxsTm9kZSk7XG4gICAgY29uc3QgW3RhYmxlTm9kZUZyb21TZWxlY3Rpb25dID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKCEkaXNUYWJsZU5vZGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbikpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgJGhhbmRsZUFycm93S2V5OiBUYWJsZVNlbGVjdGlvbi5nZXROb2RlcygpWzBdIGV4cGVjdGVkIHRvIGJlIFRhYmxlTm9kZWApO1xuICAgIH1cbiAgICBjb25zdCB0YWJsZUVsZW1lbnQgPSBnZXRUYWJsZUVsZW1lbnQodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGVGcm9tU2VsZWN0aW9uLmdldEtleSgpKSk7XG4gICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGFuY2hvckNlbGxOb2RlKSB8fCAhJGlzVGFibGVDZWxsTm9kZShmb2N1c0NlbGxOb2RlKSB8fCAhJGlzVGFibGVOb2RlKHRhYmxlTm9kZUZyb21TZWxlY3Rpb24pIHx8IHRhYmxlRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRhYmxlT2JzZXJ2ZXIuJHVwZGF0ZVRhYmxlVGFibGVTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICBjb25zdCBncmlkID0gZ2V0VGFibGUodGFibGVOb2RlRnJvbVNlbGVjdGlvbiwgdGFibGVFbGVtZW50KTtcbiAgICBjb25zdCBjb3Jkc0FuY2hvciA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZShhbmNob3JDZWxsTm9kZSwgZ3JpZCk7XG4gICAgY29uc3QgYW5jaG9yQ2VsbCA9IHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjb3Jkc0FuY2hvci54LCBjb3Jkc0FuY2hvci55LCBncmlkKTtcbiAgICB0YWJsZU9ic2VydmVyLiRzZXRBbmNob3JDZWxsRm9yU2VsZWN0aW9uKGFuY2hvckNlbGwpO1xuICAgIHN0b3BFdmVudChldmVudCk7XG4gICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICBjb25zdCBbdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlXSA9ICRjb21wdXRlVGFibGVNYXAodGFibGVOb2RlLCBhbmNob3JDZWxsTm9kZSwgZm9jdXNDZWxsTm9kZSk7XG4gICAgICByZXR1cm4gJGFkanVzdEZvY3VzSW5EaXJlY3Rpb24odGFibGVPYnNlcnZlciwgdGFibGVNYXAsIGFuY2hvclZhbHVlLCBmb2N1c1ZhbHVlLCBkaXJlY3Rpb24pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb2N1c0NlbGxOb2RlLnNlbGVjdEVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xufVxuZnVuY3Rpb24gaXNUeXBlYWhlYWRNZW51SW5WaWV3KGVkaXRvcikge1xuICAvLyBUaGVyZSBpcyBubyBpbmJ1aWx0IHdheSB0byBjaGVjayBpZiB0aGUgY29tcG9uZW50IHBpY2tlciBpcyBpbiB2aWV3XG4gIC8vIGJ1dCB3ZSBjYW4gY2hlY2sgaWYgdGhlIHJvb3QgRE9NIGVsZW1lbnQgaGFzIHRoZSBhcmlhLWNvbnRyb2xzIGF0dHJpYnV0ZSBcInR5cGVhaGVhZC1tZW51XCIuXG4gIGNvbnN0IHJvb3QgPSBlZGl0b3IuZ2V0Um9vdEVsZW1lbnQoKTtcbiAgaWYgKCFyb290KSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiByb290Lmhhc0F0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpICYmIHJvb3QuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykgPT09ICd0eXBlYWhlYWQtbWVudSc7XG59XG5mdW5jdGlvbiAkaW5zZXJ0UGFyYWdyYXBoQXRUYWJsZUVkZ2UoZWRnZVBvc2l0aW9uLCB0YWJsZU5vZGUsIGNoaWxkcmVuKSB7XG4gIGNvbnN0IHBhcmFncmFwaE5vZGUgPSAkY3JlYXRlUGFyYWdyYXBoTm9kZSgpO1xuICBpZiAoZWRnZVBvc2l0aW9uID09PSAnZmlyc3QnKSB7XG4gICAgdGFibGVOb2RlLmluc2VydEJlZm9yZShwYXJhZ3JhcGhOb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB0YWJsZU5vZGUuaW5zZXJ0QWZ0ZXIocGFyYWdyYXBoTm9kZSk7XG4gIH1cbiAgcGFyYWdyYXBoTm9kZS5hcHBlbmQoLi4uKGNoaWxkcmVuIHx8IFtdKSk7XG4gIHBhcmFncmFwaE5vZGUuc2VsZWN0RW5kKCk7XG59XG5mdW5jdGlvbiAkZ2V0VGFibGVFZGdlQ3Vyc29yUG9zaXRpb24oZWRpdG9yLCBzZWxlY3Rpb24sIHRhYmxlTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGVQYXJlbnQgPSB0YWJsZU5vZGUuZ2V0UGFyZW50KCk7XG4gIGlmICghdGFibGVOb2RlUGFyZW50KSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8vIFRPRE86IEFkZCBzdXBwb3J0IGZvciBuZXN0ZWQgdGFibGVzXG4gIGNvbnN0IGRvbVNlbGVjdGlvbiA9IGdldERPTVNlbGVjdGlvbihnZXRFZGl0b3JXaW5kb3coZWRpdG9yKSk7XG4gIGlmICghZG9tU2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBjb25zdCBkb21BbmNob3JOb2RlID0gZG9tU2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIGNvbnN0IHRhYmxlTm9kZVBhcmVudERPTSA9IGVkaXRvci5nZXRFbGVtZW50QnlLZXkodGFibGVOb2RlUGFyZW50LmdldEtleSgpKTtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZ2V0VGFibGVFbGVtZW50KHRhYmxlTm9kZSwgZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpKTtcbiAgLy8gV2UgYXJlIG9ubHkgaW50ZXJlc3RlZCBpbiB0aGUgc2NlbmFyaW8gd2hlcmUgdGhlXG4gIC8vIG5hdGl2ZSBzZWxlY3Rpb24gYW5jaG9yIGlzOlxuICAvLyAtIGF0IG9yIGluc2lkZSB0aGUgdGFibGUncyBwYXJlbnQgRE9NXG4gIC8vIC0gYW5kIE5PVCBhdCBvciBpbnNpZGUgdGhlIHRhYmxlIERPTVxuICAvLyBJdCBtYXkgYmUgYWRqYWNlbnQgdG8gdGhlIHRhYmxlIERPTSAoZS5nLiBpbiBhIHdyYXBwZXIpXG4gIGlmICghZG9tQW5jaG9yTm9kZSB8fCAhdGFibGVOb2RlUGFyZW50RE9NIHx8ICF0YWJsZUVsZW1lbnQgfHwgIXRhYmxlTm9kZVBhcmVudERPTS5jb250YWlucyhkb21BbmNob3JOb2RlKSB8fCB0YWJsZUVsZW1lbnQuY29udGFpbnMoZG9tQW5jaG9yTm9kZSkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGNvbnN0IGFuY2hvckNlbGxOb2RlID0gJGZpbmRNYXRjaGluZ1BhcmVudChzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSwgbiA9PiAkaXNUYWJsZUNlbGxOb2RlKG4pKTtcbiAgaWYgKCFhbmNob3JDZWxsTm9kZSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgcGFyZW50VGFibGUgPSAkZmluZE1hdGNoaW5nUGFyZW50KGFuY2hvckNlbGxOb2RlLCBuID0+ICRpc1RhYmxlTm9kZShuKSk7XG4gIGlmICghJGlzVGFibGVOb2RlKHBhcmVudFRhYmxlKSB8fCAhcGFyZW50VGFibGUuaXModGFibGVOb2RlKSkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgW3RhYmxlTWFwLCBjZWxsVmFsdWVdID0gJGNvbXB1dGVUYWJsZU1hcCh0YWJsZU5vZGUsIGFuY2hvckNlbGxOb2RlLCBhbmNob3JDZWxsTm9kZSk7XG4gIGNvbnN0IGZpcnN0Q2VsbCA9IHRhYmxlTWFwWzBdWzBdO1xuICBjb25zdCBsYXN0Q2VsbCA9IHRhYmxlTWFwW3RhYmxlTWFwLmxlbmd0aCAtIDFdW3RhYmxlTWFwWzBdLmxlbmd0aCAtIDFdO1xuICBjb25zdCB7XG4gICAgc3RhcnRSb3csXG4gICAgc3RhcnRDb2x1bW5cbiAgfSA9IGNlbGxWYWx1ZTtcbiAgY29uc3QgaXNBdEZpcnN0Q2VsbCA9IHN0YXJ0Um93ID09PSBmaXJzdENlbGwuc3RhcnRSb3cgJiYgc3RhcnRDb2x1bW4gPT09IGZpcnN0Q2VsbC5zdGFydENvbHVtbjtcbiAgY29uc3QgaXNBdExhc3RDZWxsID0gc3RhcnRSb3cgPT09IGxhc3RDZWxsLnN0YXJ0Um93ICYmIHN0YXJ0Q29sdW1uID09PSBsYXN0Q2VsbC5zdGFydENvbHVtbjtcbiAgaWYgKGlzQXRGaXJzdENlbGwpIHtcbiAgICByZXR1cm4gJ2ZpcnN0JztcbiAgfSBlbHNlIGlmIChpc0F0TGFzdENlbGwpIHtcbiAgICByZXR1cm4gJ2xhc3QnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uICRnZXRPYnNlcnZlckNlbGxGcm9tQ2VsbE5vZGVPclRocm93KHRhYmxlT2JzZXJ2ZXIsIHRhYmxlQ2VsbE5vZGUpIHtcbiAgY29uc3Qge1xuICAgIHRhYmxlTm9kZVxuICB9ID0gdGFibGVPYnNlcnZlci4kbG9va3VwKCk7XG4gIGNvbnN0IGN1cnJlbnRDb3JkcyA9IHRhYmxlTm9kZS5nZXRDb3Jkc0Zyb21DZWxsTm9kZSh0YWJsZUNlbGxOb2RlLCB0YWJsZU9ic2VydmVyLnRhYmxlKTtcbiAgcmV0dXJuIHRhYmxlTm9kZS5nZXRET01DZWxsRnJvbUNvcmRzT3JUaHJvdyhjdXJyZW50Q29yZHMueCwgY3VycmVudENvcmRzLnksIHRhYmxlT2JzZXJ2ZXIudGFibGUpO1xufVxuZnVuY3Rpb24gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGFibGVOb2RlLCBzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpIHtcbiAgcmV0dXJuICRmaW5kUGFyZW50VGFibGVDZWxsTm9kZUluVGFibGUodGFibGVOb2RlLCAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShzdGFydGluZ0RPTSwgZWRpdG9yU3RhdGUpKTtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRGl2RWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBpc0hUTUxFbGVtZW50JDEoZWxlbWVudCkgJiYgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0RJVic7XG59XG5mdW5jdGlvbiB1cGRhdGVDb2xncm91cChkb20sIGNvbmZpZywgY29sQ291bnQsIGNvbFdpZHRocykge1xuICBjb25zdCBjb2xHcm91cCA9IGRvbS5xdWVyeVNlbGVjdG9yKCdjb2xncm91cCcpO1xuICBpZiAoIWNvbEdyb3VwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbHMgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgY29uc3QgY29sID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sJyk7XG4gICAgY29uc3Qgd2lkdGggPSBjb2xXaWR0aHMgJiYgY29sV2lkdGhzW2ldO1xuICAgIGlmICh3aWR0aCkge1xuICAgICAgY29sLnN0eWxlLndpZHRoID0gYCR7d2lkdGh9cHhgO1xuICAgIH1cbiAgICBjb2xzLnB1c2goY29sKTtcbiAgfVxuICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG59XG5mdW5jdGlvbiBzZXRSb3dTdHJpcGluZyhkb20sIGNvbmZpZywgcm93U3RyaXBpbmcpIHtcbiAgaWYgKHJvd1N0cmlwaW5nKSB7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudChkb20sIGNvbmZpZy50aGVtZS50YWJsZVJvd1N0cmlwaW5nKTtcbiAgICBkb20uc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtcm93LXN0cmlwaW5nJywgJ3RydWUnKTtcbiAgfSBlbHNlIHtcbiAgICByZW1vdmVDbGFzc05hbWVzRnJvbUVsZW1lbnQoZG9tLCBjb25maWcudGhlbWUudGFibGVSb3dTdHJpcGluZyk7XG4gICAgZG9tLnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Db2x1bW5zKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plbkNvbHVtbkNvdW50KSB7XG4gIGlmIChmcm96ZW5Db2x1bW5Db3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuQ29sdW1uKTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLWNvbHVtbicpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGcm96ZW5Sb3dzKGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcsIGZyb3plblJvd0NvdW50KSB7XG4gIGlmIChmcm96ZW5Sb3dDb3VudCA+IDApIHtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycsICd0cnVlJyk7XG4gIH0gZWxzZSB7XG4gICAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgY29uZmlnLnRoZW1lLnRhYmxlRnJvemVuUm93KTtcbiAgICB0YWJsZUVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWxleGljYWwtZnJvemVuLXJvdycpO1xuICB9XG59XG5mdW5jdGlvbiBhbGlnblRhYmxlRWxlbWVudChkb20sIGNvbmZpZywgZm9ybWF0VHlwZSkge1xuICBpZiAoIWNvbmZpZy50aGVtZS50YWJsZUFsaWdubWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZW1vdmVDbGFzc2VzID0gW107XG4gIGNvbnN0IGFkZENsYXNzZXMgPSBbXTtcbiAgZm9yIChjb25zdCBmb3JtYXQgb2YgWydjZW50ZXInLCAncmlnaHQnXSkge1xuICAgIGNvbnN0IGNsYXNzZXMgPSBjb25maWcudGhlbWUudGFibGVBbGlnbm1lbnRbZm9ybWF0XTtcbiAgICBpZiAoIWNsYXNzZXMpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAoZm9ybWF0ID09PSBmb3JtYXRUeXBlID8gYWRkQ2xhc3NlcyA6IHJlbW92ZUNsYXNzZXMpLnB1c2goY2xhc3Nlcyk7XG4gIH1cbiAgcmVtb3ZlQ2xhc3NOYW1lc0Zyb21FbGVtZW50KGRvbSwgLi4ucmVtb3ZlQ2xhc3Nlcyk7XG4gIGFkZENsYXNzTmFtZXNUb0VsZW1lbnQoZG9tLCAuLi5hZGRDbGFzc2VzKTtcbn1cbmNvbnN0IHNjcm9sbGFibGVFZGl0b3JzID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yID0gJGdldEVkaXRvcigpKSB7XG4gIHJldHVybiBzY3JvbGxhYmxlRWRpdG9ycy5oYXMoZWRpdG9yKTtcbn1cbmZ1bmN0aW9uIHNldFNjcm9sbGFibGVUYWJsZXNBY3RpdmUoZWRpdG9yLCBhY3RpdmUpIHtcbiAgaWYgKGFjdGl2ZSkge1xuICAgIGlmICghZWRpdG9yLl9jb25maWcudGhlbWUudGFibGVTY3JvbGxhYmxlV3JhcHBlcikge1xuICAgICAgY29uc29sZS53YXJuKCdUYWJsZU5vZGU6IGhhc0hvcml6b250YWxTY3JvbGwgaXMgYWN0aXZlIGJ1dCB0aGVtZS50YWJsZVNjcm9sbGFibGVXcmFwcGVyIGlzIG5vdCBkZWZpbmVkLicpO1xuICAgIH1cbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgfSBlbHNlIHtcbiAgICBzY3JvbGxhYmxlRWRpdG9ycy5kZWxldGUoZWRpdG9yKTtcbiAgfVxufVxuXG4vKiogQG5vSW5oZXJpdERvYyAqL1xuY2xhc3MgVGFibGVOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICd0YWJsZSc7XG4gIH1cbiAgZ2V0Q29sV2lkdGhzKCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldExhdGVzdCgpO1xuICAgIHJldHVybiBzZWxmLl9fY29sV2lkdGhzO1xuICB9XG4gIHNldENvbFdpZHRocyhjb2xXaWR0aHMpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIC8vIE5PVEU6IE5vZGUgcHJvcGVydGllcyBzaG91bGQgYmUgaW1tdXRhYmxlLiBGcmVlemUgdG8gcHJldmVudCBhY2NpZGVudGFsIG11dGF0aW9uLlxuICAgIHNlbGYuX19jb2xXaWR0aHMgPSBjb2xXaWR0aHMgIT09IHVuZGVmaW5lZCAmJiB0cnVlID8gT2JqZWN0LmZyZWV6ZShjb2xXaWR0aHMpIDogY29sV2lkdGhzO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIHN0YXRpYyBjbG9uZShub2RlKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJsZU5vZGUobm9kZS5fX2tleSk7XG4gIH1cbiAgYWZ0ZXJDbG9uZUZyb20ocHJldk5vZGUpIHtcbiAgICBzdXBlci5hZnRlckNsb25lRnJvbShwcmV2Tm9kZSk7XG4gICAgdGhpcy5fX2NvbFdpZHRocyA9IHByZXZOb2RlLl9fY29sV2lkdGhzO1xuICAgIHRoaXMuX19yb3dTdHJpcGluZyA9IHByZXZOb2RlLl9fcm93U3RyaXBpbmc7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSBwcmV2Tm9kZS5fX2Zyb3plblJvd0NvdW50O1xuICB9XG4gIHN0YXRpYyBpbXBvcnRET00oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhYmxlOiBfbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydFRhYmxlRWxlbWVudCxcbiAgICAgICAgcHJpb3JpdHk6IDFcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuICBzdGF0aWMgaW1wb3J0SlNPTihzZXJpYWxpemVkTm9kZSkge1xuICAgIHJldHVybiAkY3JlYXRlVGFibGVOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRSb3dTdHJpcGluZyhzZXJpYWxpemVkTm9kZS5yb3dTdHJpcGluZyB8fCBmYWxzZSkuc2V0RnJvemVuQ29sdW1ucyhzZXJpYWxpemVkTm9kZS5mcm96ZW5Db2x1bW5Db3VudCB8fCAwKS5zZXRGcm96ZW5Sb3dzKHNlcmlhbGl6ZWROb2RlLmZyb3plblJvd0NvdW50IHx8IDApLnNldENvbFdpZHRocyhzZXJpYWxpemVkTm9kZS5jb2xXaWR0aHMpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgdGhpcy5fX3Jvd1N0cmlwaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fX2Zyb3plbkNvbHVtbkNvdW50ID0gMDtcbiAgICB0aGlzLl9fZnJvemVuUm93Q291bnQgPSAwO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGNvbFdpZHRoczogdGhpcy5nZXRDb2xXaWR0aHMoKSxcbiAgICAgIGZyb3plbkNvbHVtbkNvdW50OiB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgPyB0aGlzLl9fZnJvemVuQ29sdW1uQ291bnQgOiB1bmRlZmluZWQsXG4gICAgICBmcm96ZW5Sb3dDb3VudDogdGhpcy5fX2Zyb3plblJvd0NvdW50ID8gdGhpcy5fX2Zyb3plblJvd0NvdW50IDogdW5kZWZpbmVkLFxuICAgICAgcm93U3RyaXBpbmc6IHRoaXMuX19yb3dTdHJpcGluZyA/IHRoaXMuX19yb3dTdHJpcGluZyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgZXh0cmFjdFdpdGhDaGlsZChjaGlsZCwgc2VsZWN0aW9uLCBkZXN0aW5hdGlvbikge1xuICAgIHJldHVybiBkZXN0aW5hdGlvbiA9PT0gJ2h0bWwnO1xuICB9XG4gIGdldERPTVNsb3QoZWxlbWVudCkge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJykgOiBlbGVtZW50O1xuICAgIGlmICghaXNIVE1MVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCkpIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVOb2RlLmdldERPTVNsb3Q6IGNyZWF0ZURPTSgpIGRpZCBub3QgcmV0dXJuIGEgdGFibGVgKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmdldERPTVNsb3QoZWxlbWVudCkud2l0aEVsZW1lbnQodGFibGVFbGVtZW50KS53aXRoQWZ0ZXIodGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2NvbGdyb3VwJykpO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcsIGVkaXRvcikge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJyk7XG4gICAgaWYgKHRoaXMuX19zdHlsZSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IGNvbEdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY29sZ3JvdXAnKTtcbiAgICB0YWJsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY29sR3JvdXApO1xuICAgIHNldERPTVVubWFuYWdlZChjb2xHcm91cCk7XG4gICAgYWRkQ2xhc3NOYW1lc1RvRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZy50aGVtZS50YWJsZSk7XG4gICAgdGhpcy51cGRhdGVUYWJsZUVsZW1lbnQobnVsbCwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIGlmICgkaXNTY3JvbGxhYmxlVGFibGVzQWN0aXZlKGVkaXRvcikpIHtcbiAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBjb25zdCBjbGFzc2VzID0gY29uZmlnLnRoZW1lLnRhYmxlU2Nyb2xsYWJsZVdyYXBwZXI7XG4gICAgICBpZiAoY2xhc3Nlcykge1xuICAgICAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KHdyYXBwZXJFbGVtZW50LCBjbGFzc2VzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LnN0eWxlLmNzc1RleHQgPSAnb3ZlcmZsb3cteDogYXV0bzsnO1xuICAgICAgfVxuICAgICAgd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQodGFibGVFbGVtZW50KTtcbiAgICAgIHRoaXMudXBkYXRlVGFibGVXcmFwcGVyKG51bGwsIHdyYXBwZXJFbGVtZW50LCB0YWJsZUVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICByZXR1cm4gd3JhcHBlckVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZUVsZW1lbnQ7XG4gIH1cbiAgdXBkYXRlVGFibGVXcmFwcGVyKHByZXZOb2RlLCB0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19mcm96ZW5Db2x1bW5Db3VudCA6IDApKSB7XG4gICAgICBzZXRGcm96ZW5Db2x1bW5zKHRhYmxlV3JhcHBlciwgdGFibGVFbGVtZW50LCBjb25maWcsIHRoaXMuX19mcm96ZW5Db2x1bW5Db3VudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fZnJvemVuUm93Q291bnQgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fZnJvemVuUm93Q291bnQgOiAwKSkge1xuICAgICAgc2V0RnJvemVuUm93cyh0YWJsZVdyYXBwZXIsIHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fZnJvemVuUm93Q291bnQpO1xuICAgIH1cbiAgfVxuICB1cGRhdGVUYWJsZUVsZW1lbnQocHJldk5vZGUsIHRhYmxlRWxlbWVudCwgY29uZmlnKSB7XG4gICAgaWYgKHRoaXMuX19zdHlsZSAhPT0gKHByZXZOb2RlID8gcHJldk5vZGUuX19zdHlsZSA6ICcnKSkge1xuICAgICAgdGFibGVFbGVtZW50LnN0eWxlLmNzc1RleHQgPSB0aGlzLl9fc3R5bGU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fcm93U3RyaXBpbmcgIT09IChwcmV2Tm9kZSA/IHByZXZOb2RlLl9fcm93U3RyaXBpbmcgOiBmYWxzZSkpIHtcbiAgICAgIHNldFJvd1N0cmlwaW5nKHRhYmxlRWxlbWVudCwgY29uZmlnLCB0aGlzLl9fcm93U3RyaXBpbmcpO1xuICAgIH1cbiAgICB1cGRhdGVDb2xncm91cCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRDb2x1bW5Db3VudCgpLCB0aGlzLmdldENvbFdpZHRocygpKTtcbiAgICBhbGlnblRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQsIGNvbmZpZywgdGhpcy5nZXRGb3JtYXRUeXBlKCkpO1xuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgZG9tLCBjb25maWcpIHtcbiAgICBjb25zdCBzbG90ID0gdGhpcy5nZXRET01TbG90KGRvbSk7XG4gICAgY29uc3QgdGFibGVFbGVtZW50ID0gc2xvdC5lbGVtZW50O1xuICAgIGlmIChkb20gPT09IHRhYmxlRWxlbWVudCA9PT0gJGlzU2Nyb2xsYWJsZVRhYmxlc0FjdGl2ZSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGlzSFRNTERpdkVsZW1lbnQoZG9tKSkge1xuICAgICAgdGhpcy51cGRhdGVUYWJsZVdyYXBwZXIocHJldk5vZGUsIGRvbSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIH1cbiAgICB0aGlzLnVwZGF0ZVRhYmxlRWxlbWVudChwcmV2Tm9kZSwgdGFibGVFbGVtZW50LCBjb25maWcpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBleHBvcnRET00oZWRpdG9yKSB7XG4gICAgY29uc3Qgc3VwZXJFeHBvcnQgPSBzdXBlci5leHBvcnRET00oZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBlbGVtZW50XG4gICAgfSA9IHN1cGVyRXhwb3J0O1xuICAgIHJldHVybiB7XG4gICAgICBhZnRlcjogdGFibGVFbGVtZW50ID0+IHtcbiAgICAgICAgaWYgKHN1cGVyRXhwb3J0LmFmdGVyKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gc3VwZXJFeHBvcnQuYWZ0ZXIodGFibGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSFRNTFRhYmxlRWxlbWVudCh0YWJsZUVsZW1lbnQpICYmIGlzSFRNTEVsZW1lbnQkMSh0YWJsZUVsZW1lbnQpKSB7XG4gICAgICAgICAgdGFibGVFbGVtZW50ID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3RhYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc0hUTUxUYWJsZUVsZW1lbnQodGFibGVFbGVtZW50KSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGFsaWduVGFibGVFbGVtZW50KHRhYmxlRWxlbWVudCwgZWRpdG9yLl9jb25maWcsIHRoaXMuZ2V0Rm9ybWF0VHlwZSgpKTtcblxuICAgICAgICAvLyBTY2FuIHRoZSB0YWJsZSBtYXAgdG8gYnVpbGQgYSBtYXAgb2YgdGFibGUgY2VsbCBrZXkgdG8gdGhlIGNvbHVtbnMgaXQgbmVlZHNcbiAgICAgICAgY29uc3QgW3RhYmxlTWFwXSA9ICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrKHRoaXMsIG51bGwsIG51bGwpO1xuICAgICAgICBjb25zdCBjZWxsVmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG1hcFJvdyBvZiB0YWJsZU1hcCkge1xuICAgICAgICAgIGZvciAoY29uc3QgbWFwVmFsdWUgb2YgbWFwUm93KSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtYXBWYWx1ZS5jZWxsLmdldEtleSgpO1xuICAgICAgICAgICAgaWYgKCFjZWxsVmFsdWVzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgIGNlbGxWYWx1ZXMuc2V0KGtleSwge1xuICAgICAgICAgICAgICAgIGNvbFNwYW46IG1hcFZhbHVlLmNlbGwuZ2V0Q29sU3BhbigpLFxuICAgICAgICAgICAgICAgIHN0YXJ0Q29sdW1uOiBtYXBWYWx1ZS5zdGFydENvbHVtblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzY2FuIHRoZSBET00gdG8gZmluZCB0aGUgdGFibGUgY2VsbCBrZXlzIHRoYXQgd2VyZSB1c2VkIGFuZCBtYXJrIHRob3NlIGNvbHVtbnNcbiAgICAgICAgY29uc3Qga25vd25Db2x1bW5zID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGNlbGxET00gb2YgdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IHRyID4gW2RhdGEtdGVtcG9yYXJ5LXRhYmxlLWNlbGwtbGV4aWNhbC1rZXldJykpIHtcbiAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsRE9NLmdldEF0dHJpYnV0ZSgnZGF0YS10ZW1wb3JhcnktdGFibGUtY2VsbC1sZXhpY2FsLWtleScpO1xuICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGxTcGFuID0gY2VsbFZhbHVlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIGNlbGxET00ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRlbXBvcmFyeS10YWJsZS1jZWxsLWxleGljYWwta2V5Jyk7XG4gICAgICAgICAgICBpZiAoY2VsbFNwYW4pIHtcbiAgICAgICAgICAgICAgY2VsbFZhbHVlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxsU3Bhbi5jb2xTcGFuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBrbm93bkNvbHVtbnMuYWRkKGkgKyBjZWxsU3Bhbi5zdGFydENvbHVtbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb21wdXRlIHRoZSBjb2xncm91cCBhbmQgY29sdW1ucyBpbiB0aGUgZXhwb3J0XG4gICAgICAgIGNvbnN0IGNvbEdyb3VwID0gdGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJzpzY29wZSA+IGNvbGdyb3VwJyk7XG4gICAgICAgIGlmIChjb2xHcm91cCkge1xuICAgICAgICAgIC8vIE9ubHkgaW5jbHVkZSB0aGUgPGNvbCAvPiBmb3Igcm93cyB0aGF0IGFyZSBpbiB0aGUgb3V0cHV0XG4gICAgICAgICAgY29uc3QgY29scyA9IEFycmF5LmZyb20odGFibGVFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbGdyb3VwID4gY29sJykpLmZpbHRlcigoZG9tLCBpKSA9PiBrbm93bkNvbHVtbnMuaGFzKGkpKTtcbiAgICAgICAgICBjb2xHcm91cC5yZXBsYWNlQ2hpbGRyZW4oLi4uY29scyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXcmFwIGRpcmVjdCBkZXNjZW5kYW50IHJvd3MgaW4gYSB0Ym9keSBmb3IgZXhwb3J0XG4gICAgICAgIGNvbnN0IHJvd3MgPSB0YWJsZUVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnOnNjb3BlID4gdHInKTtcbiAgICAgICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IHRCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IHJvdyBvZiByb3dzKSB7XG4gICAgICAgICAgICB0Qm9keS5hcHBlbmRDaGlsZChyb3cpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0YWJsZUVsZW1lbnQuYXBwZW5kKHRCb2R5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGFibGVFbGVtZW50O1xuICAgICAgfSxcbiAgICAgIGVsZW1lbnQ6ICFpc0hUTUxUYWJsZUVsZW1lbnQoZWxlbWVudCkgJiYgaXNIVE1MRWxlbWVudCQxKGVsZW1lbnQpID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpIDogZWxlbWVudFxuICAgIH07XG4gIH1cbiAgY2FuQmVFbXB0eSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaXNTaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGdldENvcmRzRnJvbUNlbGxOb2RlKHRhYmxlQ2VsbE5vZGUsIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgcm93cyxcbiAgICAgIGRvbVJvd3NcbiAgICB9ID0gdGFibGU7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCByb3dzOyB5KyspIHtcbiAgICAgIGNvbnN0IHJvdyA9IGRvbVJvd3NbeV07XG4gICAgICBpZiAocm93ID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHJvdy5sZW5ndGg7IHgrKykge1xuICAgICAgICBjb25zdCBjZWxsID0gcm93W3hdO1xuICAgICAgICBpZiAoY2VsbCA9PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVsZW1cbiAgICAgICAgfSA9IGNlbGw7XG4gICAgICAgIGNvbnN0IGNlbGxOb2RlID0gJGdldE5lYXJlc3RUYWJsZUNlbGxJblRhYmxlRnJvbURPTU5vZGUodGhpcywgZWxlbSk7XG4gICAgICAgIGlmIChjZWxsTm9kZSAhPT0gbnVsbCAmJiB0YWJsZUNlbGxOb2RlLmlzKGNlbGxOb2RlKSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB4LFxuICAgICAgICAgICAgeVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZWxsIG5vdCBmb3VuZCBpbiB0YWJsZS4nKTtcbiAgfVxuICBnZXRET01DZWxsRnJvbUNvcmRzKHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3Qge1xuICAgICAgZG9tUm93c1xuICAgIH0gPSB0YWJsZTtcbiAgICBjb25zdCByb3cgPSBkb21Sb3dzW3ldO1xuICAgIGlmIChyb3cgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGluZGV4ID0geCA8IHJvdy5sZW5ndGggPyB4IDogcm93Lmxlbmd0aCAtIDE7XG4gICAgY29uc3QgY2VsbCA9IHJvd1tpbmRleF07XG4gICAgaWYgKGNlbGwgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjZWxsO1xuICB9XG4gIGdldERPTUNlbGxGcm9tQ29yZHNPclRocm93KHgsIHksIHRhYmxlKSB7XG4gICAgY29uc3QgY2VsbCA9IHRoaXMuZ2V0RE9NQ2VsbEZyb21Db3Jkcyh4LCB5LCB0YWJsZSk7XG4gICAgaWYgKCFjZWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NlbGwgbm90IGZvdW5kIGF0IGNvcmRzLicpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfVxuICBnZXRDZWxsTm9kZUZyb21Db3Jkcyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdldERPTUNlbGxGcm9tQ29yZHMoeCwgeSwgdGFibGUpO1xuICAgIGlmIChjZWxsID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlID0gJGdldE5lYXJlc3ROb2RlRnJvbURPTU5vZGUoY2VsbC5lbGVtKTtcbiAgICBpZiAoJGlzVGFibGVDZWxsTm9kZShub2RlKSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGdldENlbGxOb2RlRnJvbUNvcmRzT3JUaHJvdyh4LCB5LCB0YWJsZSkge1xuICAgIGNvbnN0IG5vZGUgPSB0aGlzLmdldENlbGxOb2RlRnJvbUNvcmRzKHgsIHksIHRhYmxlKTtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBhdCBjb3JkcyBub3QgVGFibGVDZWxsTm9kZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cbiAgZ2V0Um93U3RyaXBpbmcoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRMYXRlc3QoKS5fX3Jvd1N0cmlwaW5nKTtcbiAgfVxuICBzZXRSb3dTdHJpcGluZyhuZXdSb3dTdHJpcGluZykge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX3Jvd1N0cmlwaW5nID0gbmV3Um93U3RyaXBpbmc7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgc2V0RnJvemVuQ29sdW1ucyhjb2x1bW5Db3VudCkge1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgc2VsZi5fX2Zyb3plbkNvbHVtbkNvdW50ID0gY29sdW1uQ291bnQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH1cbiAgZ2V0RnJvemVuQ29sdW1ucygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX2Zyb3plbkNvbHVtbkNvdW50O1xuICB9XG4gIHNldEZyb3plblJvd3Mocm93Q291bnQpIHtcbiAgICBjb25zdCBzZWxmID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHNlbGYuX19mcm96ZW5Sb3dDb3VudCA9IHJvd0NvdW50O1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGdldEZyb3plblJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19mcm96ZW5Sb3dDb3VudDtcbiAgfVxuICBjYW5TZWxlY3RCZWZvcmUoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY2FuSW5kZW50KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBnZXRDb2x1bW5Db3VudCgpIHtcbiAgICBjb25zdCBmaXJzdFJvdyA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuICAgIGlmICghZmlyc3RSb3cpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBsZXQgY29sdW1uQ291bnQgPSAwO1xuICAgIGZpcnN0Um93LmdldENoaWxkcmVuKCkuZm9yRWFjaChjZWxsID0+IHtcbiAgICAgIGlmICgkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgIGNvbHVtbkNvdW50ICs9IGNlbGwuZ2V0Q29sU3BhbigpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjb2x1bW5Db3VudDtcbiAgfVxufVxuZnVuY3Rpb24gJGdldEVsZW1lbnRGb3JUYWJsZU5vZGUoZWRpdG9yLCB0YWJsZU5vZGUpIHtcbiAgY29uc3QgdGFibGVFbGVtZW50ID0gZWRpdG9yLmdldEVsZW1lbnRCeUtleSh0YWJsZU5vZGUuZ2V0S2V5KCkpO1xuICBpZiAoISh0YWJsZUVsZW1lbnQgIT09IG51bGwpKSB7XG4gICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZTogVGFibGUgRWxlbWVudCBOb3QgRm91bmRgKTtcbiAgfVxuICByZXR1cm4gZ2V0VGFibGUodGFibGVOb2RlLCB0YWJsZUVsZW1lbnQpO1xufVxuZnVuY3Rpb24gJGNvbnZlcnRUYWJsZUVsZW1lbnQoZG9tTm9kZSkge1xuICBjb25zdCB0YWJsZU5vZGUgPSAkY3JlYXRlVGFibGVOb2RlKCk7XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLXJvdy1zdHJpcGluZycpKSB7XG4gICAgdGFibGVOb2RlLnNldFJvd1N0cmlwaW5nKHRydWUpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1jb2x1bW4nKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Db2x1bW5zKDEpO1xuICB9XG4gIGlmIChkb21Ob2RlLmhhc0F0dHJpYnV0ZSgnZGF0YS1sZXhpY2FsLWZyb3plbi1yb3cnKSkge1xuICAgIHRhYmxlTm9kZS5zZXRGcm96ZW5Sb3dzKDEpO1xuICB9XG4gIGNvbnN0IGNvbEdyb3VwID0gZG9tTm9kZS5xdWVyeVNlbGVjdG9yKCc6c2NvcGUgPiBjb2xncm91cCcpO1xuICBpZiAoY29sR3JvdXApIHtcbiAgICBsZXQgY29sdW1ucyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29sIG9mIGNvbEdyb3VwLnF1ZXJ5U2VsZWN0b3JBbGwoJzpzY29wZSA+IGNvbCcpKSB7XG4gICAgICBsZXQgd2lkdGggPSBjb2wuc3R5bGUud2lkdGggfHwgJyc7XG4gICAgICBpZiAoIVBJWEVMX1ZBTFVFX1JFR19FWFAudGVzdCh3aWR0aCkpIHtcbiAgICAgICAgLy8gQWxzbyBzdXBwb3J0IGRlcHJlY2F0ZWQgd2lkdGggYXR0cmlidXRlIGZvciBnb29nbGUgZG9jc1xuICAgICAgICB3aWR0aCA9IGNvbC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykgfHwgJyc7XG4gICAgICAgIGlmICghL15cXGQrJC8udGVzdCh3aWR0aCkpIHtcbiAgICAgICAgICBjb2x1bW5zID0gdW5kZWZpbmVkO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb2x1bW5zLnB1c2gocGFyc2VGbG9hdCh3aWR0aCkpO1xuICAgIH1cbiAgICBpZiAoY29sdW1ucykge1xuICAgICAgdGFibGVOb2RlLnNldENvbFdpZHRocyhjb2x1bW5zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhZnRlcjogY2hpbGRyZW4gPT4gJGRlc2NlbmRhbnRzTWF0Y2hpbmcoY2hpbGRyZW4sICRpc1RhYmxlUm93Tm9kZSksXG4gICAgbm9kZTogdGFibGVOb2RlXG4gIH07XG59XG5mdW5jdGlvbiAkY3JlYXRlVGFibGVOb2RlKCkge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBUYWJsZU5vZGUoKSk7XG59XG5mdW5jdGlvbiAkaXNUYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIFRhYmxlTm9kZTtcbn1cblxuZnVuY3Rpb24gJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyKHtcbiAgcm93cyxcbiAgY29sdW1ucyxcbiAgaW5jbHVkZUhlYWRlcnNcbn0pIHtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpIHx8ICRnZXRQcmV2aW91c1NlbGVjdGlvbigpO1xuICBpZiAoIXNlbGVjdGlvbiB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFByZXZlbnQgbmVzdGVkIHRhYmxlcyBieSBjaGVja2luZyBpZiB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhIHRhYmxlXG4gIGlmICgkZmluZFRhYmxlTm9kZShzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgdGFibGVOb2RlID0gJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zKE51bWJlcihyb3dzKSwgTnVtYmVyKGNvbHVtbnMpLCBpbmNsdWRlSGVhZGVycyk7XG4gICRpbnNlcnROb2RlVG9OZWFyZXN0Um9vdCh0YWJsZU5vZGUpO1xuICBjb25zdCBmaXJzdERlc2NlbmRhbnQgPSB0YWJsZU5vZGUuZ2V0Rmlyc3REZXNjZW5kYW50KCk7XG4gIGlmICgkaXNUZXh0Tm9kZShmaXJzdERlc2NlbmRhbnQpKSB7XG4gICAgZmlyc3REZXNjZW5kYW50LnNlbGVjdCgpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gJHRhYmxlQ2VsbFRyYW5zZm9ybShub2RlKSB7XG4gIGlmICghJGlzVGFibGVSb3dOb2RlKG5vZGUuZ2V0UGFyZW50KCkpKSB7XG4gICAgLy8gVGFibGVDZWxsTm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVSb3dOb2RlLlxuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSBpZiAobm9kZS5pc0VtcHR5KCkpIHtcbiAgICAvLyBUYWJsZUNlbGxOb2RlIHNob3VsZCBuZXZlciBiZSBlbXB0eVxuICAgIG5vZGUuYXBwZW5kKCRjcmVhdGVQYXJhZ3JhcGhOb2RlKCkpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVSb3dUcmFuc2Zvcm0obm9kZSkge1xuICBpZiAoISRpc1RhYmxlTm9kZShub2RlLmdldFBhcmVudCgpKSkge1xuICAgIC8vIFRhYmxlUm93Tm9kZSBtdXN0IGJlIGEgY2hpbGQgb2YgVGFibGVOb2RlLlxuICAgIC8vIFRPRE86IEZ1dHVyZSBzdXBwb3J0IG9mIHRib2R5L3RoZWFkL3Rmb290IG1heSBjaGFuZ2UgdGhpc1xuICAgIG5vZGUucmVtb3ZlKCk7XG4gIH0gZWxzZSB7XG4gICAgJHVud3JhcEFuZEZpbHRlckRlc2NlbmRhbnRzKG5vZGUsICRpc1RhYmxlQ2VsbE5vZGUpO1xuICB9XG59XG5mdW5jdGlvbiAkdGFibGVUcmFuc2Zvcm0obm9kZSkge1xuICAvLyBUYWJsZVJvd05vZGUgaXMgdGhlIG9ubHkgdmFsaWQgY2hpbGQgZm9yIFRhYmxlTm9kZVxuICAvLyBUT0RPOiBGdXR1cmUgc3VwcG9ydCBvZiB0Ym9keS90aGVhZC90Zm9vdC9jYXB0aW9uIG1heSBjaGFuZ2UgdGhpc1xuICAkdW53cmFwQW5kRmlsdGVyRGVzY2VuZGFudHMobm9kZSwgJGlzVGFibGVSb3dOb2RlKTtcbiAgY29uc3QgW2dyaWRNYXBdID0gJGNvbXB1dGVUYWJsZU1hcFNraXBDZWxsQ2hlY2sobm9kZSwgbnVsbCwgbnVsbCk7XG4gIGNvbnN0IG1heFJvd0xlbmd0aCA9IGdyaWRNYXAucmVkdWNlKChjdXJMZW5ndGgsIHJvdykgPT4ge1xuICAgIHJldHVybiBNYXRoLm1heChjdXJMZW5ndGgsIHJvdy5sZW5ndGgpO1xuICB9LCAwKTtcbiAgY29uc3Qgcm93Tm9kZXMgPSBub2RlLmdldENoaWxkcmVuKCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZ3JpZE1hcC5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHJvd05vZGUgPSByb3dOb2Rlc1tpXTtcbiAgICBpZiAoIXJvd05vZGUpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoISRpc1RhYmxlUm93Tm9kZShyb3dOb2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBUYWJsZVBsdWdpbjogRXhwZWN0aW5nIGFsbCBjaGlsZHJlbiBvZiBUYWJsZU5vZGUgdG8gYmUgVGFibGVSb3dOb2RlLCBmb3VuZCAke3Jvd05vZGUuY29uc3RydWN0b3IubmFtZX0gKHR5cGUgJHtyb3dOb2RlLmdldFR5cGUoKX0pYCk7XG4gICAgfVxuICAgIGNvbnN0IHJvd0xlbmd0aCA9IGdyaWRNYXBbaV0ucmVkdWNlKChhY2MsIGNlbGwpID0+IGNlbGwgPyAxICsgYWNjIDogYWNjLCAwKTtcbiAgICBpZiAocm93TGVuZ3RoID09PSBtYXhSb3dMZW5ndGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gcm93TGVuZ3RoOyBqIDwgbWF4Um93TGVuZ3RoOyArK2opIHtcbiAgICAgIC8vIFRPRE86IGluaGVyaXQgaGVhZGVyIHN0YXRlIGZyb20gYW5vdGhlciBoZWFkZXIgb3IgYm9keVxuICAgICAgY29uc3QgbmV3Q2VsbCA9ICRjcmVhdGVUYWJsZUNlbGxOb2RlKCk7XG4gICAgICBuZXdDZWxsLmFwcGVuZCgkY3JlYXRlUGFyYWdyYXBoTm9kZSgpKTtcbiAgICAgIHJvd05vZGUuYXBwZW5kKG5ld0NlbGwpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gJHRhYmxlQ2xpY2tDb21tYW5kKGV2ZW50KSB7XG4gIGlmIChldmVudC5kZXRhaWwgPCAzIHx8ICFpc0RPTU5vZGUoZXZlbnQudGFyZ2V0KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdGFydE5vZGUgPSAkZ2V0TmVhcmVzdE5vZGVGcm9tRE9NTm9kZShldmVudC50YXJnZXQpO1xuICBpZiAoc3RhcnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGJsb2NrTm9kZSA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQoc3RhcnROb2RlLCBub2RlID0+ICRpc0VsZW1lbnROb2RlKG5vZGUpICYmICFub2RlLmlzSW5saW5lKCkpO1xuICBpZiAoYmxvY2tOb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IHJvb3ROb2RlID0gYmxvY2tOb2RlLmdldFBhcmVudCgpO1xuICBpZiAoISRpc1RhYmxlQ2VsbE5vZGUocm9vdE5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGJsb2NrTm9kZS5zZWxlY3QoMCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIGEgdHJhbnNmb3JtIHRvIGVuc3VyZSB0aGF0IGFsbCBUYWJsZUNlbGxOb2RlIGhhdmUgYSBjb2xTcGFuIGFuZCByb3dTcGFuIG9mIDEuXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHJlZ2lzdGVyZWQgd2hlbiB5b3UgZG8gbm90IHdhbnQgdG8gc3VwcG9ydCBtZXJnZWQgY2VsbHMuXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybShlZGl0b3IpIHtcbiAgcmV0dXJuIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVDZWxsTm9kZSwgbm9kZSA9PiB7XG4gICAgaWYgKG5vZGUuZ2V0Q29sU3BhbigpID4gMSB8fCBub2RlLmdldFJvd1NwYW4oKSA+IDEpIHtcbiAgICAgIC8vIFdoZW4gd2UgaGF2ZSByb3dTcGFuIHdlIGhhdmUgdG8gbWFwIHRoZSBlbnRpcmUgVGFibGUgdG8gdW5kZXJzdGFuZCB3aGVyZSB0aGUgbmV3IENlbGxzXG4gICAgICAvLyBmaXQgYmVzdDsgbGV0J3MgYW5hbHl6ZSBhbGwgQ2VsbHMgYXQgb25jZSB0byBzYXZlIHVzIGZyb20gZnVydGhlciB0cmFuc2Zvcm0gaXRlcmF0aW9uc1xuICAgICAgY29uc3QgWywsIGdyaWROb2RlXSA9ICRnZXROb2RlVHJpcGxldChub2RlKTtcbiAgICAgIGNvbnN0IFtncmlkTWFwXSA9ICRjb21wdXRlVGFibGVNYXAoZ3JpZE5vZGUsIG5vZGUsIG5vZGUpO1xuICAgICAgLy8gVE9ETyB0aGlzIGZ1bmN0aW9uIGV4cGVjdHMgVGFibGVzIHRvIGJlIG5vcm1hbGl6ZWQuIExvb2sgaW50byB0aGlzIG9uY2UgaXQgZXhpc3RzXG4gICAgICBjb25zdCByb3dzQ291bnQgPSBncmlkTWFwLmxlbmd0aDtcbiAgICAgIGNvbnN0IGNvbHVtbnNDb3VudCA9IGdyaWRNYXBbMF0ubGVuZ3RoO1xuICAgICAgbGV0IHJvdyA9IGdyaWROb2RlLmdldEZpcnN0Q2hpbGQoKTtcbiAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGBFeHBlY3RlZCBUYWJsZU5vZGUgZmlyc3QgY2hpbGQgdG8gYmUgYSBSb3dOb2RlYCk7XG4gICAgICB9XG4gICAgICBjb25zdCB1bm1lcmdlZCA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzQ291bnQ7IGkrKykge1xuICAgICAgICBpZiAoaSAhPT0gMCkge1xuICAgICAgICAgIHJvdyA9IHJvdy5nZXROZXh0U2libGluZygpO1xuICAgICAgICAgIGlmICghJGlzVGFibGVSb3dOb2RlKHJvdykpIHtcbiAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGZpcnN0IGNoaWxkIHRvIGJlIGEgUm93Tm9kZWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbGFzdFJvd0NlbGwgPSBudWxsO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHVtbnNDb3VudDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgY2VsbE1hcCA9IGdyaWRNYXBbaV1bal07XG4gICAgICAgICAgY29uc3QgY2VsbCA9IGNlbGxNYXAuY2VsbDtcbiAgICAgICAgICBpZiAoY2VsbE1hcC5zdGFydFJvdyA9PT0gaSAmJiBjZWxsTWFwLnN0YXJ0Q29sdW1uID09PSBqKSB7XG4gICAgICAgICAgICBsYXN0Um93Q2VsbCA9IGNlbGw7XG4gICAgICAgICAgICB1bm1lcmdlZC5wdXNoKGNlbGwpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2VsbC5nZXRDb2xTcGFuKCkgPiAxIHx8IGNlbGwuZ2V0Um93U3BhbigpID4gMSkge1xuICAgICAgICAgICAgaWYgKCEkaXNUYWJsZUNlbGxOb2RlKGNlbGwpKSB7XG4gICAgICAgICAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgRXhwZWN0ZWQgVGFibGVOb2RlIGNlbGwgdG8gYmUgYSBUYWJsZUNlbGxOb2RlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdDZWxsID0gJGNyZWF0ZVRhYmxlQ2VsbE5vZGUoY2VsbC5fX2hlYWRlclN0YXRlKTtcbiAgICAgICAgICAgIGlmIChsYXN0Um93Q2VsbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBsYXN0Um93Q2VsbC5pbnNlcnRBZnRlcihuZXdDZWxsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICRpbnNlcnRGaXJzdCQxKHJvdywgbmV3Q2VsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdW5tZXJnZWQpIHtcbiAgICAgICAgY2VsbC5zZXRDb2xTcGFuKDEpO1xuICAgICAgICBjZWxsLnNldFJvd1NwYW4oMSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcihlZGl0b3IsIGhhc1RhYkhhbmRsZXIgPSB0cnVlKSB7XG4gIGNvbnN0IHRhYmxlU2VsZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgY29uc3QgaW5pdGlhbGl6ZVRhYmxlTm9kZSA9ICh0YWJsZU5vZGUsIG5vZGVLZXksIGRvbSkgPT4ge1xuICAgIGNvbnN0IHRhYmxlRWxlbWVudCA9IGdldFRhYmxlRWxlbWVudCh0YWJsZU5vZGUsIGRvbSk7XG4gICAgY29uc3QgdGFibGVTZWxlY3Rpb24gPSBhcHBseVRhYmxlSGFuZGxlcnModGFibGVOb2RlLCB0YWJsZUVsZW1lbnQsIGVkaXRvciwgaGFzVGFiSGFuZGxlcik7XG4gICAgdGFibGVTZWxlY3Rpb25zLnNldChub2RlS2V5LCBbdGFibGVTZWxlY3Rpb24sIHRhYmxlRWxlbWVudF0pO1xuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVyTXV0YXRpb25MaXN0ZW5lciA9IGVkaXRvci5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoVGFibGVOb2RlLCBub2RlTXV0YXRpb25zID0+IHtcbiAgICBlZGl0b3IuZ2V0RWRpdG9yU3RhdGUoKS5yZWFkKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgW25vZGVLZXksIG11dGF0aW9uXSBvZiBub2RlTXV0YXRpb25zKSB7XG4gICAgICAgIGNvbnN0IHRhYmxlU2VsZWN0aW9uID0gdGFibGVTZWxlY3Rpb25zLmdldChub2RlS2V5KTtcbiAgICAgICAgaWYgKG11dGF0aW9uID09PSAnY3JlYXRlZCcgfHwgbXV0YXRpb24gPT09ICd1cGRhdGVkJykge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHRhYmxlTm9kZSxcbiAgICAgICAgICAgIHRhYmxlRWxlbWVudFxuICAgICAgICAgIH0gPSAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXkobm9kZUtleSk7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGluaXRpYWxpemVUYWJsZU5vZGUodGFibGVOb2RlLCBub2RlS2V5LCB0YWJsZUVsZW1lbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGFibGVFbGVtZW50ICE9PSB0YWJsZVNlbGVjdGlvblsxXSkge1xuICAgICAgICAgICAgLy8gVGhlIHVwZGF0ZSBjcmVhdGVkIGEgbmV3IERPTSBub2RlLCBkZXN0cm95IHRoZSBleGlzdGluZyBUYWJsZU9ic2VydmVyXG4gICAgICAgICAgICB0YWJsZVNlbGVjdGlvblswXS5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9ucy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgICAgICBpbml0aWFsaXplVGFibGVOb2RlKHRhYmxlTm9kZSwgbm9kZUtleSwgdGFibGVFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobXV0YXRpb24gPT09ICdkZXN0cm95ZWQnKSB7XG4gICAgICAgICAgaWYgKHRhYmxlU2VsZWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRhYmxlU2VsZWN0aW9uWzBdLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgICAgdGFibGVTZWxlY3Rpb25zLmRlbGV0ZShub2RlS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBlZGl0b3JcbiAgICB9KTtcbiAgfSwge1xuICAgIHNraXBJbml0aWFsaXphdGlvbjogZmFsc2VcbiAgfSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgdW5yZWdpc3Rlck11dGF0aW9uTGlzdGVuZXIoKTtcbiAgICAvLyBIb29rIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBzbyBjbGVhbmluZyB1cCB0YWJsZXMgbGlzdGVuZXJzIGFzIHdlbGwsXG4gICAgLy8gYXMgaXQnbGwgYmUgcmVpbml0aWFsaXplZCBkdXJpbmcgcmVjdXJyaW5nIGNhbGxcbiAgICBmb3IgKGNvbnN0IFssIFt0YWJsZVNlbGVjdGlvbl1dIG9mIHRhYmxlU2VsZWN0aW9ucykge1xuICAgICAgdGFibGVTZWxlY3Rpb24ucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyIHRoZSBJTlNFUlRfVEFCTEVfQ09NTUFORCBsaXN0ZW5lciBhbmQgdGhlIHRhYmxlIGludGVncml0eSB0cmFuc2Zvcm1zLiBUaGVcbiAqIHRhYmxlIHNlbGVjdGlvbiBvYnNlcnZlciBzaG91bGQgYmUgcmVnaXN0ZXJlZCBzZXBhcmF0ZWx5IGFmdGVyIHRoaXMgd2l0aFxuICoge0BsaW5rIHJlZ2lzdGVyVGFibGVTZWxlY3Rpb25PYnNlcnZlcn0uXG4gKlxuICogQHBhcmFtIGVkaXRvciBUaGUgZWRpdG9yXG4gKiBAcmV0dXJucyBBbiB1bnJlZ2lzdGVyIGNhbGxiYWNrXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyVGFibGVQbHVnaW4oZWRpdG9yKSB7XG4gIGlmICghZWRpdG9yLmhhc05vZGVzKFtUYWJsZU5vZGVdKSkge1xuICAgIHtcbiAgICAgIGZvcm1hdERldkVycm9yTWVzc2FnZShgVGFibGVQbHVnaW46IFRhYmxlTm9kZSBpcyBub3QgcmVnaXN0ZXJlZCBvbiBlZGl0b3JgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1lcmdlUmVnaXN0ZXIoZWRpdG9yLnJlZ2lzdGVyQ29tbWFuZChJTlNFUlRfVEFCTEVfQ09NTUFORCwgJGluc2VydFRhYmxlQ29tbWFuZExpc3RlbmVyLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoU0VMRUNUSU9OX0lOU0VSVF9DTElQQk9BUkRfTk9ERVNfQ09NTUFORCwgKHtcbiAgICBub2RlcyxcbiAgICBzZWxlY3Rpb25cbiAgfSwgZGlzcGF0Y2hFZGl0b3IpID0+IHtcbiAgICBpZiAoZWRpdG9yICE9PSBkaXNwYXRjaEVkaXRvciB8fCAhJGlzUmFuZ2VTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBpc0luc2lkZVRhYmxlQ2VsbCA9ICRmaW5kVGFibGVOb2RlKHNlbGVjdGlvbi5hbmNob3IuZ2V0Tm9kZSgpKSAhPT0gbnVsbDtcbiAgICByZXR1cm4gaXNJbnNpZGVUYWJsZUNlbGwgJiYgbm9kZXMuc29tZSgkaXNUYWJsZU5vZGUpO1xuICB9LCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3RlckNvbW1hbmQoQ0xJQ0tfQ09NTUFORCwgJHRhYmxlQ2xpY2tDb21tYW5kLCBDT01NQU5EX1BSSU9SSVRZX0VESVRPUiksIGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0oVGFibGVOb2RlLCAkdGFibGVUcmFuc2Zvcm0pLCBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRhYmxlUm93Tm9kZSwgJHRhYmxlUm93VHJhbnNmb3JtKSwgZWRpdG9yLnJlZ2lzdGVyTm9kZVRyYW5zZm9ybShUYWJsZUNlbGxOb2RlLCAkdGFibGVDZWxsVHJhbnNmb3JtKSk7XG59XG5cbmV4cG9ydCB7ICRjb21wdXRlVGFibGVNYXAsICRjb21wdXRlVGFibGVNYXBTa2lwQ2VsbENoZWNrLCAkY3JlYXRlVGFibGVDZWxsTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZSwgJGNyZWF0ZVRhYmxlTm9kZVdpdGhEaW1lbnNpb25zLCAkY3JlYXRlVGFibGVSb3dOb2RlLCAkY3JlYXRlVGFibGVTZWxlY3Rpb24sICRjcmVhdGVUYWJsZVNlbGVjdGlvbkZyb20sICRkZWxldGVUYWJsZUNvbHVtbiwgJGRlbGV0ZVRhYmxlQ29sdW1uQXRTZWxlY3Rpb24sICRkZWxldGVUYWJsZUNvbHVtbl9fRVhQRVJJTUVOVEFMLCAkZGVsZXRlVGFibGVSb3dBdFNlbGVjdGlvbiwgJGRlbGV0ZVRhYmxlUm93X19FWFBFUklNRU5UQUwsICRmaW5kQ2VsbE5vZGUsICRmaW5kVGFibGVOb2RlLCAkZ2V0RWxlbWVudEZvclRhYmxlTm9kZSwgJGdldE5vZGVUcmlwbGV0LCAkZ2V0VGFibGVBbmRFbGVtZW50QnlLZXksICRnZXRUYWJsZUNlbGxOb2RlRnJvbUxleGljYWxOb2RlLCAkZ2V0VGFibGVDZWxsTm9kZVJlY3QsICRnZXRUYWJsZUNvbHVtbkluZGV4RnJvbVRhYmxlQ2VsbE5vZGUsICRnZXRUYWJsZU5vZGVGcm9tTGV4aWNhbE5vZGVPclRocm93LCAkZ2V0VGFibGVSb3dJbmRleEZyb21UYWJsZUNlbGxOb2RlLCAkZ2V0VGFibGVSb3dOb2RlRnJvbVRhYmxlQ2VsbE5vZGVPclRocm93LCAkaW5zZXJ0VGFibGVDb2x1bW4sICRpbnNlcnRUYWJsZUNvbHVtbkF0U2VsZWN0aW9uLCAkaW5zZXJ0VGFibGVDb2x1bW5fX0VYUEVSSU1FTlRBTCwgJGluc2VydFRhYmxlUm93LCAkaW5zZXJ0VGFibGVSb3dBdFNlbGVjdGlvbiwgJGluc2VydFRhYmxlUm93X19FWFBFUklNRU5UQUwsICRpc1Njcm9sbGFibGVUYWJsZXNBY3RpdmUsICRpc1RhYmxlQ2VsbE5vZGUsICRpc1RhYmxlTm9kZSwgJGlzVGFibGVSb3dOb2RlLCAkaXNUYWJsZVNlbGVjdGlvbiwgJG1lcmdlQ2VsbHMsICRyZW1vdmVUYWJsZVJvd0F0SW5kZXgsICR1bm1lcmdlQ2VsbCwgSU5TRVJUX1RBQkxFX0NPTU1BTkQsIFRhYmxlQ2VsbEhlYWRlclN0YXRlcywgVGFibGVDZWxsTm9kZSwgVGFibGVOb2RlLCBUYWJsZU9ic2VydmVyLCBUYWJsZVJvd05vZGUsIGFwcGx5VGFibGVIYW5kbGVycywgZ2V0RE9NQ2VsbEZyb21UYXJnZXQsIGdldFRhYmxlRWxlbWVudCwgZ2V0VGFibGVPYnNlcnZlckZyb21UYWJsZUVsZW1lbnQsIHJlZ2lzdGVyVGFibGVDZWxsVW5tZXJnZVRyYW5zZm9ybSwgcmVnaXN0ZXJUYWJsZVBsdWdpbiwgcmVnaXN0ZXJUYWJsZVNlbGVjdGlvbk9ic2VydmVyLCBzZXRTY3JvbGxhYmxlVGFibGVzQWN0aXZlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+table@0.35.0/node_modules/@lexical/table/LexicalTable.dev.mjs\n");

/***/ })

};
;