"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+link@0.35.0";
exports.ids = ["vendor-chunks/@lexical+link@0.35.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+link@0.35.0/node_modules/@lexical/link/LexicalLink.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+link@0.35.0/node_modules/@lexical/link/LexicalLink.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $createAutoLinkNode: () => (/* binding */ $createAutoLinkNode),\n/* harmony export */   $createLinkNode: () => (/* binding */ $createLinkNode),\n/* harmony export */   $isAutoLinkNode: () => (/* binding */ $isAutoLinkNode),\n/* harmony export */   $isLinkNode: () => (/* binding */ $isLinkNode),\n/* harmony export */   $toggleLink: () => (/* binding */ $toggleLink),\n/* harmony export */   AutoLinkNode: () => (/* binding */ AutoLinkNode),\n/* harmony export */   LinkNode: () => (/* binding */ LinkNode),\n/* harmony export */   TOGGLE_LINK_COMMAND: () => (/* binding */ TOGGLE_LINK_COMMAND),\n/* harmony export */   formatUrl: () => (/* binding */ formatUrl),\n/* harmony export */   toggleLink: () => (/* binding */ toggleLink)\n/* harmony export */ });\n/* harmony import */ var _lexical_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lexical/utils */ \"(ssr)/./node_modules/.pnpm/@lexical+utils@0.35.0/node_modules/@lexical/utils/LexicalUtils.dev.mjs\");\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\nconst SUPPORTED_URL_PROTOCOLS = new Set(['http:', 'https:', 'mailto:', 'sms:', 'tel:']);\n\n/** @noInheritDoc */\nclass LinkNode extends lexical__WEBPACK_IMPORTED_MODULE_0__.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  static getType() {\n    return 'link';\n  }\n  static clone(node) {\n    return new LinkNode(node.__url, {\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  constructor(url = '', attributes = {}, key) {\n    super(key);\n    const {\n      target = null,\n      rel = null,\n      title = null\n    } = attributes;\n    this.__url = url;\n    this.__target = target;\n    this.__rel = rel;\n    this.__title = title;\n  }\n  createDOM(config) {\n    const element = document.createElement('a');\n    this.updateLinkDOM(null, element, config);\n    (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.addClassNamesToElement)(element, config.theme.link);\n    return element;\n  }\n  updateLinkDOM(prevNode, anchor, config) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(anchor)) {\n      if (!prevNode || prevNode.__url !== this.__url) {\n        anchor.href = this.sanitizeUrl(this.__url);\n      }\n      for (const attr of ['target', 'rel', 'title']) {\n        const key = `__${attr}`;\n        const value = this[key];\n        if (!prevNode || prevNode[key] !== value) {\n          if (value) {\n            anchor[attr] = value;\n          } else {\n            anchor.removeAttribute(attr);\n          }\n        }\n      }\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    this.updateLinkDOM(prevNode, anchor, config);\n    return false;\n  }\n  static importDOM() {\n    return {\n      a: node => ({\n        conversion: $convertAnchorElement,\n        priority: 1\n      })\n    };\n  }\n  static importJSON(serializedNode) {\n    return $createLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setURL(serializedNode.url).setRel(serializedNode.rel || null).setTarget(serializedNode.target || null).setTitle(serializedNode.title || null);\n  }\n  sanitizeUrl(url) {\n    url = formatUrl(url);\n    try {\n      const parsedUrl = new URL(formatUrl(url));\n      // eslint-disable-next-line no-script-url\n      if (!SUPPORTED_URL_PROTOCOLS.has(parsedUrl.protocol)) {\n        return 'about:blank';\n      }\n    } catch (_unused) {\n      return url;\n    }\n    return url;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      rel: this.getRel(),\n      target: this.getTarget(),\n      title: this.getTitle(),\n      url: this.getURL()\n    };\n  }\n  getURL() {\n    return this.getLatest().__url;\n  }\n  setURL(url) {\n    const writable = this.getWritable();\n    writable.__url = url;\n    return writable;\n  }\n  getTarget() {\n    return this.getLatest().__target;\n  }\n  setTarget(target) {\n    const writable = this.getWritable();\n    writable.__target = target;\n    return writable;\n  }\n  getRel() {\n    return this.getLatest().__rel;\n  }\n  setRel(rel) {\n    const writable = this.getWritable();\n    writable.__rel = rel;\n    return writable;\n  }\n  getTitle() {\n    return this.getLatest().__title;\n  }\n  setTitle(title) {\n    const writable = this.getWritable();\n    writable.__title = title;\n    return writable;\n  }\n  insertNewAfter(_, restoreSelection = true) {\n    const linkNode = $createLinkNode(this.__url, {\n      rel: this.__rel,\n      target: this.__target,\n      title: this.__title\n    });\n    this.insertAfter(linkNode, restoreSelection);\n    return linkNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection)) {\n      return false;\n    }\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && selection.getTextContent().length > 0;\n  }\n  isEmailURI() {\n    return this.__url.startsWith('mailto:');\n  }\n  isWebSiteURI() {\n    return this.__url.startsWith('https://') || this.__url.startsWith('http://');\n  }\n}\nfunction $convertAnchorElement(domNode) {\n  let node = null;\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.isHTMLAnchorElement)(domNode)) {\n    const content = domNode.textContent;\n    if (content !== null && content !== '' || domNode.children.length > 0) {\n      node = $createLinkNode(domNode.getAttribute('href') || '', {\n        rel: domNode.getAttribute('rel'),\n        target: domNode.getAttribute('target'),\n        title: domNode.getAttribute('title')\n      });\n    }\n  }\n  return {\n    node\n  };\n}\n\n/**\n * Takes a URL and creates a LinkNode.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new LinkNode(url, attributes));\n}\n\n/**\n * Determines if node is a LinkNode.\n * @param node - The node to be checked.\n * @returns true if node is a LinkNode, false otherwise.\n */\nfunction $isLinkNode(node) {\n  return node instanceof LinkNode;\n}\n// Custom node type to override `canInsertTextAfter` that will\n// allow typing within the link\nclass AutoLinkNode extends LinkNode {\n  /** @internal */\n  /** Indicates whether the autolink was ever unlinked. **/\n\n  constructor(url = '', attributes = {}, key) {\n    super(url, attributes, key);\n    this.__isUnlinked = attributes.isUnlinked !== undefined && attributes.isUnlinked !== null ? attributes.isUnlinked : false;\n  }\n  static getType() {\n    return 'autolink';\n  }\n  static clone(node) {\n    return new AutoLinkNode(node.__url, {\n      isUnlinked: node.__isUnlinked,\n      rel: node.__rel,\n      target: node.__target,\n      title: node.__title\n    }, node.__key);\n  }\n  getIsUnlinked() {\n    return this.__isUnlinked;\n  }\n  setIsUnlinked(value) {\n    const self = this.getWritable();\n    self.__isUnlinked = value;\n    return self;\n  }\n  createDOM(config) {\n    if (this.__isUnlinked) {\n      return document.createElement('span');\n    } else {\n      return super.createDOM(config);\n    }\n  }\n  updateDOM(prevNode, anchor, config) {\n    return super.updateDOM(prevNode, anchor, config) || prevNode.__isUnlinked !== this.__isUnlinked;\n  }\n  static importJSON(serializedNode) {\n    return $createAutoLinkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIsUnlinked(serializedNode.isUnlinked || false);\n  }\n  static importDOM() {\n    // TODO: Should link node should handle the import over autolink?\n    return null;\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      isUnlinked: this.__isUnlinked\n    };\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const element = this.getParentOrThrow().insertNewAfter(selection, restoreSelection);\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(element)) {\n      const linkNode = $createAutoLinkNode(this.__url, {\n        isUnlinked: this.__isUnlinked,\n        rel: this.__rel,\n        target: this.__target,\n        title: this.__title\n      });\n      element.append(linkNode);\n      return linkNode;\n    }\n    return null;\n  }\n}\n\n/**\n * Takes a URL and creates an AutoLinkNode. AutoLinkNodes are generally automatically generated\n * during typing, which is especially useful when a button to generate a LinkNode is not practical.\n * @param url - The URL the LinkNode should direct to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n * @returns The LinkNode.\n */\nfunction $createAutoLinkNode(url = '', attributes) {\n  return (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$applyNodeReplacement)(new AutoLinkNode(url, attributes));\n}\n\n/**\n * Determines if node is an AutoLinkNode.\n * @param node - The node to be checked.\n * @returns true if node is an AutoLinkNode, false otherwise.\n */\nfunction $isAutoLinkNode(node) {\n  return node instanceof AutoLinkNode;\n}\nconst TOGGLE_LINK_COMMAND = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.createCommand)('TOGGLE_LINK_COMMAND');\nfunction $getPointNode(point, offset) {\n  if (point.type === 'element') {\n    const node = point.getNode();\n    if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      formatDevErrorMessage(`$getPointNode: element point is not an ElementNode`);\n    }\n    const childNode = node.getChildren()[point.offset + offset];\n    return childNode || null;\n  }\n  return null;\n}\n\n/**\n * Preserve the logical start/end of a RangeSelection in situations where\n * the point is an element that may be reparented in the callback.\n *\n * @param $fn The function to run\n * @returns The result of the callback\n */\nfunction $withSelectedNodes($fn) {\n  const initialSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(initialSelection)) {\n    return $fn();\n  }\n  const normalized = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(initialSelection);\n  const isBackwards = normalized.isBackward();\n  const anchorNode = $getPointNode(normalized.anchor, isBackwards ? -1 : 0);\n  const focusNode = $getPointNode(normalized.focus, isBackwards ? 0 : -1);\n  const rval = $fn();\n  if (anchorNode || focusNode) {\n    const updatedSelection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(updatedSelection)) {\n      const finalSelection = updatedSelection.clone();\n      if (anchorNode) {\n        const anchorParent = anchorNode.getParent();\n        if (anchorParent) {\n          finalSelection.anchor.set(anchorParent.getKey(), anchorNode.getIndexWithinParent() + (isBackwards ? 1 : 0), 'element');\n        }\n      }\n      if (focusNode) {\n        const focusParent = focusNode.getParent();\n        if (focusParent) {\n          finalSelection.focus.set(focusParent.getKey(), focusNode.getIndexWithinParent() + (isBackwards ? 0 : 1), 'element');\n        }\n      }\n      (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$setSelection)((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$normalizeSelection__EXPERIMENTAL)(finalSelection));\n    }\n  }\n  return rval;\n}\n\n/**\n * Generates or updates a LinkNode. It can also delete a LinkNode if the URL is null,\n * but saves any children and brings them up to the parent node.\n * @param url - The URL the link directs to.\n * @param attributes - Optional HTML a tag attributes. \\\\{ target, rel, title \\\\}\n */\nfunction $toggleLink(url, attributes = {}) {\n  const {\n    target,\n    title\n  } = attributes;\n  const rel = attributes.rel === undefined ? 'noreferrer' : attributes.rel;\n  const selection = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getSelection)();\n  if (selection === null || !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isRangeSelection)(selection) && !(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    return;\n  }\n  if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isNodeSelection)(selection)) {\n    const nodes = selection.getNodes();\n    if (nodes.length === 0) {\n      return;\n    }\n\n    // Handle all selected nodes\n    nodes.forEach(node => {\n      if (url === null) {\n        // Remove link\n        const linkParent = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (linkParent) {\n          linkParent.insertBefore(node);\n          if (linkParent.getChildren().length === 0) {\n            linkParent.remove();\n          }\n        }\n      } else {\n        // Add/Update link\n        const existingLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n        if (existingLink) {\n          existingLink.setURL(url);\n          if (target !== undefined) {\n            existingLink.setTarget(target);\n          }\n          if (rel !== undefined) {\n            existingLink.setRel(rel);\n          }\n        } else {\n          const linkNode = $createLinkNode(url, {\n            rel,\n            target\n          });\n          node.insertBefore(linkNode);\n          linkNode.append(node);\n        }\n      }\n    });\n    return;\n  }\n\n  // Handle RangeSelection\n  const nodes = selection.extract();\n  if (url === null) {\n    // Remove LinkNodes\n    nodes.forEach(node => {\n      const parentLink = (0,_lexical_utils__WEBPACK_IMPORTED_MODULE_1__.$findMatchingParent)(node, parent => !$isAutoLinkNode(parent) && $isLinkNode(parent));\n      if (parentLink) {\n        const children = parentLink.getChildren();\n        for (let i = 0; i < children.length; i++) {\n          parentLink.insertBefore(children[i]);\n        }\n        parentLink.remove();\n      }\n    });\n    return;\n  }\n  const updatedNodes = new Set();\n  const updateLinkNode = linkNode => {\n    if (updatedNodes.has(linkNode.getKey())) {\n      return;\n    }\n    updatedNodes.add(linkNode.getKey());\n    linkNode.setURL(url);\n    if (target !== undefined) {\n      linkNode.setTarget(target);\n    }\n    if (rel !== undefined) {\n      linkNode.setRel(rel);\n    }\n    if (title !== undefined) {\n      linkNode.setTitle(title);\n    }\n  };\n  // Add or merge LinkNodes\n  if (nodes.length === 1) {\n    const firstNode = nodes[0];\n    // if the first node is a LinkNode or if its\n    // parent is a LinkNode, we update the URL, target and rel.\n    const linkNode = $getAncestor(firstNode, $isLinkNode);\n    if (linkNode !== null) {\n      return updateLinkNode(linkNode);\n    }\n  }\n  $withSelectedNodes(() => {\n    let linkNode = null;\n    for (const node of nodes) {\n      if (!node.isAttached()) {\n        continue;\n      }\n      const parentLinkNode = $getAncestor(node, $isLinkNode);\n      if (parentLinkNode) {\n        updateLinkNode(parentLinkNode);\n        continue;\n      }\n      if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n        if (!node.isInline()) {\n          // Ignore block nodes, if there are any children we will see them\n          // later and wrap in a new LinkNode\n          continue;\n        }\n        if ($isLinkNode(node)) {\n          // If it's not an autolink node and we don't already have a LinkNode\n          // in this block then we can update it and re-use it\n          if (!$isAutoLinkNode(node) && (linkNode === null || !linkNode.getParentOrThrow().isParentOf(node))) {\n            updateLinkNode(node);\n            linkNode = node;\n            continue;\n          }\n          // Unwrap LinkNode, we already have one or it's an AutoLinkNode\n          for (const child of node.getChildren()) {\n            node.insertBefore(child);\n          }\n          node.remove();\n          continue;\n        }\n      }\n      const prevLinkNode = node.getPreviousSibling();\n      if ($isLinkNode(prevLinkNode) && prevLinkNode.is(linkNode)) {\n        prevLinkNode.append(node);\n        continue;\n      }\n      linkNode = $createLinkNode(url, {\n        rel,\n        target,\n        title\n      });\n      node.insertAfter(linkNode);\n      linkNode.append(node);\n    }\n  });\n}\n/** @deprecated renamed to {@link $toggleLink} by @lexical/eslint-plugin rules-of-lexical */\nconst toggleLink = $toggleLink;\nfunction $getAncestor(node, predicate) {\n  let parent = node;\n  while (parent !== null && parent.getParent() !== null && !predicate(parent)) {\n    parent = parent.getParentOrThrow();\n  }\n  return predicate(parent) ? parent : null;\n}\nconst PHONE_NUMBER_REGEX = /^\\+?[0-9\\s()-]{5,}$/;\n\n/**\n * Formats a URL string by adding appropriate protocol if missing\n *\n * @param url - URL to format\n * @returns Formatted URL with appropriate protocol\n */\nfunction formatUrl(url) {\n  // Check if URL already has a protocol\n  if (url.match(/^[a-z][a-z0-9+.-]*:/i)) {\n    // URL already has a protocol, leave it as is\n    return url;\n  }\n  // Check if it's a relative path (starting with '/', '.', or '#')\n  else if (url.match(/^[/#.]/)) {\n    // Relative path, leave it as is\n    return url;\n  }\n\n  // Check for email address\n  else if (url.includes('@')) {\n    return `mailto:${url}`;\n  }\n\n  // Check for phone number\n  else if (PHONE_NUMBER_REGEX.test(url)) {\n    return `tel:${url}`;\n  }\n\n  // For everything else, return with https:// prefix\n  return `https://${url}`;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlua0AwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFa0c7QUFDZ0c7O0FBRWxNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVCQUF1QixnREFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksc0VBQXNCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNERBQW1CO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDBEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDREQUFtQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLDhEQUFxQjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLFNBQVMsOERBQXFCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQWE7QUFDekM7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNEQUFhO0FBQ3hDLE9BQU8sMERBQWlCO0FBQ3hCO0FBQ0E7QUFDQSxxQkFBcUIsMEVBQWlDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQWE7QUFDMUMsUUFBUSwwREFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNEQUFhLENBQUMsMEVBQWlDO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLG9CQUFvQixzREFBYTtBQUNqQyw2QkFBNkIsMERBQWlCLGdCQUFnQix5REFBZ0I7QUFDOUU7QUFDQTtBQUNBLE1BQU0seURBQWdCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG1FQUFtQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSw2QkFBNkIsbUVBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtRUFBbUI7QUFDNUM7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHVEQUFjO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsR0FBRzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLElBQUk7QUFDekI7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixJQUFJO0FBQ3RCOztBQUVBO0FBQ0Esb0JBQW9CLElBQUk7QUFDeEI7O0FBRStKIiwic291cmNlcyI6WyIvVXNlcnMvbWFjL1N5bmMvcHJvamVjdC9lY29tbWVyY2Uvc2hvcHNhYXMvaHRtbGNvbnZlcnRlci9wYXlsb2Fkc2Fhcy9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrbGlua0AwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL2xpbmsvTGV4aWNhbExpbmsuZGV2Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbmltcG9ydCB7IGFkZENsYXNzTmFtZXNUb0VsZW1lbnQsIGlzSFRNTEFuY2hvckVsZW1lbnQsICRmaW5kTWF0Y2hpbmdQYXJlbnQgfSBmcm9tICdAbGV4aWNhbC91dGlscyc7XG5pbXBvcnQgeyBjcmVhdGVDb21tYW5kLCBFbGVtZW50Tm9kZSwgJGlzUmFuZ2VTZWxlY3Rpb24sICRhcHBseU5vZGVSZXBsYWNlbWVudCwgJGlzRWxlbWVudE5vZGUsICRnZXRTZWxlY3Rpb24sICRpc05vZGVTZWxlY3Rpb24sICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTCwgJHNldFNlbGVjdGlvbiB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8vIERvIG5vdCByZXF1aXJlIHRoaXMgbW9kdWxlIGRpcmVjdGx5ISBVc2Ugbm9ybWFsIGBpbnZhcmlhbnRgIGNhbGxzLlxuXG5mdW5jdGlvbiBmb3JtYXREZXZFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5cbmNvbnN0IFNVUFBPUlRFRF9VUkxfUFJPVE9DT0xTID0gbmV3IFNldChbJ2h0dHA6JywgJ2h0dHBzOicsICdtYWlsdG86JywgJ3NtczonLCAndGVsOiddKTtcblxuLyoqIEBub0luaGVyaXREb2MgKi9cbmNsYXNzIExpbmtOb2RlIGV4dGVuZHMgRWxlbWVudE5vZGUge1xuICAvKiogQGludGVybmFsICovXG5cbiAgLyoqIEBpbnRlcm5hbCAqL1xuXG4gIC8qKiBAaW50ZXJuYWwgKi9cblxuICAvKiogQGludGVybmFsICovXG5cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdsaW5rJztcbiAgfVxuICBzdGF0aWMgY2xvbmUobm9kZSkge1xuICAgIHJldHVybiBuZXcgTGlua05vZGUobm9kZS5fX3VybCwge1xuICAgICAgcmVsOiBub2RlLl9fcmVsLFxuICAgICAgdGFyZ2V0OiBub2RlLl9fdGFyZ2V0LFxuICAgICAgdGl0bGU6IG5vZGUuX190aXRsZVxuICAgIH0sIG5vZGUuX19rZXkpO1xuICB9XG4gIGNvbnN0cnVjdG9yKHVybCA9ICcnLCBhdHRyaWJ1dGVzID0ge30sIGtleSkge1xuICAgIHN1cGVyKGtleSk7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0ID0gbnVsbCxcbiAgICAgIHJlbCA9IG51bGwsXG4gICAgICB0aXRsZSA9IG51bGxcbiAgICB9ID0gYXR0cmlidXRlcztcbiAgICB0aGlzLl9fdXJsID0gdXJsO1xuICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5fX3JlbCA9IHJlbDtcbiAgICB0aGlzLl9fdGl0bGUgPSB0aXRsZTtcbiAgfVxuICBjcmVhdGVET00oY29uZmlnKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICB0aGlzLnVwZGF0ZUxpbmtET00obnVsbCwgZWxlbWVudCwgY29uZmlnKTtcbiAgICBhZGRDbGFzc05hbWVzVG9FbGVtZW50KGVsZW1lbnQsIGNvbmZpZy50aGVtZS5saW5rKTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICB1cGRhdGVMaW5rRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KGFuY2hvcikpIHtcbiAgICAgIGlmICghcHJldk5vZGUgfHwgcHJldk5vZGUuX191cmwgIT09IHRoaXMuX191cmwpIHtcbiAgICAgICAgYW5jaG9yLmhyZWYgPSB0aGlzLnNhbml0aXplVXJsKHRoaXMuX191cmwpO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhdHRyIG9mIFsndGFyZ2V0JywgJ3JlbCcsICd0aXRsZSddKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGBfXyR7YXR0cn1gO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXNba2V5XTtcbiAgICAgICAgaWYgKCFwcmV2Tm9kZSB8fCBwcmV2Tm9kZVtrZXldICE9PSB2YWx1ZSkge1xuICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgYW5jaG9yW2F0dHJdID0gdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvci5yZW1vdmVBdHRyaWJ1dGUoYXR0cik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZURPTShwcmV2Tm9kZSwgYW5jaG9yLCBjb25maWcpIHtcbiAgICB0aGlzLnVwZGF0ZUxpbmtET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYTogbm9kZSA9PiAoe1xuICAgICAgICBjb252ZXJzaW9uOiAkY29udmVydEFuY2hvckVsZW1lbnQsXG4gICAgICAgIHByaW9yaXR5OiAxXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGltcG9ydEpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gJGNyZWF0ZUxpbmtOb2RlKCkudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpO1xuICB9XG4gIHVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuIHN1cGVyLnVwZGF0ZUZyb21KU09OKHNlcmlhbGl6ZWROb2RlKS5zZXRVUkwoc2VyaWFsaXplZE5vZGUudXJsKS5zZXRSZWwoc2VyaWFsaXplZE5vZGUucmVsIHx8IG51bGwpLnNldFRhcmdldChzZXJpYWxpemVkTm9kZS50YXJnZXQgfHwgbnVsbCkuc2V0VGl0bGUoc2VyaWFsaXplZE5vZGUudGl0bGUgfHwgbnVsbCk7XG4gIH1cbiAgc2FuaXRpemVVcmwodXJsKSB7XG4gICAgdXJsID0gZm9ybWF0VXJsKHVybCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZFVybCA9IG5ldyBVUkwoZm9ybWF0VXJsKHVybCkpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNjcmlwdC11cmxcbiAgICAgIGlmICghU1VQUE9SVEVEX1VSTF9QUk9UT0NPTFMuaGFzKHBhcnNlZFVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgcmV0dXJuICdhYm91dDpibGFuayc7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgcmV0dXJuIHVybDtcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICBleHBvcnRKU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5zdXBlci5leHBvcnRKU09OKCksXG4gICAgICByZWw6IHRoaXMuZ2V0UmVsKCksXG4gICAgICB0YXJnZXQ6IHRoaXMuZ2V0VGFyZ2V0KCksXG4gICAgICB0aXRsZTogdGhpcy5nZXRUaXRsZSgpLFxuICAgICAgdXJsOiB0aGlzLmdldFVSTCgpXG4gICAgfTtcbiAgfVxuICBnZXRVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX191cmw7XG4gIH1cbiAgc2V0VVJMKHVybCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdXJsID0gdXJsO1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfVxuICBnZXRUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX190YXJnZXQ7XG4gIH1cbiAgc2V0VGFyZ2V0KHRhcmdldCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfVxuICBnZXRSZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0KCkuX19yZWw7XG4gIH1cbiAgc2V0UmVsKHJlbCkge1xuICAgIGNvbnN0IHdyaXRhYmxlID0gdGhpcy5nZXRXcml0YWJsZSgpO1xuICAgIHdyaXRhYmxlLl9fcmVsID0gcmVsO1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfVxuICBnZXRUaXRsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMYXRlc3QoKS5fX3RpdGxlO1xuICB9XG4gIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgY29uc3Qgd3JpdGFibGUgPSB0aGlzLmdldFdyaXRhYmxlKCk7XG4gICAgd3JpdGFibGUuX190aXRsZSA9IHRpdGxlO1xuICAgIHJldHVybiB3cml0YWJsZTtcbiAgfVxuICBpbnNlcnROZXdBZnRlcihfLCByZXN0b3JlU2VsZWN0aW9uID0gdHJ1ZSkge1xuICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHRoaXMuX191cmwsIHtcbiAgICAgIHJlbDogdGhpcy5fX3JlbCxcbiAgICAgIHRhcmdldDogdGhpcy5fX3RhcmdldCxcbiAgICAgIHRpdGxlOiB0aGlzLl9fdGl0bGVcbiAgICB9KTtcbiAgICB0aGlzLmluc2VydEFmdGVyKGxpbmtOb2RlLCByZXN0b3JlU2VsZWN0aW9uKTtcbiAgICByZXR1cm4gbGlua05vZGU7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEJlZm9yZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY2FuSW5zZXJ0VGV4dEFmdGVyKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjYW5CZUVtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpc0lubGluZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBleHRyYWN0V2l0aENoaWxkKGNoaWxkLCBzZWxlY3Rpb24sIGRlc3RpbmF0aW9uKSB7XG4gICAgaWYgKCEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yLmdldE5vZGUoKTtcbiAgICBjb25zdCBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXMuZ2V0Tm9kZSgpO1xuICAgIHJldHVybiB0aGlzLmlzUGFyZW50T2YoYW5jaG9yTm9kZSkgJiYgdGhpcy5pc1BhcmVudE9mKGZvY3VzTm9kZSkgJiYgc2VsZWN0aW9uLmdldFRleHRDb250ZW50KCkubGVuZ3RoID4gMDtcbiAgfVxuICBpc0VtYWlsVVJJKCkge1xuICAgIHJldHVybiB0aGlzLl9fdXJsLnN0YXJ0c1dpdGgoJ21haWx0bzonKTtcbiAgfVxuICBpc1dlYlNpdGVVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX191cmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSB8fCB0aGlzLl9fdXJsLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKTtcbiAgfVxufVxuZnVuY3Rpb24gJGNvbnZlcnRBbmNob3JFbGVtZW50KGRvbU5vZGUpIHtcbiAgbGV0IG5vZGUgPSBudWxsO1xuICBpZiAoaXNIVE1MQW5jaG9yRWxlbWVudChkb21Ob2RlKSkge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBkb21Ob2RlLnRleHRDb250ZW50O1xuICAgIGlmIChjb250ZW50ICE9PSBudWxsICYmIGNvbnRlbnQgIT09ICcnIHx8IGRvbU5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgbm9kZSA9ICRjcmVhdGVMaW5rTm9kZShkb21Ob2RlLmdldEF0dHJpYnV0ZSgnaHJlZicpIHx8ICcnLCB7XG4gICAgICAgIHJlbDogZG9tTm9kZS5nZXRBdHRyaWJ1dGUoJ3JlbCcpLFxuICAgICAgICB0YXJnZXQ6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0YXJnZXQnKSxcbiAgICAgICAgdGl0bGU6IGRvbU5vZGUuZ2V0QXR0cmlidXRlKCd0aXRsZScpXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBub2RlXG4gIH07XG59XG5cbi8qKlxuICogVGFrZXMgYSBVUkwgYW5kIGNyZWF0ZXMgYSBMaW5rTm9kZS5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBMaW5rTm9kZSBzaG91bGQgZGlyZWN0IHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMgXFxcXHsgdGFyZ2V0LCByZWwsIHRpdGxlIFxcXFx9XG4gKiBAcmV0dXJucyBUaGUgTGlua05vZGUuXG4gKi9cbmZ1bmN0aW9uICRjcmVhdGVMaW5rTm9kZSh1cmwgPSAnJywgYXR0cmlidXRlcykge1xuICByZXR1cm4gJGFwcGx5Tm9kZVJlcGxhY2VtZW50KG5ldyBMaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG5vZGUgaXMgYSBMaW5rTm9kZS5cbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gYmUgY2hlY2tlZC5cbiAqIEByZXR1cm5zIHRydWUgaWYgbm9kZSBpcyBhIExpbmtOb2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uICRpc0xpbmtOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBMaW5rTm9kZTtcbn1cbi8vIEN1c3RvbSBub2RlIHR5cGUgdG8gb3ZlcnJpZGUgYGNhbkluc2VydFRleHRBZnRlcmAgdGhhdCB3aWxsXG4vLyBhbGxvdyB0eXBpbmcgd2l0aGluIHRoZSBsaW5rXG5jbGFzcyBBdXRvTGlua05vZGUgZXh0ZW5kcyBMaW5rTm9kZSB7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgLyoqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBhdXRvbGluayB3YXMgZXZlciB1bmxpbmtlZC4gKiovXG5cbiAgY29uc3RydWN0b3IodXJsID0gJycsIGF0dHJpYnV0ZXMgPSB7fSwga2V5KSB7XG4gICAgc3VwZXIodXJsLCBhdHRyaWJ1dGVzLCBrZXkpO1xuICAgIHRoaXMuX19pc1VubGlua2VkID0gYXR0cmlidXRlcy5pc1VubGlua2VkICE9PSB1bmRlZmluZWQgJiYgYXR0cmlidXRlcy5pc1VubGlua2VkICE9PSBudWxsID8gYXR0cmlidXRlcy5pc1VubGlua2VkIDogZmFsc2U7XG4gIH1cbiAgc3RhdGljIGdldFR5cGUoKSB7XG4gICAgcmV0dXJuICdhdXRvbGluayc7XG4gIH1cbiAgc3RhdGljIGNsb25lKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IEF1dG9MaW5rTm9kZShub2RlLl9fdXJsLCB7XG4gICAgICBpc1VubGlua2VkOiBub2RlLl9faXNVbmxpbmtlZCxcbiAgICAgIHJlbDogbm9kZS5fX3JlbCxcbiAgICAgIHRhcmdldDogbm9kZS5fX3RhcmdldCxcbiAgICAgIHRpdGxlOiBub2RlLl9fdGl0bGVcbiAgICB9LCBub2RlLl9fa2V5KTtcbiAgfVxuICBnZXRJc1VubGlua2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9faXNVbmxpbmtlZDtcbiAgfVxuICBzZXRJc1VubGlua2VkKHZhbHVlKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXMuZ2V0V3JpdGFibGUoKTtcbiAgICBzZWxmLl9faXNVbmxpbmtlZCA9IHZhbHVlO1xuICAgIHJldHVybiBzZWxmO1xuICB9XG4gIGNyZWF0ZURPTShjb25maWcpIHtcbiAgICBpZiAodGhpcy5fX2lzVW5saW5rZWQpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzdXBlci5jcmVhdGVET00oY29uZmlnKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlRE9NKHByZXZOb2RlLCBhbmNob3IsIGNvbmZpZykge1xuICAgIHJldHVybiBzdXBlci51cGRhdGVET00ocHJldk5vZGUsIGFuY2hvciwgY29uZmlnKSB8fCBwcmV2Tm9kZS5fX2lzVW5saW5rZWQgIT09IHRoaXMuX19pc1VubGlua2VkO1xuICB9XG4gIHN0YXRpYyBpbXBvcnRKU09OKHNlcmlhbGl6ZWROb2RlKSB7XG4gICAgcmV0dXJuICRjcmVhdGVBdXRvTGlua05vZGUoKS51cGRhdGVGcm9tSlNPTihzZXJpYWxpemVkTm9kZSk7XG4gIH1cbiAgdXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpIHtcbiAgICByZXR1cm4gc3VwZXIudXBkYXRlRnJvbUpTT04oc2VyaWFsaXplZE5vZGUpLnNldElzVW5saW5rZWQoc2VyaWFsaXplZE5vZGUuaXNVbmxpbmtlZCB8fCBmYWxzZSk7XG4gIH1cbiAgc3RhdGljIGltcG9ydERPTSgpIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgbGluayBub2RlIHNob3VsZCBoYW5kbGUgdGhlIGltcG9ydCBvdmVyIGF1dG9saW5rP1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGV4cG9ydEpTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN1cGVyLmV4cG9ydEpTT04oKSxcbiAgICAgIGlzVW5saW5rZWQ6IHRoaXMuX19pc1VubGlua2VkXG4gICAgfTtcbiAgfVxuICBpbnNlcnROZXdBZnRlcihzZWxlY3Rpb24sIHJlc3RvcmVTZWxlY3Rpb24gPSB0cnVlKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ2V0UGFyZW50T3JUaHJvdygpLmluc2VydE5ld0FmdGVyKHNlbGVjdGlvbiwgcmVzdG9yZVNlbGVjdGlvbik7XG4gICAgaWYgKCRpc0VsZW1lbnROb2RlKGVsZW1lbnQpKSB7XG4gICAgICBjb25zdCBsaW5rTm9kZSA9ICRjcmVhdGVBdXRvTGlua05vZGUodGhpcy5fX3VybCwge1xuICAgICAgICBpc1VubGlua2VkOiB0aGlzLl9faXNVbmxpbmtlZCxcbiAgICAgICAgcmVsOiB0aGlzLl9fcmVsLFxuICAgICAgICB0YXJnZXQ6IHRoaXMuX190YXJnZXQsXG4gICAgICAgIHRpdGxlOiB0aGlzLl9fdGl0bGVcbiAgICAgIH0pO1xuICAgICAgZWxlbWVudC5hcHBlbmQobGlua05vZGUpO1xuICAgICAgcmV0dXJuIGxpbmtOb2RlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFRha2VzIGEgVVJMIGFuZCBjcmVhdGVzIGFuIEF1dG9MaW5rTm9kZS4gQXV0b0xpbmtOb2RlcyBhcmUgZ2VuZXJhbGx5IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkXG4gKiBkdXJpbmcgdHlwaW5nLCB3aGljaCBpcyBlc3BlY2lhbGx5IHVzZWZ1bCB3aGVuIGEgYnV0dG9uIHRvIGdlbmVyYXRlIGEgTGlua05vZGUgaXMgbm90IHByYWN0aWNhbC5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBMaW5rTm9kZSBzaG91bGQgZGlyZWN0IHRvLlxuICogQHBhcmFtIGF0dHJpYnV0ZXMgLSBPcHRpb25hbCBIVE1MIGEgdGFnIGF0dHJpYnV0ZXMuIFxcXFx7IHRhcmdldCwgcmVsLCB0aXRsZSBcXFxcfVxuICogQHJldHVybnMgVGhlIExpbmtOb2RlLlxuICovXG5mdW5jdGlvbiAkY3JlYXRlQXV0b0xpbmtOb2RlKHVybCA9ICcnLCBhdHRyaWJ1dGVzKSB7XG4gIHJldHVybiAkYXBwbHlOb2RlUmVwbGFjZW1lbnQobmV3IEF1dG9MaW5rTm9kZSh1cmwsIGF0dHJpYnV0ZXMpKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG5vZGUgaXMgYW4gQXV0b0xpbmtOb2RlLlxuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBiZSBjaGVja2VkLlxuICogQHJldHVybnMgdHJ1ZSBpZiBub2RlIGlzIGFuIEF1dG9MaW5rTm9kZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiAkaXNBdXRvTGlua05vZGUobm9kZSkge1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIEF1dG9MaW5rTm9kZTtcbn1cbmNvbnN0IFRPR0dMRV9MSU5LX0NPTU1BTkQgPSBjcmVhdGVDb21tYW5kKCdUT0dHTEVfTElOS19DT01NQU5EJyk7XG5mdW5jdGlvbiAkZ2V0UG9pbnROb2RlKHBvaW50LCBvZmZzZXQpIHtcbiAgaWYgKHBvaW50LnR5cGUgPT09ICdlbGVtZW50Jykge1xuICAgIGNvbnN0IG5vZGUgPSBwb2ludC5nZXROb2RlKCk7XG4gICAgaWYgKCEkaXNFbGVtZW50Tm9kZShub2RlKSkge1xuICAgICAgZm9ybWF0RGV2RXJyb3JNZXNzYWdlKGAkZ2V0UG9pbnROb2RlOiBlbGVtZW50IHBvaW50IGlzIG5vdCBhbiBFbGVtZW50Tm9kZWApO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZE5vZGUgPSBub2RlLmdldENoaWxkcmVuKClbcG9pbnQub2Zmc2V0ICsgb2Zmc2V0XTtcbiAgICByZXR1cm4gY2hpbGROb2RlIHx8IG51bGw7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUHJlc2VydmUgdGhlIGxvZ2ljYWwgc3RhcnQvZW5kIG9mIGEgUmFuZ2VTZWxlY3Rpb24gaW4gc2l0dWF0aW9ucyB3aGVyZVxuICogdGhlIHBvaW50IGlzIGFuIGVsZW1lbnQgdGhhdCBtYXkgYmUgcmVwYXJlbnRlZCBpbiB0aGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtICRmbiBUaGUgZnVuY3Rpb24gdG8gcnVuXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiAkd2l0aFNlbGVjdGVkTm9kZXMoJGZuKSB7XG4gIGNvbnN0IGluaXRpYWxTZWxlY3Rpb24gPSAkZ2V0U2VsZWN0aW9uKCk7XG4gIGlmICghJGlzUmFuZ2VTZWxlY3Rpb24oaW5pdGlhbFNlbGVjdGlvbikpIHtcbiAgICByZXR1cm4gJGZuKCk7XG4gIH1cbiAgY29uc3Qgbm9ybWFsaXplZCA9ICRub3JtYWxpemVTZWxlY3Rpb25fX0VYUEVSSU1FTlRBTChpbml0aWFsU2VsZWN0aW9uKTtcbiAgY29uc3QgaXNCYWNrd2FyZHMgPSBub3JtYWxpemVkLmlzQmFja3dhcmQoKTtcbiAgY29uc3QgYW5jaG9yTm9kZSA9ICRnZXRQb2ludE5vZGUobm9ybWFsaXplZC5hbmNob3IsIGlzQmFja3dhcmRzID8gLTEgOiAwKTtcbiAgY29uc3QgZm9jdXNOb2RlID0gJGdldFBvaW50Tm9kZShub3JtYWxpemVkLmZvY3VzLCBpc0JhY2t3YXJkcyA/IDAgOiAtMSk7XG4gIGNvbnN0IHJ2YWwgPSAkZm4oKTtcbiAgaWYgKGFuY2hvck5vZGUgfHwgZm9jdXNOb2RlKSB7XG4gICAgY29uc3QgdXBkYXRlZFNlbGVjdGlvbiA9ICRnZXRTZWxlY3Rpb24oKTtcbiAgICBpZiAoJGlzUmFuZ2VTZWxlY3Rpb24odXBkYXRlZFNlbGVjdGlvbikpIHtcbiAgICAgIGNvbnN0IGZpbmFsU2VsZWN0aW9uID0gdXBkYXRlZFNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgaWYgKGFuY2hvck5vZGUpIHtcbiAgICAgICAgY29uc3QgYW5jaG9yUGFyZW50ID0gYW5jaG9yTm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKGFuY2hvclBhcmVudCkge1xuICAgICAgICAgIGZpbmFsU2VsZWN0aW9uLmFuY2hvci5zZXQoYW5jaG9yUGFyZW50LmdldEtleSgpLCBhbmNob3JOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAoaXNCYWNrd2FyZHMgPyAxIDogMCksICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb2N1c05vZGUpIHtcbiAgICAgICAgY29uc3QgZm9jdXNQYXJlbnQgPSBmb2N1c05vZGUuZ2V0UGFyZW50KCk7XG4gICAgICAgIGlmIChmb2N1c1BhcmVudCkge1xuICAgICAgICAgIGZpbmFsU2VsZWN0aW9uLmZvY3VzLnNldChmb2N1c1BhcmVudC5nZXRLZXkoKSwgZm9jdXNOb2RlLmdldEluZGV4V2l0aGluUGFyZW50KCkgKyAoaXNCYWNrd2FyZHMgPyAwIDogMSksICdlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgICRzZXRTZWxlY3Rpb24oJG5vcm1hbGl6ZVNlbGVjdGlvbl9fRVhQRVJJTUVOVEFMKGZpbmFsU2VsZWN0aW9uKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBydmFsO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBvciB1cGRhdGVzIGEgTGlua05vZGUuIEl0IGNhbiBhbHNvIGRlbGV0ZSBhIExpbmtOb2RlIGlmIHRoZSBVUkwgaXMgbnVsbCxcbiAqIGJ1dCBzYXZlcyBhbnkgY2hpbGRyZW4gYW5kIGJyaW5ncyB0aGVtIHVwIHRvIHRoZSBwYXJlbnQgbm9kZS5cbiAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRoZSBsaW5rIGRpcmVjdHMgdG8uXG4gKiBAcGFyYW0gYXR0cmlidXRlcyAtIE9wdGlvbmFsIEhUTUwgYSB0YWcgYXR0cmlidXRlcy4gXFxcXHsgdGFyZ2V0LCByZWwsIHRpdGxlIFxcXFx9XG4gKi9cbmZ1bmN0aW9uICR0b2dnbGVMaW5rKHVybCwgYXR0cmlidXRlcyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQsXG4gICAgdGl0bGVcbiAgfSA9IGF0dHJpYnV0ZXM7XG4gIGNvbnN0IHJlbCA9IGF0dHJpYnV0ZXMucmVsID09PSB1bmRlZmluZWQgPyAnbm9yZWZlcnJlcicgOiBhdHRyaWJ1dGVzLnJlbDtcbiAgY29uc3Qgc2VsZWN0aW9uID0gJGdldFNlbGVjdGlvbigpO1xuICBpZiAoc2VsZWN0aW9uID09PSBudWxsIHx8ICEkaXNSYW5nZVNlbGVjdGlvbihzZWxlY3Rpb24pICYmICEkaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCRpc05vZGVTZWxlY3Rpb24oc2VsZWN0aW9uKSkge1xuICAgIGNvbnN0IG5vZGVzID0gc2VsZWN0aW9uLmdldE5vZGVzKCk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBhbGwgc2VsZWN0ZWQgbm9kZXNcbiAgICBub2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgaWYgKHVybCA9PT0gbnVsbCkge1xuICAgICAgICAvLyBSZW1vdmUgbGlua1xuICAgICAgICBjb25zdCBsaW5rUGFyZW50ID0gJGZpbmRNYXRjaGluZ1BhcmVudChub2RlLCBwYXJlbnQgPT4gISRpc0F1dG9MaW5rTm9kZShwYXJlbnQpICYmICRpc0xpbmtOb2RlKHBhcmVudCkpO1xuICAgICAgICBpZiAobGlua1BhcmVudCkge1xuICAgICAgICAgIGxpbmtQYXJlbnQuaW5zZXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgIGlmIChsaW5rUGFyZW50LmdldENoaWxkcmVuKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsaW5rUGFyZW50LnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkL1VwZGF0ZSBsaW5rXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nTGluayA9ICRmaW5kTWF0Y2hpbmdQYXJlbnQobm9kZSwgcGFyZW50ID0+ICEkaXNBdXRvTGlua05vZGUocGFyZW50KSAmJiAkaXNMaW5rTm9kZShwYXJlbnQpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTGluaykge1xuICAgICAgICAgIGV4aXN0aW5nTGluay5zZXRVUkwodXJsKTtcbiAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGV4aXN0aW5nTGluay5zZXRUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleGlzdGluZ0xpbmsuc2V0UmVsKHJlbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHVybCwge1xuICAgICAgICAgICAgcmVsLFxuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUobGlua05vZGUpO1xuICAgICAgICAgIGxpbmtOb2RlLmFwcGVuZChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEhhbmRsZSBSYW5nZVNlbGVjdGlvblxuICBjb25zdCBub2RlcyA9IHNlbGVjdGlvbi5leHRyYWN0KCk7XG4gIGlmICh1cmwgPT09IG51bGwpIHtcbiAgICAvLyBSZW1vdmUgTGlua05vZGVzXG4gICAgbm9kZXMuZm9yRWFjaChub2RlID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudExpbmsgPSAkZmluZE1hdGNoaW5nUGFyZW50KG5vZGUsIHBhcmVudCA9PiAhJGlzQXV0b0xpbmtOb2RlKHBhcmVudCkgJiYgJGlzTGlua05vZGUocGFyZW50KSk7XG4gICAgICBpZiAocGFyZW50TGluaykge1xuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHBhcmVudExpbmsuZ2V0Q2hpbGRyZW4oKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHBhcmVudExpbmsuaW5zZXJ0QmVmb3JlKGNoaWxkcmVuW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJlbnRMaW5rLnJlbW92ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB1cGRhdGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gIGNvbnN0IHVwZGF0ZUxpbmtOb2RlID0gbGlua05vZGUgPT4ge1xuICAgIGlmICh1cGRhdGVkTm9kZXMuaGFzKGxpbmtOb2RlLmdldEtleSgpKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB1cGRhdGVkTm9kZXMuYWRkKGxpbmtOb2RlLmdldEtleSgpKTtcbiAgICBsaW5rTm9kZS5zZXRVUkwodXJsKTtcbiAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpbmtOb2RlLnNldFRhcmdldCh0YXJnZXQpO1xuICAgIH1cbiAgICBpZiAocmVsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGxpbmtOb2RlLnNldFJlbChyZWwpO1xuICAgIH1cbiAgICBpZiAodGl0bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbGlua05vZGUuc2V0VGl0bGUodGl0bGUpO1xuICAgIH1cbiAgfTtcbiAgLy8gQWRkIG9yIG1lcmdlIExpbmtOb2Rlc1xuICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgY29uc3QgZmlyc3ROb2RlID0gbm9kZXNbMF07XG4gICAgLy8gaWYgdGhlIGZpcnN0IG5vZGUgaXMgYSBMaW5rTm9kZSBvciBpZiBpdHNcbiAgICAvLyBwYXJlbnQgaXMgYSBMaW5rTm9kZSwgd2UgdXBkYXRlIHRoZSBVUkwsIHRhcmdldCBhbmQgcmVsLlxuICAgIGNvbnN0IGxpbmtOb2RlID0gJGdldEFuY2VzdG9yKGZpcnN0Tm9kZSwgJGlzTGlua05vZGUpO1xuICAgIGlmIChsaW5rTm9kZSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZUxpbmtOb2RlKGxpbmtOb2RlKTtcbiAgICB9XG4gIH1cbiAgJHdpdGhTZWxlY3RlZE5vZGVzKCgpID0+IHtcbiAgICBsZXQgbGlua05vZGUgPSBudWxsO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2Rlcykge1xuICAgICAgaWYgKCFub2RlLmlzQXR0YWNoZWQoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudExpbmtOb2RlID0gJGdldEFuY2VzdG9yKG5vZGUsICRpc0xpbmtOb2RlKTtcbiAgICAgIGlmIChwYXJlbnRMaW5rTm9kZSkge1xuICAgICAgICB1cGRhdGVMaW5rTm9kZShwYXJlbnRMaW5rTm9kZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCRpc0VsZW1lbnROb2RlKG5vZGUpKSB7XG4gICAgICAgIGlmICghbm9kZS5pc0lubGluZSgpKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGJsb2NrIG5vZGVzLCBpZiB0aGVyZSBhcmUgYW55IGNoaWxkcmVuIHdlIHdpbGwgc2VlIHRoZW1cbiAgICAgICAgICAvLyBsYXRlciBhbmQgd3JhcCBpbiBhIG5ldyBMaW5rTm9kZVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgkaXNMaW5rTm9kZShub2RlKSkge1xuICAgICAgICAgIC8vIElmIGl0J3Mgbm90IGFuIGF1dG9saW5rIG5vZGUgYW5kIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIExpbmtOb2RlXG4gICAgICAgICAgLy8gaW4gdGhpcyBibG9jayB0aGVuIHdlIGNhbiB1cGRhdGUgaXQgYW5kIHJlLXVzZSBpdFxuICAgICAgICAgIGlmICghJGlzQXV0b0xpbmtOb2RlKG5vZGUpICYmIChsaW5rTm9kZSA9PT0gbnVsbCB8fCAhbGlua05vZGUuZ2V0UGFyZW50T3JUaHJvdygpLmlzUGFyZW50T2Yobm9kZSkpKSB7XG4gICAgICAgICAgICB1cGRhdGVMaW5rTm9kZShub2RlKTtcbiAgICAgICAgICAgIGxpbmtOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVbndyYXAgTGlua05vZGUsIHdlIGFscmVhZHkgaGF2ZSBvbmUgb3IgaXQncyBhbiBBdXRvTGlua05vZGVcbiAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuZ2V0Q2hpbGRyZW4oKSkge1xuICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnJlbW92ZSgpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBwcmV2TGlua05vZGUgPSBub2RlLmdldFByZXZpb3VzU2libGluZygpO1xuICAgICAgaWYgKCRpc0xpbmtOb2RlKHByZXZMaW5rTm9kZSkgJiYgcHJldkxpbmtOb2RlLmlzKGxpbmtOb2RlKSkge1xuICAgICAgICBwcmV2TGlua05vZGUuYXBwZW5kKG5vZGUpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxpbmtOb2RlID0gJGNyZWF0ZUxpbmtOb2RlKHVybCwge1xuICAgICAgICByZWwsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdGl0bGVcbiAgICAgIH0pO1xuICAgICAgbm9kZS5pbnNlcnRBZnRlcihsaW5rTm9kZSk7XG4gICAgICBsaW5rTm9kZS5hcHBlbmQobm9kZSk7XG4gICAgfVxuICB9KTtcbn1cbi8qKiBAZGVwcmVjYXRlZCByZW5hbWVkIHRvIHtAbGluayAkdG9nZ2xlTGlua30gYnkgQGxleGljYWwvZXNsaW50LXBsdWdpbiBydWxlcy1vZi1sZXhpY2FsICovXG5jb25zdCB0b2dnbGVMaW5rID0gJHRvZ2dsZUxpbms7XG5mdW5jdGlvbiAkZ2V0QW5jZXN0b3Iobm9kZSwgcHJlZGljYXRlKSB7XG4gIGxldCBwYXJlbnQgPSBub2RlO1xuICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC5nZXRQYXJlbnQoKSAhPT0gbnVsbCAmJiAhcHJlZGljYXRlKHBhcmVudCkpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQuZ2V0UGFyZW50T3JUaHJvdygpO1xuICB9XG4gIHJldHVybiBwcmVkaWNhdGUocGFyZW50KSA/IHBhcmVudCA6IG51bGw7XG59XG5jb25zdCBQSE9ORV9OVU1CRVJfUkVHRVggPSAvXlxcKz9bMC05XFxzKCktXXs1LH0kLztcblxuLyoqXG4gKiBGb3JtYXRzIGEgVVJMIHN0cmluZyBieSBhZGRpbmcgYXBwcm9wcmlhdGUgcHJvdG9jb2wgaWYgbWlzc2luZ1xuICpcbiAqIEBwYXJhbSB1cmwgLSBVUkwgdG8gZm9ybWF0XG4gKiBAcmV0dXJucyBGb3JtYXR0ZWQgVVJMIHdpdGggYXBwcm9wcmlhdGUgcHJvdG9jb2xcbiAqL1xuZnVuY3Rpb24gZm9ybWF0VXJsKHVybCkge1xuICAvLyBDaGVjayBpZiBVUkwgYWxyZWFkeSBoYXMgYSBwcm90b2NvbFxuICBpZiAodXJsLm1hdGNoKC9eW2Etel1bYS16MC05Ky4tXSo6L2kpKSB7XG4gICAgLy8gVVJMIGFscmVhZHkgaGFzIGEgcHJvdG9jb2wsIGxlYXZlIGl0IGFzIGlzXG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBDaGVjayBpZiBpdCdzIGEgcmVsYXRpdmUgcGF0aCAoc3RhcnRpbmcgd2l0aCAnLycsICcuJywgb3IgJyMnKVxuICBlbHNlIGlmICh1cmwubWF0Y2goL15bLyMuXS8pKSB7XG4gICAgLy8gUmVsYXRpdmUgcGF0aCwgbGVhdmUgaXQgYXMgaXNcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIGVtYWlsIGFkZHJlc3NcbiAgZWxzZSBpZiAodXJsLmluY2x1ZGVzKCdAJykpIHtcbiAgICByZXR1cm4gYG1haWx0bzoke3VybH1gO1xuICB9XG5cbiAgLy8gQ2hlY2sgZm9yIHBob25lIG51bWJlclxuICBlbHNlIGlmIChQSE9ORV9OVU1CRVJfUkVHRVgudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIGB0ZWw6JHt1cmx9YDtcbiAgfVxuXG4gIC8vIEZvciBldmVyeXRoaW5nIGVsc2UsIHJldHVybiB3aXRoIGh0dHBzOi8vIHByZWZpeFxuICByZXR1cm4gYGh0dHBzOi8vJHt1cmx9YDtcbn1cblxuZXhwb3J0IHsgJGNyZWF0ZUF1dG9MaW5rTm9kZSwgJGNyZWF0ZUxpbmtOb2RlLCAkaXNBdXRvTGlua05vZGUsICRpc0xpbmtOb2RlLCAkdG9nZ2xlTGluaywgQXV0b0xpbmtOb2RlLCBMaW5rTm9kZSwgVE9HR0xFX0xJTktfQ09NTUFORCwgZm9ybWF0VXJsLCB0b2dnbGVMaW5rIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+link@0.35.0/node_modules/@lexical/link/LexicalLink.dev.mjs\n");

/***/ })

};
;