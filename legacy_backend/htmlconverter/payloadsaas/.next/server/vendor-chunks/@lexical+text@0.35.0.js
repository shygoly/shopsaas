"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@lexical+text@0.35.0";
exports.ids = ["vendor-chunks/@lexical+text@0.35.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@lexical+text@0.35.0/node_modules/@lexical/text/LexicalText.dev.mjs":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@lexical+text@0.35.0/node_modules/@lexical/text/LexicalText.dev.mjs ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   $canShowPlaceholder: () => (/* binding */ $canShowPlaceholder),\n/* harmony export */   $canShowPlaceholderCurry: () => (/* binding */ $canShowPlaceholderCurry),\n/* harmony export */   $findTextIntersectionFromCharacters: () => (/* binding */ $findTextIntersectionFromCharacters),\n/* harmony export */   $isRootTextContentEmpty: () => (/* binding */ $isRootTextContentEmpty),\n/* harmony export */   $isRootTextContentEmptyCurry: () => (/* binding */ $isRootTextContentEmptyCurry),\n/* harmony export */   $rootTextContent: () => (/* binding */ $rootTextContent),\n/* harmony export */   registerLexicalTextEntity: () => (/* binding */ registerLexicalTextEntity)\n/* harmony export */ });\n/* harmony import */ var lexical__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lexical */ \"(ssr)/./node_modules/.pnpm/lexical@0.35.0/node_modules/lexical/Lexical.dev.mjs\");\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Returns the root's text content.\n * @returns The root's text content.\n */\nfunction $rootTextContent() {\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  return root.getTextContent();\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the root has any text content and can trim any whitespace if it does.\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns true if text content is empty, false if there is text or isEditorComposing is true.\n */\nfunction $isRootTextContentEmpty(isEditorComposing, trim = true) {\n  if (isEditorComposing) {\n    return false;\n  }\n  let text = $rootTextContent();\n  if (trim) {\n    text = text.trim();\n  }\n  return text === '';\n}\n\n/**\n * Returns a function that executes {@link $isRootTextContentEmpty}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @param trim - Should the root text have its whitespaced trimmed? Defaults to true.\n * @returns A function that executes $isRootTextContentEmpty based on arguments.\n */\nfunction $isRootTextContentEmptyCurry(isEditorComposing, trim) {\n  return () => $isRootTextContentEmpty(isEditorComposing, trim);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Determines if the input should show the placeholder. If anything is in\n * in the root the placeholder should not be shown.\n * @param isComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns true if the input should show the placeholder, false otherwise.\n */\nfunction $canShowPlaceholder(isComposing) {\n  if (!$isRootTextContentEmpty(isComposing, false)) {\n    return false;\n  }\n  const root = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$getRoot)();\n  const children = root.getChildren();\n  const childrenLength = children.length;\n  if (childrenLength > 1) {\n    return false;\n  }\n  for (let i = 0; i < childrenLength; i++) {\n    const topBlock = children[i];\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isDecoratorNode)(topBlock)) {\n      return false;\n    }\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(topBlock)) {\n      if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isParagraphNode)(topBlock)) {\n        return false;\n      }\n      if (topBlock.__indent !== 0) {\n        return false;\n      }\n      const topBlockChildren = topBlock.getChildren();\n      const topBlockChildrenLength = topBlockChildren.length;\n      for (let s = 0; s < topBlockChildrenLength; s++) {\n        const child = topBlockChildren[i];\n        if (!(0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(child)) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * Returns a function that executes {@link $canShowPlaceholder}\n * @param isEditorComposing - Is the editor in composition mode due to an active Input Method Editor?\n * @returns A function that executes $canShowPlaceholder with arguments.\n */\nfunction $canShowPlaceholderCurry(isEditorComposing) {\n  return () => $canShowPlaceholder(isEditorComposing);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/**\n * Finds a TextNode with a size larger than targetCharacters and returns\n * the node along with the remaining length of the text.\n * @param root - The RootNode.\n * @param targetCharacters - The number of characters whose TextNode must be larger than.\n * @returns The TextNode and the intersections offset, or null if no TextNode is found.\n */\nfunction $findTextIntersectionFromCharacters(root, targetCharacters) {\n  let node = root.getFirstChild();\n  let currentCharacters = 0;\n  mainLoop: while (node !== null) {\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isElementNode)(node)) {\n      const child = node.getFirstChild();\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n    } else if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(node)) {\n      const characters = node.getTextContentSize();\n      if (currentCharacters + characters > targetCharacters) {\n        return {\n          node,\n          offset: targetCharacters - currentCharacters\n        };\n      }\n      currentCharacters += characters;\n    }\n    const sibling = node.getNextSibling();\n    if (sibling !== null) {\n      node = sibling;\n      continue;\n    }\n    let parent = node.getParent();\n    while (parent !== null) {\n      const parentSibling = parent.getNextSibling();\n      if (parentSibling !== null) {\n        node = parentSibling;\n        continue mainLoop;\n      }\n      parent = parent.getParent();\n    }\n    break;\n  }\n  return null;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n// Do not require this module directly! Use normal `invariant` calls.\n\nfunction formatDevErrorMessage(message) {\n  throw new Error(message);\n}\n\n/**\n * Returns a tuple that can be rested (...) into mergeRegister to clean up\n * node transforms listeners that transforms text into another node, eg. a HashtagNode.\n * @example\n * ```ts\n *   useEffect(() => {\n    return mergeRegister(\n      ...registerLexicalTextEntity(editor, getMatch, targetNode, createNode),\n    );\n  }, [createNode, editor, getMatch, targetNode]);\n * ```\n * Where targetNode is the type of node containing the text you want to transform (like a text input),\n * then getMatch uses a regex to find a matching text and creates the proper node to include the matching text.\n * @param editor - The lexical editor.\n * @param getMatch - Finds a matching string that satisfies a regex expression.\n * @param targetNode - The node type that contains text to match with. eg. HashtagNode\n * @param createNode - A function that creates a new node to contain the matched text. eg createHashtagNode\n * @returns An array containing the plain text and reverse node transform listeners.\n */\nfunction registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {\n  const isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n  const $replaceWithSimpleText = node => {\n    const textNode = (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$createTextNode)(node.getTextContent());\n    textNode.setFormat(node.getFormat());\n    node.replace(textNode);\n  };\n  const getMode = node => {\n    return node.getLatest().__mode;\n  };\n  const $textNodeTransform = node => {\n    if (!node.isSimpleText()) {\n      return;\n    }\n    let prevSibling = node.getPreviousSibling();\n    let text = node.getTextContent();\n    let currentNode = node;\n    let match;\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling)) {\n      const previousText = prevSibling.getTextContent();\n      const combinedText = previousText + text;\n      const prevMatch = getMatch(combinedText);\n      if (isTargetNode(prevSibling)) {\n        if (prevMatch === null || getMode(prevSibling) !== 0) {\n          $replaceWithSimpleText(prevSibling);\n          return;\n        } else {\n          const diff = prevMatch.end - previousText.length;\n          if (diff > 0) {\n            const concatText = text.slice(0, diff);\n            const newTextContent = previousText + concatText;\n            prevSibling.select();\n            prevSibling.setTextContent(newTextContent);\n            if (diff === text.length) {\n              node.remove();\n            } else {\n              const remainingText = text.slice(diff);\n              node.setTextContent(remainingText);\n            }\n            return;\n          }\n        }\n      } else if (prevMatch === null || prevMatch.start < previousText.length) {\n        return;\n      }\n    }\n    let prevMatchLengthToSkip = 0;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      match = getMatch(text);\n      let nextText = match === null ? '' : text.slice(match.end);\n      text = nextText;\n      if (nextText === '') {\n        const nextSibling = currentNode.getNextSibling();\n        if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling)) {\n          nextText = currentNode.getTextContent() + nextSibling.getTextContent();\n          const nextMatch = getMatch(nextText);\n          if (nextMatch === null) {\n            if (isTargetNode(nextSibling)) {\n              $replaceWithSimpleText(nextSibling);\n            } else {\n              nextSibling.markDirty();\n            }\n            return;\n          } else if (nextMatch.start !== 0) {\n            return;\n          }\n        }\n      }\n      if (match === null) {\n        return;\n      }\n      if (match.start === 0 && (0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n        prevMatchLengthToSkip += match.end;\n        continue;\n      }\n      let nodeToReplace;\n      if (match.start === 0) {\n        [nodeToReplace, currentNode] = currentNode.splitText(match.end);\n      } else {\n        [, nodeToReplace, currentNode] = currentNode.splitText(match.start + prevMatchLengthToSkip, match.end + prevMatchLengthToSkip);\n      }\n      if (!(nodeToReplace !== undefined)) {\n        formatDevErrorMessage(`${'nodeToReplace'} should not be undefined. You may want to check splitOffsets passed to the splitText.`);\n      }\n      const replacementNode = createNode(nodeToReplace);\n      replacementNode.setFormat(nodeToReplace.getFormat());\n      nodeToReplace.replace(replacementNode);\n      if (currentNode == null) {\n        return;\n      }\n      prevMatchLengthToSkip = 0;\n      prevSibling = replacementNode;\n    }\n  };\n  const $reverseNodeTransform = node => {\n    const text = node.getTextContent();\n    const match = getMatch(text);\n    if (match === null || match.start !== 0) {\n      $replaceWithSimpleText(node);\n      return;\n    }\n    if (text.length > match.end) {\n      // This will split out the rest of the text as simple text\n      node.splitText(match.end);\n      return;\n    }\n    const prevSibling = node.getPreviousSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(prevSibling) && prevSibling.isTextEntity()) {\n      $replaceWithSimpleText(prevSibling);\n      $replaceWithSimpleText(node);\n    }\n    const nextSibling = node.getNextSibling();\n    if ((0,lexical__WEBPACK_IMPORTED_MODULE_0__.$isTextNode)(nextSibling) && nextSibling.isTextEntity()) {\n      $replaceWithSimpleText(nextSibling);\n\n      // This may have already been converted in the previous block\n      if (isTargetNode(node)) {\n        $replaceWithSimpleText(node);\n      }\n    }\n  };\n  const removePlainTextTransform = editor.registerNodeTransform(lexical__WEBPACK_IMPORTED_MODULE_0__.TextNode, $textNodeTransform);\n  const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, $reverseNodeTransform);\n  return [removePlainTextTransform, removeReverseNodeTransform];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQGxleGljYWwrdGV4dEAwLjM1LjAvbm9kZV9tb2R1bGVzL0BsZXhpY2FsL3RleHQvTGV4aWNhbFRleHQuZGV2Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrSDs7QUFFL0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVE7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaURBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixvQkFBb0I7QUFDdEM7QUFDQSxRQUFRLHlEQUFnQjtBQUN4QjtBQUNBO0FBQ0EsUUFBUSx1REFBYztBQUN0QixXQUFXLHlEQUFnQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiw0QkFBNEI7QUFDbEQ7QUFDQSxhQUFhLG9EQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1REFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxTQUFTLG9EQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsd0RBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isb0RBQVc7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvREFBVztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0RBQVc7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLDZDQUFRO0FBQ3hFO0FBQ0E7QUFDQTs7QUFFa00iLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYWMvU3luYy9wcm9qZWN0L2Vjb21tZXJjZS9zaG9wc2Fhcy9odG1sY29udmVydGVyL3BheWxvYWRzYWFzL25vZGVfbW9kdWxlcy8ucG5wbS9AbGV4aWNhbCt0ZXh0QDAuMzUuMC9ub2RlX21vZHVsZXMvQGxleGljYWwvdGV4dC9MZXhpY2FsVGV4dC5kZXYubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuaW1wb3J0IHsgJGdldFJvb3QsICRpc0RlY29yYXRvck5vZGUsICRpc0VsZW1lbnROb2RlLCAkaXNQYXJhZ3JhcGhOb2RlLCAkaXNUZXh0Tm9kZSwgVGV4dE5vZGUsICRjcmVhdGVUZXh0Tm9kZSB9IGZyb20gJ2xleGljYWwnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbi8qKlxuICogUmV0dXJucyB0aGUgcm9vdCdzIHRleHQgY29udGVudC5cbiAqIEByZXR1cm5zIFRoZSByb290J3MgdGV4dCBjb250ZW50LlxuICovXG5mdW5jdGlvbiAkcm9vdFRleHRDb250ZW50KCkge1xuICBjb25zdCByb290ID0gJGdldFJvb3QoKTtcbiAgcmV0dXJuIHJvb3QuZ2V0VGV4dENvbnRlbnQoKTtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhlIHJvb3QgaGFzIGFueSB0ZXh0IGNvbnRlbnQgYW5kIGNhbiB0cmltIGFueSB3aGl0ZXNwYWNlIGlmIGl0IGRvZXMuXG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHBhcmFtIHRyaW0gLSBTaG91bGQgdGhlIHJvb3QgdGV4dCBoYXZlIGl0cyB3aGl0ZXNwYWNlZCB0cmltbWVkPyBEZWZhdWx0cyB0byB0cnVlLlxuICogQHJldHVybnMgdHJ1ZSBpZiB0ZXh0IGNvbnRlbnQgaXMgZW1wdHksIGZhbHNlIGlmIHRoZXJlIGlzIHRleHQgb3IgaXNFZGl0b3JDb21wb3NpbmcgaXMgdHJ1ZS5cbiAqL1xuZnVuY3Rpb24gJGlzUm9vdFRleHRDb250ZW50RW1wdHkoaXNFZGl0b3JDb21wb3NpbmcsIHRyaW0gPSB0cnVlKSB7XG4gIGlmIChpc0VkaXRvckNvbXBvc2luZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsZXQgdGV4dCA9ICRyb290VGV4dENvbnRlbnQoKTtcbiAgaWYgKHRyaW0pIHtcbiAgICB0ZXh0ID0gdGV4dC50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHRleHQgPT09ICcnO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzIHtAbGluayAkaXNSb290VGV4dENvbnRlbnRFbXB0eX1cbiAqIEBwYXJhbSBpc0VkaXRvckNvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcGFyYW0gdHJpbSAtIFNob3VsZCB0aGUgcm9vdCB0ZXh0IGhhdmUgaXRzIHdoaXRlc3BhY2VkIHRyaW1tZWQ/IERlZmF1bHRzIHRvIHRydWUuXG4gKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMgJGlzUm9vdFRleHRDb250ZW50RW1wdHkgYmFzZWQgb24gYXJndW1lbnRzLlxuICovXG5mdW5jdGlvbiAkaXNSb290VGV4dENvbnRlbnRFbXB0eUN1cnJ5KGlzRWRpdG9yQ29tcG9zaW5nLCB0cmltKSB7XG4gIHJldHVybiAoKSA9PiAkaXNSb290VGV4dENvbnRlbnRFbXB0eShpc0VkaXRvckNvbXBvc2luZywgdHJpbSk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIuIElmIGFueXRoaW5nIGlzIGluXG4gKiBpbiB0aGUgcm9vdCB0aGUgcGxhY2Vob2xkZXIgc2hvdWxkIG5vdCBiZSBzaG93bi5cbiAqIEBwYXJhbSBpc0NvbXBvc2luZyAtIElzIHRoZSBlZGl0b3IgaW4gY29tcG9zaXRpb24gbW9kZSBkdWUgdG8gYW4gYWN0aXZlIElucHV0IE1ldGhvZCBFZGl0b3I/XG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBpbnB1dCBzaG91bGQgc2hvdyB0aGUgcGxhY2Vob2xkZXIsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gJGNhblNob3dQbGFjZWhvbGRlcihpc0NvbXBvc2luZykge1xuICBpZiAoISRpc1Jvb3RUZXh0Q29udGVudEVtcHR5KGlzQ29tcG9zaW5nLCBmYWxzZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3Qgcm9vdCA9ICRnZXRSb290KCk7XG4gIGNvbnN0IGNoaWxkcmVuID0gcm9vdC5nZXRDaGlsZHJlbigpO1xuICBjb25zdCBjaGlsZHJlbkxlbmd0aCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b3BCbG9jayA9IGNoaWxkcmVuW2ldO1xuICAgIGlmICgkaXNEZWNvcmF0b3JOb2RlKHRvcEJsb2NrKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJGlzRWxlbWVudE5vZGUodG9wQmxvY2spKSB7XG4gICAgICBpZiAoISRpc1BhcmFncmFwaE5vZGUodG9wQmxvY2spKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICh0b3BCbG9jay5fX2luZGVudCAhPT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBjb25zdCB0b3BCbG9ja0NoaWxkcmVuID0gdG9wQmxvY2suZ2V0Q2hpbGRyZW4oKTtcbiAgICAgIGNvbnN0IHRvcEJsb2NrQ2hpbGRyZW5MZW5ndGggPSB0b3BCbG9ja0NoaWxkcmVuLmxlbmd0aDtcbiAgICAgIGZvciAobGV0IHMgPSAwOyBzIDwgdG9wQmxvY2tDaGlsZHJlbkxlbmd0aDsgcysrKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gdG9wQmxvY2tDaGlsZHJlbltpXTtcbiAgICAgICAgaWYgKCEkaXNUZXh0Tm9kZShjaGlsZCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgZXhlY3V0ZXMge0BsaW5rICRjYW5TaG93UGxhY2Vob2xkZXJ9XG4gKiBAcGFyYW0gaXNFZGl0b3JDb21wb3NpbmcgLSBJcyB0aGUgZWRpdG9yIGluIGNvbXBvc2l0aW9uIG1vZGUgZHVlIHRvIGFuIGFjdGl2ZSBJbnB1dCBNZXRob2QgRWRpdG9yP1xuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGV4ZWN1dGVzICRjYW5TaG93UGxhY2Vob2xkZXIgd2l0aCBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uICRjYW5TaG93UGxhY2Vob2xkZXJDdXJyeShpc0VkaXRvckNvbXBvc2luZykge1xuICByZXR1cm4gKCkgPT4gJGNhblNob3dQbGFjZWhvbGRlcihpc0VkaXRvckNvbXBvc2luZyk7XG59XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuLyoqXG4gKiBGaW5kcyBhIFRleHROb2RlIHdpdGggYSBzaXplIGxhcmdlciB0aGFuIHRhcmdldENoYXJhY3RlcnMgYW5kIHJldHVybnNcbiAqIHRoZSBub2RlIGFsb25nIHdpdGggdGhlIHJlbWFpbmluZyBsZW5ndGggb2YgdGhlIHRleHQuXG4gKiBAcGFyYW0gcm9vdCAtIFRoZSBSb290Tm9kZS5cbiAqIEBwYXJhbSB0YXJnZXRDaGFyYWN0ZXJzIC0gVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHdob3NlIFRleHROb2RlIG11c3QgYmUgbGFyZ2VyIHRoYW4uXG4gKiBAcmV0dXJucyBUaGUgVGV4dE5vZGUgYW5kIHRoZSBpbnRlcnNlY3Rpb25zIG9mZnNldCwgb3IgbnVsbCBpZiBubyBUZXh0Tm9kZSBpcyBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gJGZpbmRUZXh0SW50ZXJzZWN0aW9uRnJvbUNoYXJhY3RlcnMocm9vdCwgdGFyZ2V0Q2hhcmFjdGVycykge1xuICBsZXQgbm9kZSA9IHJvb3QuZ2V0Rmlyc3RDaGlsZCgpO1xuICBsZXQgY3VycmVudENoYXJhY3RlcnMgPSAwO1xuICBtYWluTG9vcDogd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAoJGlzRWxlbWVudE5vZGUobm9kZSkpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gbm9kZS5nZXRGaXJzdENoaWxkKCk7XG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCRpc1RleHROb2RlKG5vZGUpKSB7XG4gICAgICBjb25zdCBjaGFyYWN0ZXJzID0gbm9kZS5nZXRUZXh0Q29udGVudFNpemUoKTtcbiAgICAgIGlmIChjdXJyZW50Q2hhcmFjdGVycyArIGNoYXJhY3RlcnMgPiB0YXJnZXRDaGFyYWN0ZXJzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IHRhcmdldENoYXJhY3RlcnMgLSBjdXJyZW50Q2hhcmFjdGVyc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY3VycmVudENoYXJhY3RlcnMgKz0gY2hhcmFjdGVycztcbiAgICB9XG4gICAgY29uc3Qgc2libGluZyA9IG5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgbm9kZSA9IHNpYmxpbmc7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuZ2V0UGFyZW50KCk7XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50U2libGluZyA9IHBhcmVudC5nZXROZXh0U2libGluZygpO1xuICAgICAgaWYgKHBhcmVudFNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZSA9IHBhcmVudFNpYmxpbmc7XG4gICAgICAgIGNvbnRpbnVlIG1haW5Mb29wO1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50LmdldFBhcmVudCgpO1xuICAgIH1cbiAgICBicmVhaztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4vLyBEbyBub3QgcmVxdWlyZSB0aGlzIG1vZHVsZSBkaXJlY3RseSEgVXNlIG5vcm1hbCBgaW52YXJpYW50YCBjYWxscy5cblxuZnVuY3Rpb24gZm9ybWF0RGV2RXJyb3JNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSB0dXBsZSB0aGF0IGNhbiBiZSByZXN0ZWQgKC4uLikgaW50byBtZXJnZVJlZ2lzdGVyIHRvIGNsZWFuIHVwXG4gKiBub2RlIHRyYW5zZm9ybXMgbGlzdGVuZXJzIHRoYXQgdHJhbnNmb3JtcyB0ZXh0IGludG8gYW5vdGhlciBub2RlLCBlZy4gYSBIYXNodGFnTm9kZS5cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHJldHVybiBtZXJnZVJlZ2lzdGVyKFxuICAgICAgLi4ucmVnaXN0ZXJMZXhpY2FsVGV4dEVudGl0eShlZGl0b3IsIGdldE1hdGNoLCB0YXJnZXROb2RlLCBjcmVhdGVOb2RlKSxcbiAgICApO1xuICB9LCBbY3JlYXRlTm9kZSwgZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZV0pO1xuICogYGBgXG4gKiBXaGVyZSB0YXJnZXROb2RlIGlzIHRoZSB0eXBlIG9mIG5vZGUgY29udGFpbmluZyB0aGUgdGV4dCB5b3Ugd2FudCB0byB0cmFuc2Zvcm0gKGxpa2UgYSB0ZXh0IGlucHV0KSxcbiAqIHRoZW4gZ2V0TWF0Y2ggdXNlcyBhIHJlZ2V4IHRvIGZpbmQgYSBtYXRjaGluZyB0ZXh0IGFuZCBjcmVhdGVzIHRoZSBwcm9wZXIgbm9kZSB0byBpbmNsdWRlIHRoZSBtYXRjaGluZyB0ZXh0LlxuICogQHBhcmFtIGVkaXRvciAtIFRoZSBsZXhpY2FsIGVkaXRvci5cbiAqIEBwYXJhbSBnZXRNYXRjaCAtIEZpbmRzIGEgbWF0Y2hpbmcgc3RyaW5nIHRoYXQgc2F0aXNmaWVzIGEgcmVnZXggZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSB0YXJnZXROb2RlIC0gVGhlIG5vZGUgdHlwZSB0aGF0IGNvbnRhaW5zIHRleHQgdG8gbWF0Y2ggd2l0aC4gZWcuIEhhc2h0YWdOb2RlXG4gKiBAcGFyYW0gY3JlYXRlTm9kZSAtIEEgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IG5vZGUgdG8gY29udGFpbiB0aGUgbWF0Y2hlZCB0ZXh0LiBlZyBjcmVhdGVIYXNodGFnTm9kZVxuICogQHJldHVybnMgQW4gYXJyYXkgY29udGFpbmluZyB0aGUgcGxhaW4gdGV4dCBhbmQgcmV2ZXJzZSBub2RlIHRyYW5zZm9ybSBsaXN0ZW5lcnMuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkoZWRpdG9yLCBnZXRNYXRjaCwgdGFyZ2V0Tm9kZSwgY3JlYXRlTm9kZSkge1xuICBjb25zdCBpc1RhcmdldE5vZGUgPSBub2RlID0+IHtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIHRhcmdldE5vZGU7XG4gIH07XG4gIGNvbnN0ICRyZXBsYWNlV2l0aFNpbXBsZVRleHQgPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0Tm9kZSA9ICRjcmVhdGVUZXh0Tm9kZShub2RlLmdldFRleHRDb250ZW50KCkpO1xuICAgIHRleHROb2RlLnNldEZvcm1hdChub2RlLmdldEZvcm1hdCgpKTtcbiAgICBub2RlLnJlcGxhY2UodGV4dE5vZGUpO1xuICB9O1xuICBjb25zdCBnZXRNb2RlID0gbm9kZSA9PiB7XG4gICAgcmV0dXJuIG5vZGUuZ2V0TGF0ZXN0KCkuX19tb2RlO1xuICB9O1xuICBjb25zdCAkdGV4dE5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBpZiAoIW5vZGUuaXNTaW1wbGVUZXh0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBsZXQgdGV4dCA9IG5vZGUuZ2V0VGV4dENvbnRlbnQoKTtcbiAgICBsZXQgY3VycmVudE5vZGUgPSBub2RlO1xuICAgIGxldCBtYXRjaDtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpKSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RleHQgPSBwcmV2U2libGluZy5nZXRUZXh0Q29udGVudCgpO1xuICAgICAgY29uc3QgY29tYmluZWRUZXh0ID0gcHJldmlvdXNUZXh0ICsgdGV4dDtcbiAgICAgIGNvbnN0IHByZXZNYXRjaCA9IGdldE1hdGNoKGNvbWJpbmVkVGV4dCk7XG4gICAgICBpZiAoaXNUYXJnZXROb2RlKHByZXZTaWJsaW5nKSkge1xuICAgICAgICBpZiAocHJldk1hdGNoID09PSBudWxsIHx8IGdldE1vZGUocHJldlNpYmxpbmcpICE9PSAwKSB7XG4gICAgICAgICAgJHJlcGxhY2VXaXRoU2ltcGxlVGV4dChwcmV2U2libGluZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IGRpZmYgPSBwcmV2TWF0Y2guZW5kIC0gcHJldmlvdXNUZXh0Lmxlbmd0aDtcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmNhdFRleHQgPSB0ZXh0LnNsaWNlKDAsIGRpZmYpO1xuICAgICAgICAgICAgY29uc3QgbmV3VGV4dENvbnRlbnQgPSBwcmV2aW91c1RleHQgKyBjb25jYXRUZXh0O1xuICAgICAgICAgICAgcHJldlNpYmxpbmcuc2VsZWN0KCk7XG4gICAgICAgICAgICBwcmV2U2libGluZy5zZXRUZXh0Q29udGVudChuZXdUZXh0Q29udGVudCk7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbm9kZS5yZW1vdmUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlbWFpbmluZ1RleHQgPSB0ZXh0LnNsaWNlKGRpZmYpO1xuICAgICAgICAgICAgICBub2RlLnNldFRleHRDb250ZW50KHJlbWFpbmluZ1RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmV2TWF0Y2ggPT09IG51bGwgfHwgcHJldk1hdGNoLnN0YXJ0IDwgcHJldmlvdXNUZXh0Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgPSAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgbWF0Y2ggPSBnZXRNYXRjaCh0ZXh0KTtcbiAgICAgIGxldCBuZXh0VGV4dCA9IG1hdGNoID09PSBudWxsID8gJycgOiB0ZXh0LnNsaWNlKG1hdGNoLmVuZCk7XG4gICAgICB0ZXh0ID0gbmV4dFRleHQ7XG4gICAgICBpZiAobmV4dFRleHQgPT09ICcnKSB7XG4gICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gY3VycmVudE5vZGUuZ2V0TmV4dFNpYmxpbmcoKTtcbiAgICAgICAgaWYgKCRpc1RleHROb2RlKG5leHRTaWJsaW5nKSkge1xuICAgICAgICAgIG5leHRUZXh0ID0gY3VycmVudE5vZGUuZ2V0VGV4dENvbnRlbnQoKSArIG5leHRTaWJsaW5nLmdldFRleHRDb250ZW50KCk7XG4gICAgICAgICAgY29uc3QgbmV4dE1hdGNoID0gZ2V0TWF0Y2gobmV4dFRleHQpO1xuICAgICAgICAgIGlmIChuZXh0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChpc1RhcmdldE5vZGUobmV4dFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV4dFNpYmxpbmcubWFya0RpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIGlmIChuZXh0TWF0Y2guc3RhcnQgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDAgJiYgJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAgIHByZXZNYXRjaExlbmd0aFRvU2tpcCArPSBtYXRjaC5lbmQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5vZGVUb1JlcGxhY2U7XG4gICAgICBpZiAobWF0Y2guc3RhcnQgPT09IDApIHtcbiAgICAgICAgW25vZGVUb1JlcGxhY2UsIGN1cnJlbnROb2RlXSA9IGN1cnJlbnROb2RlLnNwbGl0VGV4dChtYXRjaC5lbmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWywgbm9kZVRvUmVwbGFjZSwgY3VycmVudE5vZGVdID0gY3VycmVudE5vZGUuc3BsaXRUZXh0KG1hdGNoLnN0YXJ0ICsgcHJldk1hdGNoTGVuZ3RoVG9Ta2lwLCBtYXRjaC5lbmQgKyBwcmV2TWF0Y2hMZW5ndGhUb1NraXApO1xuICAgICAgfVxuICAgICAgaWYgKCEobm9kZVRvUmVwbGFjZSAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBmb3JtYXREZXZFcnJvck1lc3NhZ2UoYCR7J25vZGVUb1JlcGxhY2UnfSBzaG91bGQgbm90IGJlIHVuZGVmaW5lZC4gWW91IG1heSB3YW50IHRvIGNoZWNrIHNwbGl0T2Zmc2V0cyBwYXNzZWQgdG8gdGhlIHNwbGl0VGV4dC5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlcGxhY2VtZW50Tm9kZSA9IGNyZWF0ZU5vZGUobm9kZVRvUmVwbGFjZSk7XG4gICAgICByZXBsYWNlbWVudE5vZGUuc2V0Rm9ybWF0KG5vZGVUb1JlcGxhY2UuZ2V0Rm9ybWF0KCkpO1xuICAgICAgbm9kZVRvUmVwbGFjZS5yZXBsYWNlKHJlcGxhY2VtZW50Tm9kZSk7XG4gICAgICBpZiAoY3VycmVudE5vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwcmV2TWF0Y2hMZW5ndGhUb1NraXAgPSAwO1xuICAgICAgcHJldlNpYmxpbmcgPSByZXBsYWNlbWVudE5vZGU7XG4gICAgfVxuICB9O1xuICBjb25zdCAkcmV2ZXJzZU5vZGVUcmFuc2Zvcm0gPSBub2RlID0+IHtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS5nZXRUZXh0Q29udGVudCgpO1xuICAgIGNvbnN0IG1hdGNoID0gZ2V0TWF0Y2godGV4dCk7XG4gICAgaWYgKG1hdGNoID09PSBudWxsIHx8IG1hdGNoLnN0YXJ0ICE9PSAwKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KG5vZGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGV4dC5sZW5ndGggPiBtYXRjaC5lbmQpIHtcbiAgICAgIC8vIFRoaXMgd2lsbCBzcGxpdCBvdXQgdGhlIHJlc3Qgb2YgdGhlIHRleHQgYXMgc2ltcGxlIHRleHRcbiAgICAgIG5vZGUuc3BsaXRUZXh0KG1hdGNoLmVuZCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHByZXZTaWJsaW5nID0gbm9kZS5nZXRQcmV2aW91c1NpYmxpbmcoKTtcbiAgICBpZiAoJGlzVGV4dE5vZGUocHJldlNpYmxpbmcpICYmIHByZXZTaWJsaW5nLmlzVGV4dEVudGl0eSgpKSB7XG4gICAgICAkcmVwbGFjZVdpdGhTaW1wbGVUZXh0KHByZXZTaWJsaW5nKTtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5nZXROZXh0U2libGluZygpO1xuICAgIGlmICgkaXNUZXh0Tm9kZShuZXh0U2libGluZykgJiYgbmV4dFNpYmxpbmcuaXNUZXh0RW50aXR5KCkpIHtcbiAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobmV4dFNpYmxpbmcpO1xuXG4gICAgICAvLyBUaGlzIG1heSBoYXZlIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgaW4gdGhlIHByZXZpb3VzIGJsb2NrXG4gICAgICBpZiAoaXNUYXJnZXROb2RlKG5vZGUpKSB7XG4gICAgICAgICRyZXBsYWNlV2l0aFNpbXBsZVRleHQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0gPSBlZGl0b3IucmVnaXN0ZXJOb2RlVHJhbnNmb3JtKFRleHROb2RlLCAkdGV4dE5vZGVUcmFuc2Zvcm0pO1xuICBjb25zdCByZW1vdmVSZXZlcnNlTm9kZVRyYW5zZm9ybSA9IGVkaXRvci5yZWdpc3Rlck5vZGVUcmFuc2Zvcm0odGFyZ2V0Tm9kZSwgJHJldmVyc2VOb2RlVHJhbnNmb3JtKTtcbiAgcmV0dXJuIFtyZW1vdmVQbGFpblRleHRUcmFuc2Zvcm0sIHJlbW92ZVJldmVyc2VOb2RlVHJhbnNmb3JtXTtcbn1cblxuZXhwb3J0IHsgJGNhblNob3dQbGFjZWhvbGRlciwgJGNhblNob3dQbGFjZWhvbGRlckN1cnJ5LCAkZmluZFRleHRJbnRlcnNlY3Rpb25Gcm9tQ2hhcmFjdGVycywgJGlzUm9vdFRleHRDb250ZW50RW1wdHksICRpc1Jvb3RUZXh0Q29udGVudEVtcHR5Q3VycnksICRyb290VGV4dENvbnRlbnQsIHJlZ2lzdGVyTGV4aWNhbFRleHRFbnRpdHkgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@lexical+text@0.35.0/node_modules/@lexical/text/LexicalText.dev.mjs\n");

/***/ })

};
;